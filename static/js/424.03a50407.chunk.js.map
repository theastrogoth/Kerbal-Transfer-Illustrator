{"version":3,"file":"static/js/424.03a50407.chunk.js","mappings":"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","sources":["main/libs/departarrive.ts","main/libs/flybycalcs.ts","main/libs/kepler.ts","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"],"sourcesContent":["import FlybyCalcs from \"./flybycalcs\";\nimport Kepler from \"./kepler\";\nimport { TWO_PI, X_DIR, Y_DIR, Z_DIR, copysign, acosClamped, wrapAngle, vec3, magSq3, mag3, normalize3, add3, sub3, div3, mult3, dot3, cross3, roderigues, counterClockwiseAngleInPlane, alignVectorsAngleAxis, clamp } from \"./math\"\nimport { brentRootFind, brentMinimize } from \"./optim\"\n\n// const blankOrbit: IOrbit = {\n//     orbiting:   -1,\n//     semiMajorAxis: 0,\n//     eccentricity: 0,\n//     inclination: 0,\n//     argOfPeriapsis: 0,\n//     ascNodeLongitude: 0,\n//     meanAnomalyEpoch: 0,\n//     epoch: 0,\n//     siderealPeriod: 0,\n//     semiLatusRectum: 0,\n// }\n\nnamespace DepartArrive {\n    // \"Direct\" ejection/insertion\n    export function fastDeparture(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, matchParkMo: boolean = true): Trajectory {\n        return fastDepartureArrival(parkOrbit, parkBody, relativeVel, soiDate, true, matchParkMo)\n    }\n\n    export function fastArrival(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, matchParkMo: boolean = true): Trajectory {\n        return fastDepartureArrival(parkOrbit, parkBody, relativeVel, soiDate, false, matchParkMo)\n    }\n\n    export function fastDepartureArrival(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, ejection: boolean, matchParkMo: boolean = true): Trajectory {     \n        const c = ejection ? 1 : -1;\n        const mu = parkBody.stdGravParam;\n        const soi = parkBody.soi;\n        const soiSpeedSq = magSq3(relativeVel);\n\n        const a = 1 / (2 / soi - soiSpeedSq / mu);\n        const etol = 1e-8;\n\n        // Rotate the relative velocity to the perifocal frame of the parking orbit\n        const relativeVelPlane = Kepler.rotateToPerifocalFromInertial(relativeVel, parkOrbit);\n\n        // If the orbit is circular, there is no need to search for a periapsis height\n        let periapsis = parkOrbit.semiMajorAxis;\n\n        // use Brent's method to find when the difference between the departure/arrival hyperbola and parking orbit radius is 0\n        if(parkOrbit.eccentricity > etol) {\n            const periapsisErr = (periapsis: number) => {\n                const res = fastDepartureArrivalForPeriapsis(periapsis, parkOrbit, mu, soi, relativeVelPlane, soiSpeedSq, a, c);\n                return res.err\n            }\n            const min = parkOrbit.semiMajorAxis * (1 - parkOrbit.eccentricity);\n            const max = parkOrbit.eccentricity > 1 ? soi : parkOrbit.semiMajorAxis * (1 + parkOrbit.eccentricity);\n            periapsis = brentRootFind(periapsisErr, min, max);\n        }\n        const {parkNu, e, soiNu, pPos, pVel} = fastDepartureArrivalForPeriapsis(periapsis, parkOrbit, mu, soi, relativeVelPlane, soiSpeedSq, a, c);\n\n        const deltaT = Kepler.trueAnomalyToDate(soiNu, e, Kepler.siderealPeriod(a, mu), 0, 0);\n\n        const periapsisDate = matchParkMo ? Kepler.trueAnomalyToOrbitDate(parkNu, parkOrbit, soiDate - deltaT - parkOrbit.siderealPeriod / 2) \n                                          : soiDate - deltaT;\n        const periapsisState = {\n            date:   periapsisDate,\n            pos:    pPos,\n            vel:    pVel,\n        };\n        \n        const parkState = {\n            date:   periapsisDate,\n            pos:    pPos,\n            vel:    Kepler.velocityAtTrueAnomaly(parkOrbit, mu, parkNu),\n        };\n        const orbit = Kepler.stateToOrbit(periapsisState, parkBody);\n\n        if(c === 1) {\n            const maneuver = Kepler.maneuverFromOrbitalStates(parkState, periapsisState);\n            return {\n                orbits:             [orbit], \n                intersectTimes:     [orbit.epoch, orbit.epoch + deltaT],\n                maneuvers:          [maneuver],\n            }\n        } else {\n            const maneuver = Kepler.maneuverFromOrbitalStates(periapsisState, parkState);\n            return {\n                orbits:             [orbit], \n                intersectTimes:     [orbit.epoch + deltaT, orbit.epoch],\n                maneuvers:          [maneuver],\n            }\n        }\n    }\n\n    function fastDepartureArrivalForPeriapsis(periapsis: number, parkOrbit: IOrbit, mu: number, soi: number, relativeVelPlane: Vector3, soiSpeedSq: number, a: number, c: 1 | -1) {\n\n        const pSpeedSq = soiSpeedSq + 2 * mu * (1 / periapsis - 1 / soi);\n        const pSpeed = Math.sqrt(pSpeedSq);\n\n        const e = Math.sqrt(1 + 2 * (0.5 * pSpeedSq - mu / periapsis) * periapsis * periapsis * pSpeedSq / mu  / mu);\n        const p = a * (1 - e*e);\n\n        // Start in perifocal coordinates of the ejection/insertion orbit\n        // The assumption is made that the periapsis of the ejection/insertion orbit intersects with the parking orbit (which is not necessarily optimal, but is good for near-circular cases)\n        const soiNu = c * Kepler.trueAnomalyAtDistance(soi, e, p);\n        let soiVel = mult3(Kepler.motionDirectionAtTrueAnomaly(soiNu, e), Math.sqrt(soiSpeedSq));\n        let pPos = mult3(X_DIR, periapsis);\n        let pVel = mult3(Y_DIR, pSpeed);\n\n        // Rotate about the x-axis to match the inclination of the relative velocity (in the plane of the parking orbit)\n        const rotAngle1 = Math.atan2(relativeVelPlane.z, Math.sqrt(Math.abs(soiVel.y*soiVel.y - relativeVelPlane.z*relativeVelPlane.z)));\n        soiVel = roderigues(soiVel, X_DIR, rotAngle1);\n        pPos = roderigues(pPos, X_DIR, rotAngle1);\n        pVel = roderigues(pVel, X_DIR, rotAngle1);\n\n        // Rotate about the z-axs to match the direction of the relative velocity (in the plane of the parking orbit)\n        const rotAngle2 = Math.atan2(relativeVelPlane.y, relativeVelPlane.x) - Math.atan2(soiVel.y, soiVel.x);\n        soiVel = roderigues(soiVel, Z_DIR, rotAngle2);\n        pPos = roderigues(pPos, Z_DIR, rotAngle2);\n        pVel = roderigues(pVel, Z_DIR, rotAngle2);\n\n        // Rotate back into the reference plane\n        soiVel = Kepler.rotateToInertialFromPerifocal(soiVel, parkOrbit);\n        pPos = Kepler.rotateToInertialFromPerifocal(pPos, parkOrbit);\n        pVel = Kepler.rotateToInertialFromPerifocal(pVel, parkOrbit);\n\n        // check error in periapsis height against parking orbit\n        const parkNu = Kepler.angleInOrbitPlane(pPos, parkOrbit);\n        const parkRadius = Kepler.distanceAtOrbitTrueAnomaly(parkNu, parkOrbit);\n        const err = periapsis - parkRadius;\n        return {err,  parkNu, e, soiNu, pPos, pVel}\n    }\n\n    // \"Oberth\" ejection/insertion\n    export function fastOberthDeparture(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, matchParkMo: boolean = true, soiPatchPosition: Vector3 = vec3(0,0,0)): Trajectory {\n        return fastOberthDepartureArrival(parkOrbit, parkBody, relativeVel, soiDate, true, matchParkMo, soiPatchPosition);\n    }\n\n    export function fastOberthArrival(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, matchParkMo: boolean = true, soiPatchPosition: Vector3 = vec3(0,0,0)): Trajectory {\n        return fastOberthDepartureArrival(parkOrbit, parkBody, relativeVel, soiDate, false, matchParkMo, soiPatchPosition);\n    }\n    \n    function fastOberthDepartureArrival(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, ejection: boolean, matchParkMo: boolean = true, soiPatchPosition: Vector3 = vec3(0,0,0)): Trajectory {\n        const c = ejection ? 1 : -1;\n        const mu = parkBody.stdGravParam;\n        const soi = parkBody.soi;\n        const soiSpeedSq = magSq3(relativeVel);\n\n        // set the slingshot radius\n        const periapsis = FlybyCalcs.minFlybyRadius(parkBody);\n\n        // incoming/outgoing orbit details (should be completely defined)\n        const hypSMA = 1 / (2 / soi - soiSpeedSq / mu);\n        const hypEcc    = 1 - periapsis / hypSMA;\n        const hypSLR    = hypSMA  * (1 - hypEcc  * hypEcc); \n        const hypNu     = c * Kepler.trueAnomalyAtDistance(soi, hypEcc,  hypSLR);   // true anomaly at SoI\n        const obrNu     = -c * Math.PI\n\n        const hypDelta  = Kepler.motionAngleAtTrueAnomaly(hypNu, hypEcc);           // angle of motion direction at SoI\n\n        const delta     = c * (hypDelta - obrNu);\n\n        // Find the true anomaly for the parking orbit that makes the Oberth orbit a half-ellipse\n        let parkNu = wrapAngle(Kepler.angleInOrbitPlane(relativeVel, parkOrbit) - c * delta);\n\n        const parkNuObj = (parkNu: number) => {\n            const parkPos = Kepler.positionAtTrueAnomaly(parkOrbit, parkNu);\n            const startPos = add3(parkPos, soiPatchPosition);\n            let nDir = normalize3(cross3(startPos, relativeVel));    // direction normal to the trajectory plane\n            if(nDir.z < 0) {\n                nDir = mult3(nDir, -1);\n            }\n            const deltaForNu = c === 1 ? counterClockwiseAngleInPlane(startPos, relativeVel, nDir) : // angle between incoming and outgoing velocity vectors (flyby angle)\n                                         counterClockwiseAngleInPlane(relativeVel, startPos, nDir) \n            return Math.abs(deltaForNu - delta);\n        }\n        parkNu = parkOrbit.eccentricity < 1 ? brentMinimize(parkNuObj, parkNu - Math.PI, parkNu + Math.PI) \n                                            : brentMinimize(parkNuObj, insertionTrueAnomaly(parkOrbit, parkBody), ejectionTrueAnomaly(parkOrbit, parkBody));\n\n        // set positions and speeds\n        const parkPos  = Kepler.positionAtTrueAnomaly(parkOrbit, parkNu);\n        const startPos = add3(parkPos, soiPatchPosition);\n        let nDir = normalize3(cross3(startPos, relativeVel));    // direction normal to the trajectory plane\n        if(nDir.z < 0) {\n            nDir = mult3(nDir, -1);\n        }\n\n        const apoapsis  = mag3(startPos);\n\n        const soiVelSq = magSq3(relativeVel);\n        const hypEnergy  = soiVelSq  / 2 - mu / soi;\n\n        const obrEcc    = (apoapsis - periapsis) / (periapsis + apoapsis);\n        const obrSMA    = periapsis / (1 - obrEcc);\n        const obrEnergy = -mu  / (2 * obrSMA) ;\n\n        const obrPeriapsisSpeed = Math.sqrt((obrEnergy + mu / periapsis) * 2); \n        const hypPeriapsisSpeed = Math.sqrt((hypEnergy + mu / periapsis) * 2); \n\n\n        // align the perifocal fram with the inertial frame\n        const rotInc = alignVectorsAngleAxis(Z_DIR, nDir);\n        const perifocalSoiDir = vec3(Math.cos(hypDelta), Math.sin(hypDelta), 0);\n        const tiltSoiDir = roderigues(perifocalSoiDir, rotInc.axis, rotInc.angle)\n        const rotArg = alignVectorsAngleAxis(tiltSoiDir, normalize3(relativeVel));\n\n        // results\n        const periapsisPos = roderigues(roderigues(mult3(X_DIR,periapsis), rotInc.axis, rotInc.angle), rotArg.axis, rotArg.angle);\n        const periapsisVelDir = roderigues(roderigues(Y_DIR, rotInc.axis, rotInc.angle), rotArg.axis, rotArg.angle);\n        const hypPeriapsisVel = mult3(periapsisVelDir, hypPeriapsisSpeed);\n        const obrPeriapsisVel = mult3(periapsisVelDir, obrPeriapsisSpeed);\n        const hypDuration = Math.abs(Kepler.trueAnomalyToDate(hypNu, hypEcc, Kepler.siderealPeriod(hypSMA, mu), 0, 0));     \n        const obrDuration = Math.abs(Kepler.trueAnomalyToDate(obrNu, obrEcc, Kepler.siderealPeriod(obrSMA, mu), 0, 0));\n\n        const periapsisDate = soiDate - c * hypDuration;\n        const obrDate = periapsisDate - c * obrDuration;\n\n        const hypPreState:  OrbitalState = {date: periapsisDate, pos: periapsisPos, vel: obrPeriapsisVel};\n        const hypPostState: OrbitalState = {date: periapsisDate, pos: periapsisPos, vel: hypPeriapsisVel};\n\n        const obrEpoch = matchParkMo ? Kepler.trueAnomalyToOrbitDate(parkNu, parkOrbit, obrDate - parkOrbit.siderealPeriod/2) : obrDate;\n        const adjustedSoiDate = soiDate + obrEpoch - obrDate;\n        hypPreState.date  = hypPreState.date + obrEpoch - obrDate;\n        hypPostState.date = hypPreState.date;\n\n        // orbits\n        const obrOrbit = Kepler.stateToOrbit(hypPreState, parkBody);\n        obrOrbit.meanAnomalyEpoch = Kepler.dateToMeanAnomaly(obrEpoch, obrOrbit.siderealPeriod, obrOrbit.meanAnomalyEpoch, obrOrbit.epoch);\n        obrOrbit.epoch = obrEpoch;\n        const hypOrbit = Kepler.stateToOrbit(hypPostState, parkBody);\n\n        // oberth maneuver states\n        const parkVel   = Kepler.velocityAtTrueAnomaly(parkOrbit, parkBody.stdGravParam, parkNu);\n        const obrVel    = Kepler.velocityAtTrueAnomaly(obrOrbit, parkBody.stdGravParam, obrNu);\n        const obrPreState: OrbitalState = {\n            date: obrDate,\n            pos:  startPos,\n            vel:  parkVel,\n        };\n        const obrPostState: OrbitalState = {\n            date: obrDate,\n            pos:  startPos,\n            vel:  obrVel,\n        }\n\n        // trajectory\n        if(c === 1) {\n            const obrManeuver = Kepler.maneuverFromOrbitalStates(obrPreState, obrPostState);\n            const hypManeuver = Kepler.maneuverFromOrbitalStates(hypPreState, hypPostState);\n            return {\n                orbits:             [obrOrbit, hypOrbit],\n                intersectTimes:     [obrOrbit.epoch, hypOrbit.epoch, adjustedSoiDate],\n                maneuvers:          [obrManeuver, hypManeuver],\n            }\n        } else {\n            const obrManeuver = Kepler.maneuverFromOrbitalStates(obrPostState, obrPreState);\n            const hypManeuver = Kepler.maneuverFromOrbitalStates(hypPostState, hypPreState);\n            return {\n                orbits:             [hypOrbit, obrOrbit],\n                intersectTimes:     [adjustedSoiDate, hypOrbit.epoch, obrOrbit.epoch],\n                maneuvers:          [hypManeuver, obrManeuver],\n            }\n        }\n    }\n\n    // Optimal ejection/insertion orbits similar to KSPTOT\n    // An important difference is that vSoI, velocity at SOI encounter/exit, is used instead of vInf\n\n    export function optimalDeparture(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, \n                                     matchParkMo: boolean = true, type: \"direct\" | \"oberth\" = \"direct\", soiPatchPosition: Vector3 = vec3(0,0,0)): Trajectory {\n        return optimalDepartureArrival(parkOrbit, parkBody, relativeVel, soiDate, true, matchParkMo, type ,soiPatchPosition);\n    }\n\n    export function optimalArrival(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number,  \n                                   matchParkMo: boolean = true, type: \"direct\" | \"oberth\" = \"direct\", soiPatchPosition: Vector3 = vec3(0,0,0)): Trajectory {\n        return optimalDepartureArrival(parkOrbit, parkBody, relativeVel, soiDate, false, matchParkMo, type, soiPatchPosition);\n    }\n\n    export function optimalDepartureArrival(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, ejection: boolean,\n                                            matchParkMo: boolean = true, type: \"direct\" | \"oberth\" = \"direct\", soiPatchPosition: Vector3 = vec3(0, 0, 0)): Trajectory {\n        const c = ejection ? 1 : -1;\n        \n        // optimize the true anomaly of the parking orbit at the maneuver\n        // bounds for elliptical starting orbit\n        let minNu = -TWO_PI;\n        let maxNu = TWO_PI - Number.EPSILON;\n        if(type === \"direct\") {\n            const mu = parkBody.stdGravParam;\n            const soi = parkBody.soi;\n            const soiSpeedSq = magSq3(relativeVel);\n    \n            const a = 1 / (2 / soi - soiSpeedSq / mu);\n            const periapsis = parkOrbit.semiMajorAxis;\n            const relativeVelPlane = Kepler.rotateToPerifocalFromInertial(relativeVel, parkOrbit);\n\n            const {parkNu} = fastDepartureArrivalForPeriapsis(periapsis, parkOrbit, mu, soi, relativeVelPlane, soiSpeedSq, a, c);\n            minNu = parkNu - Math.PI;\n            maxNu = parkNu + Math.PI;\n        }else if(type === \"oberth\") {\n            const mu = parkBody.stdGravParam;\n            const soi = parkBody.soi;\n    \n            const periapsis = FlybyCalcs.minFlybyRadius(parkBody);\n    \n            const soiVelSq = magSq3(relativeVel);\n            const hypEnergy  = soiVelSq  / 2 - mu / soi;\n            const hypSMA = -mu / (2 * hypEnergy);  \n            const hypEcc    = 1 - periapsis / hypSMA;\n            const hypSLR    = hypSMA  * (1 - hypEcc  * hypEcc); \n            const hypNu     = Kepler.trueAnomalyAtDistance(soi, hypEcc,  hypSLR);       // true anomaly at SoI\n            const hypDelta  = Kepler.motionAngleAtTrueAnomaly(hypNu, hypEcc);           // angle of motion direction at SoI\n            const delta     = hypDelta + Math.PI;\n\n            const parkNu = wrapAngle(Kepler.angleInOrbitPlane(relativeVel, parkOrbit) - c * delta);\n            minNu = parkNu - Math.PI;\n            maxNu = parkNu + Math.PI;\n        }\n        // bounds for hyperbolic starting orbit\n        if(parkOrbit.eccentricity > 1) {\n            maxNu = ejectionTrueAnomaly(parkOrbit, parkBody) - 2 * Number.EPSILON;\n            minNu = -maxNu;\n        }\n\n        // console.log(minNu, maxNu)\n\n        const nuFun = type === \"direct\" ? directDepartArriveForTrueAnomaly : \n                      type === \"oberth\" ? oberthDepartArriveForTrueAnomaly :\n                      directDepartArriveForTrueAnomaly;\n\n        // objective export function for true anomaly optimization\n        function nuObjFun(nu: number) {\n            if(isNaN(nu) || nu === Infinity) {\n                console.log(nu)\n                throw Error(\"nu cannot be NaN\")\n            }\n            const {deltaV, err} = nuFun(nu, parkOrbit, parkBody, relativeVel, soiDate, c, matchParkMo, soiPatchPosition, false);\n            const obj = (deltaV * Math.exp(Math.min(100 * err, 10)))  // minimize delta v, and penalize direction mismatch from the intended excess velocity vector\n            return obj;\n        }\n\n        const nu = brentMinimize(nuObjFun, minNu, maxNu, 1e-4);\n        const res = nuFun(nu, parkOrbit, parkBody, relativeVel, soiDate, c, matchParkMo, soiPatchPosition, true);\n        \n        return res.trajectoryInfo\n    }\n\n    function directDepartArriveForTrueAnomaly(nu: number, parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, c: 1 | -1, \n                                              matchParkMo: boolean = true, soiPatchPosition: Vector3 = vec3(0,0,0), fullResult: boolean = true) {\n        const parkPos = add3(Kepler.positionAtTrueAnomaly(parkOrbit, nu), soiPatchPosition);\n        if(isNaN(parkPos.x)) {\n            throw Error(\"nu cannot be NaN\")\n        }\n        const {err, orbit} =  departArriveForPosition(parkPos, parkBody, relativeVel, soiDate, c, fullResult);\n\n        const epoch = matchParkMo ? Kepler.trueAnomalyToOrbitDate(nu, parkOrbit, orbit.epoch - parkOrbit.siderealPeriod/2) : orbit.epoch;\n        const adjustedSoiDate = soiDate + epoch - orbit.epoch;\n        orbit.epoch = epoch;\n\n        const preState = {\n            date: orbit.epoch,\n            pos:  Kepler.positionAtTrueAnomaly(parkOrbit, nu),\n            vel:  Kepler.velocityAtTrueAnomaly(parkOrbit, parkBody.stdGravParam, nu),\n        }\n        const postState = Kepler.orbitToStateAtDate(orbit, parkBody, orbit.epoch);\n\n        // console.log(mag3(sub3(preState.pos, postState.pos)))\n\n        let trajectoryInfo: Trajectory;\n        if(c === 1) {\n            const maneuver = Kepler.maneuverFromOrbitalStates(preState, postState);\n            trajectoryInfo = {\n                orbits:         [orbit],\n                intersectTimes: [orbit.epoch, adjustedSoiDate], \n                maneuvers:      [maneuver],\n            }\n        } else {\n            const maneuver = Kepler.maneuverFromOrbitalStates(postState, preState);\n            trajectoryInfo = {\n                orbits:         [orbit],\n                intersectTimes: [adjustedSoiDate, orbit.epoch],\n                maneuvers:      [maneuver],\n            }\n        }\n        const deltaV = trajectoryInfo.maneuvers[0].deltaVMag;\n\n        \n        return {deltaV, err, trajectoryInfo}\n    }\n\n    export function departArriveForPosition(parkPos: Vector3, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, c: 1 | -1, fullResult: boolean = true) {\n        // from a known position and a known velocity (at another position), we can calculate a, i, and lan\n        const mu = parkBody.stdGravParam;\n        const mr = mag3(parkPos);\n        const soi = parkBody.soi;\n\n        const hHat = normalize3(cross3(parkPos, relativeVel));\n        const n = cross3(Z_DIR, hHat);\n        const nMag = mag3(n);\n        const nHat = (nMag === 0) ? X_DIR : div3(n, nMag);\n\n        const a = 1 / (2 / soi - magSq3(relativeVel) / mu);\n        const i = acosClamped(hHat.z);\n        const lan = wrapAngle(copysign(1, nHat.y) * acosClamped(nHat.x));\n\n        // set bounds for eccentricity\n        // elliptical case\n        let eMax = 1 - 2 * Number.EPSILON;\n        let eMin = clamp(soi / a - 1 + Number.EPSILON, 0, eMax);\n        // hyperbolic case\n        if(a < 0) {\n            eMin = 1 + 2 * Number.EPSILON;\n            eMax = Math.max(1 - mr / a, mr / a - 1);\n            eMax = eMax === 1 ? 1 + 4 * Number.EPSILON : eMax;\n        }\n\n        // objective export function for eccentricity optimization\n        function eObjFun(e: number) {\n            if(isNaN(e)) {\n                return 2;\n            }\n            const {err} =  departArriveForEccentricity(e, a, lan, i, parkPos, mr, soi, mu, relativeVel, parkBody.id, c);\n            return err;\n        }\n\n        // Determine eccentricity (and argument of the periapsis, which depends on eccentricity) that ensure the correct excess velocity\n        const e = brentMinimize(eObjFun, eMin, eMax, 1e-6);\n        let {err, orbit} = departArriveForEccentricity(e, a, lan, i, parkPos, mr, soi, mu, relativeVel, parkBody.id, c);\n\n        if(fullResult) {\n            // Calculate the maneuver time, and consider it the orbit's epoch\n            const p = orbit.semiLatusRectum;\n            const mNu = c * Kepler.trueAnomalyAtDistance(mr, e, p);\n            const soiNu = c * Kepler.trueAnomalyAtDistance(soi, e, p);\n            const T = Kepler.siderealPeriod(a, mu);\n            const mM = Kepler.trueToMeanAnomaly(mNu, e);\n            const deltat = Kepler.trueAnomalyToDate(soiNu, e, T, mM, 0);\n            const mt = soiDate - deltat;\n\n            // Construct orbital objects and state vectors\n            orbit.meanAnomalyEpoch = mM;\n            orbit.epoch = mt;\n        }\n        return {err, orbit}\n    }\n\n    function departArriveForEccentricity(e: number, a: number, lan: number, i: number, parkPos: Vector3, mr: number, soi: number, mu: number, relativeVel: Vector3, orbiting: number, c: 1 | -1) {\n        const p = a * (1 - e * e);\n        const mNu = c * Kepler.trueAnomalyAtDistance(mr, e, p);\n        const soiNu = c * Kepler.trueAnomalyAtDistance(soi, e, p);\n\n        // determine arg that ensures that the optimized orbit intersects with the parking orbit at the provided point, parkPos \n        const arg = wrapAngle(Kepler.angleInPlane(parkPos, lan, i, 0.) - mNu);\n\n        const orbit: IOrbit = {\n            orbiting:           orbiting,\n            semiMajorAxis:      a,\n            eccentricity:       e,\n            inclination:        i,\n            ascNodeLongitude:   lan,\n            argOfPeriapsis:     arg,\n            meanAnomalyEpoch:   0.,     // does not affect the error or deltaV, and can be filled in later\n            epoch:              0.,     // does not affect the error or deltaV, and can be filled in later\n            semiLatusRectum:    p,\n            siderealPeriod:     Kepler.siderealPeriod(a, mu),\n        };\n\n        const soiVel = Kepler.velocityAtTrueAnomaly(orbit, mu, soiNu);\n\n        // calculate direction mismatch between the optimized orbit and the intended excess velocity\n        let err = 1 - dot3(normalize3(relativeVel), normalize3(soiVel))\n        if(isNaN(err)) {\n            err = 2;\n        }\n        console.log()\n        return {err, orbit}\n    }\n\n\n    // Oberth ejection/insertion (slingshot style)\n    export function oberthDepartArriveForTrueAnomaly(nu: number, parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, c: -1 | 1,\n                                                     matchParkMo: boolean = true, soiPatchPosition: Vector3 = vec3(0,0,0), fullResult: boolean = true) {\n        const parkPos = add3(Kepler.positionAtTrueAnomaly(parkOrbit, nu), soiPatchPosition);\n        const parkVel = Kepler.velocityAtTrueAnomaly(parkOrbit, parkBody.stdGravParam, nu);\n        \n        const {deltaV, obrPreState, obrPostState, hypPreState, hypPostState} = oberthDepartArriveForPosition(parkPos, parkVel, parkBody, relativeVel, soiDate, c, fullResult);\n\n        let trajectoryInfo: Trajectory = {orbits: [], intersectTimes: [], maneuvers: []};\n        if(fullResult) {\n            const obrEpoch = matchParkMo ? Kepler.trueAnomalyToOrbitDate(nu, parkOrbit, obrPreState.date - parkOrbit.siderealPeriod/2) : obrPreState.date;\n            const adjustedSoiDate = soiDate + obrEpoch - obrPreState.date;\n            hypPreState.date  = hypPreState.date + obrEpoch - obrPreState.date;\n            hypPostState.date = hypPreState.date;\n            obrPreState.date  = obrEpoch;\n            obrPostState.date = obrEpoch;\n\n            const obrOrbit = Kepler.stateToOrbit(hypPreState,  parkBody);\n            obrOrbit.meanAnomalyEpoch = Kepler.dateToMeanAnomaly(obrEpoch, obrOrbit.siderealPeriod, obrOrbit.meanAnomalyEpoch, obrOrbit.epoch);\n            obrOrbit.epoch = obrEpoch;\n            // const obrOrbit = Kepler.stateToOrbit(obrPostState, parkBody);\n            const hypOrbit = Kepler.stateToOrbit(hypPostState, parkBody);\n\n            if(c === 1) {\n                const obrManeuver = Kepler.maneuverFromOrbitalStates(obrPreState, obrPostState);\n                const hypManeuver = Kepler.maneuverFromOrbitalStates(hypPreState, hypPostState);\n                trajectoryInfo = {\n                    orbits:             [obrOrbit, hypOrbit],\n                    intersectTimes:     [obrOrbit.epoch, hypOrbit.epoch, adjustedSoiDate],\n                    maneuvers:          [obrManeuver, hypManeuver],\n                }\n            } else {\n                const obrManeuver = Kepler.maneuverFromOrbitalStates(obrPostState, obrPreState);\n                const hypManeuver = Kepler.maneuverFromOrbitalStates(hypPostState, hypPreState);\n                trajectoryInfo = {\n                    orbits:             [hypOrbit, obrOrbit],\n                    intersectTimes:     [adjustedSoiDate, hypOrbit.epoch, obrOrbit.epoch],\n                    maneuvers:          [hypManeuver, obrManeuver],\n                }\n            }\n        }\n\n        return {deltaV, err: 0, trajectoryInfo}\n    }\n\n\n    export function oberthDepartArriveForPosition(parkPos: Vector3, parkVel: Vector3, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, c: 1 | -1, fullResult: boolean = true) {\n        const mu = parkBody.stdGravParam;\n        const soi = parkBody.soi;\n\n        const mr = mag3(parkPos);\n        const parkPosDir = div3(parkPos, mr);\n\n        const soiVelSq = magSq3(relativeVel);\n        const soiDir = div3(relativeVel, Math.sqrt(soiVelSq));\n        const hypEnergy  = soiVelSq  / 2 - mu / soi;\n        const hypSMA = -mu / (2 * hypEnergy);  \n\n        let nDir = normalize3(cross3(parkPosDir, soiDir));                              // direction normal to the trajectory plane\n        if(nDir.z < 0) {\n            nDir = mult3(nDir, -1);\n        }\n        const delta = c === 1 ? counterClockwiseAngleInPlane(parkPosDir, soiDir, nDir) : // angle between incoming and outgoing velocity vectors (flyby angle)\n                                counterClockwiseAngleInPlane(soiDir, parkPosDir, nDir)  \n        \n        if(isNaN(delta)) {\n            console.log(parkPosDir, soiDir, nDir)\n        }\n\n        const denominator = (periapsis: number) => {\n            const hypEcc    = 1 - periapsis / hypSMA;\n            const hypSLR    = hypSMA  * (1 - hypEcc  * hypEcc); \n            const hypNu     = c * Kepler.trueAnomalyAtDistance(soi, hypEcc,  hypSLR);   // true anomaly at SoI\n            const hypDelta  = Kepler.motionAngleAtTrueAnomaly(hypNu, hypEcc);           // angle of motion direction at SoI\n            const obrNu     = wrapAngle(hypDelta - c * delta, -Math.PI * (c + 1));      // true anomaly at Oberth maneuver start\n            const denom    = (periapsis - mr * Math.cos(obrNu));\n            return denom;\n        }\n\n        // define the search space by eliminating periapses that result in negative eccentricity\n        let minPeriapsis = FlybyCalcs.minFlybyRadius(parkBody);\n        const minDenomPeriapsis = brentMinimize(denominator, minPeriapsis, mr);\n        const minDenom = denominator(minDenomPeriapsis)\n        if(minDenom < 0) {\n            minPeriapsis = brentRootFind(denominator, minDenomPeriapsis, mr) + 1;\n        }\n\n        // require that the incoming and outgoing orbits intersect at their periapses.\n        // find the periapsis height that gives the correct flyby angle at the lowest deltaV\n        const objective = (periapsis: number, fullResult: boolean = false) => {\n            const hypEcc    = 1 - periapsis / hypSMA;\n            const hypSLR    = hypSMA  * (1 - hypEcc  * hypEcc); \n            const hypNu     = c * Kepler.trueAnomalyAtDistance(soi, hypEcc,  hypSLR);   // true anomaly at SoI\n            const hypDelta  = Kepler.motionAngleAtTrueAnomaly(hypNu, hypEcc);           // angle of motion direction at SoI\n            const obrNu     = wrapAngle(hypDelta - c * delta, -Math.PI * (c + 1));      // true anomaly at Oberth maneuver start\n            const obrEcc    = (mr - periapsis) / (periapsis - mr * Math.cos(obrNu));\n            const obrSMA    = periapsis / (1 - obrEcc);\n            const obrEnergy = -mu  / (2 * obrSMA) ;\n\n            const obrPeriapsisSpeed = Math.sqrt((obrEnergy + mu / periapsis) * 2); \n            const hypPeriapsisSpeed = Math.sqrt((hypEnergy + mu / periapsis) * 2); \n\n\n            // align the perifocal fram with the inertial frame\n            const rotInc = alignVectorsAngleAxis(Z_DIR, nDir);\n            const perifocalSoiDir = vec3(Math.cos(hypDelta), Math.sin(hypDelta), 0);\n            const tiltSoiDir = roderigues(perifocalSoiDir, rotInc.axis, rotInc.angle)\n            const rotArg = alignVectorsAngleAxis(tiltSoiDir, soiDir);\n\n            // const diff = dot3(roderigues(perifocalParkDir, axis, angle), parkPosDir);\n            // if(diff < 0.95) {\n            //     console.log(axis, angle)\n            // }\n\n            // velocity of the Oberth maneuver at the intersect with the parking orbit\n            const obrSpeed = Math.sqrt((obrEnergy + mu / mr) * 2);\n            const perifocalObrDir = Kepler.motionDirectionAtTrueAnomaly(obrNu, obrEcc);\n            const obrDir = roderigues(roderigues(perifocalObrDir, rotInc.axis, rotInc.angle), rotArg.axis, rotInc.angle);\n            const obrVel = mult3(obrDir, obrSpeed);\n\n            // results\n            const deltaV = Math.abs(obrPeriapsisSpeed - hypPeriapsisSpeed) + mag3(sub3(obrVel, parkVel));\n            let periapsisPos:    Vector3 = vec3(0,0,0);     // store useless values during optimization\n            let hypPeriapsisVel: Vector3 = vec3(0,0,0);     \n            let obrPeriapsisVel: Vector3 = vec3(0,0,0);\n            let hypDuration: number = 0;\n            let obrDuration: number = 0;\n            if(fullResult) {    // only prepare the full info outisde of the optimization loop, since only deltaV is optimized\n                periapsisPos = roderigues(roderigues(mult3(vec3(1,0,0),periapsis), rotInc.axis, rotInc.angle), rotArg.axis, rotArg.angle);\n                const periapsisVelDir = roderigues(roderigues(vec3(0,1,0), rotInc.axis, rotInc.angle), rotArg.axis, rotArg.angle);\n                hypPeriapsisVel = mult3(periapsisVelDir, hypPeriapsisSpeed);\n                obrPeriapsisVel = mult3(periapsisVelDir, obrPeriapsisSpeed);\n                hypDuration = Math.abs(Kepler.trueAnomalyToDate(hypNu, hypEcc, Kepler.siderealPeriod(hypSMA, mu), 0, 0));     \n                obrDuration = Math.abs(Kepler.trueAnomalyToDate(obrNu, obrEcc, Kepler.siderealPeriod(obrSMA, mu), 0, 0));\n            }\n\n            if(isNaN(deltaV)) {\n                console.log(parkBody.name, mr, minPeriapsis, denominator(mr), denominator(minPeriapsis));\n                console.log(periapsis, (mr - periapsis), (periapsis - mr * Math.cos(obrNu)), delta, hypDelta);\n                // console.log(mu, mr, periapsis, obrNu, obrEcc, obrSMA, obrEnergy, obrPeriapsisSpeed, obrSpeed);\n            }\n\n            return {\n                deltaV,\n                obrVel,\n                periapsisPos,\n                hypPeriapsisVel,\n                obrPeriapsisVel,\n                hypDuration,\n                obrDuration,\n            };\n        }\n        const periapsis = brentMinimize((p: number) => objective(p).deltaV, minPeriapsis, mr, 1e-8)\n        const {deltaV, obrVel, periapsisPos, hypPeriapsisVel, obrPeriapsisVel, hypDuration, obrDuration} = objective(periapsis, fullResult);\n\n        const periapsisDate = soiDate - c * hypDuration;\n        const obrDate = periapsisDate - c * obrDuration;\n\n        const obrPreState:  OrbitalState = {date: obrDate,       pos: parkPos,      vel: parkVel};\n        const obrPostState: OrbitalState = {date: obrDate,       pos: parkPos,      vel: obrVel};\n        const hypPreState:  OrbitalState = {date: periapsisDate, pos: periapsisPos, vel: obrPeriapsisVel};\n        const hypPostState: OrbitalState = {date: periapsisDate, pos: periapsisPos, vel: hypPeriapsisVel};\n\n        return {deltaV, obrPreState, obrPostState, hypPreState, hypPostState};\n    }\n\n\n    // At the SoI boundary...\n\n    function patchTrueAnomaly(orb: IOrbit, attractor: IOrbitingBody, c: 1 | -1) {\n        return c * Kepler.trueAnomalyAtDistance(attractor.soi, orb.eccentricity, orb.semiLatusRectum)\n    }\n\n    export function ejectionTrueAnomaly(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchTrueAnomaly(orb, attractor, 1)\n    }\n\n    export function insertionTrueAnomaly(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchTrueAnomaly(orb, attractor, -1)\n    }\n\n\n    function patchDate(orb: IOrbit, attractor: IOrbitingBody, c: 1 | -1) {\n        let tMin: number | undefined = undefined;\n        // take care to get correct time for elliptical (periodic) orbits\n        if(orb.eccentricity < 1) {\n            tMin = c === 1 ? orb.epoch : orb.epoch - orb.siderealPeriod;\n        }\n        return Kepler.trueAnomalyToDate(patchTrueAnomaly(orb, attractor, c), orb.eccentricity, orb.siderealPeriod, orb.meanAnomalyEpoch, orb.epoch, tMin)\n    }\n\n    export function ejectionDate(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchDate(orb, attractor, 1)\n    }\n\n    export function insertionDate(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchDate(orb, attractor, -1)\n    }\n\n\n    function patchPosition(orb: IOrbit, attractor: IOrbitingBody, c: 1 | -1) {\n        return Kepler.positionAtTrueAnomaly(orb, patchTrueAnomaly(orb, attractor, c))\n    }\n\n    export function ejectionPosition(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchPosition(orb, attractor, 1)\n    }\n\n    export function insertionPosition(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchPosition(orb, attractor, -1)\n    }\n\n\n    function patchVelocity(orb: IOrbit, attractor: IOrbitingBody, c: 1 | -1) {\n        return Kepler.velocityAtTrueAnomaly(orb, attractor.stdGravParam, patchTrueAnomaly(orb, attractor, c))\n    }\n\n    export function ejectionVelocity(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchVelocity(orb, attractor, 1)\n    }\n\n    export function insertionVelocity(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchPosition(orb, attractor, -1)\n    }\n}\n\nexport default DepartArrive","import Kepler from \"./kepler\";\nimport DepartArrive from \"./departarrive\";\nimport { lerp, vec3, magSq3, div3, normalize3, cross3, dot3, acosClamped, roderigues, alignVectorsAngleAxis, wrapAngle } from \"./math\";\nimport { brentMinimize } from \"./optim\";\n\nnamespace FlybyCalcs {\n    export function minFlybyRadius(body: IOrbitingBody): number {\n        const margin = 1000; // leave a 1km buffer\n        if(body.atmosphereHeight !== 0) {\n            return body.radius + body.atmosphereHeight + margin;\n        } else {\n            const terrain = body.maxTerrainHeight ? body.maxTerrainHeight : 0.0;\n            return body.radius + terrain + margin;\n        }\n    }\n\n    export function maxFlybyRadius(body: IOrbitingBody) {\n        return body.soi;\n    }\n\n    export function legDurationBounds(orb1: IOrbit, orb2: IOrbit, attractor: ICelestialBody) {\n        const meanSMA = 0.5 * (orb1.semiMajorAxis + orb2.semiMajorAxis);\n        const midPeriod = Kepler.siderealPeriod(meanSMA, attractor.stdGravParam);\n        return {lb: midPeriod / 25, ub: midPeriod * 2}\n    }\n\n    export function flybyParameters({velIn, velOut, body, time}: FlybyInputs): FlybyParams {\n        const mu = body.stdGravParam;\n        const soi = body.soi;\n\n        const inVelSq = magSq3(velIn);\n        const outVelSq = magSq3(velOut);\n        const inDir = div3(velIn, Math.sqrt(inVelSq));\n        const outDir = div3(velOut, Math.sqrt(outVelSq));\n\n        const inEnergy  = inVelSq  / 2 - mu / soi; // account for gravitational potential energy as well as\n        const outEnergy = outVelSq / 2 - mu / soi; // kinetic energy.\n        const inSMA  = -mu / (2 * inEnergy);  \n        const outSMA = -mu / (2 * outEnergy);  \n\n        const hDir = normalize3(cross3(inDir, outDir));     // direction of angular moment vector, normal to the flyby plane\n        const delta = acosClamped(dot3(inDir, outDir));     // angle between incoming and outgoing velocity vectors (flyby angle)\n\n        // require that the incoming and outgoing orbits intersect at their periapses.\n        // find the periapsis height that gives the correct flyby angle\n        const objective = (periapsis: number) => {\n            const inEcc  = 1 - periapsis / inSMA;\n            const outEcc = 1 - periapsis / outSMA;\n            const inSLR  = inSMA  * (1 - inEcc  * inEcc); \n            const outSLR = outSMA * (1 - outEcc * outEcc);\n            const inNu   = -Kepler.trueAnomalyAtDistance(soi, inEcc,  inSLR);     // true anomaly at encounter\n            const outNu  =  Kepler.trueAnomalyAtDistance(soi, outEcc, outSLR);    // true anomaly at escape\n\n            const deltaIn  = Kepler.motionAngleAtTrueAnomaly(inNu,  inEcc);\n            const deltaOut = Kepler.motionAngleAtTrueAnomaly(outNu, outEcc);\n            const obj = Math.abs(delta - wrapAngle(deltaOut - deltaIn))\n            return isNaN(obj) ? Math.PI : obj;\n        }\n        const periapsis = brentMinimize(objective, minFlybyRadius(body), maxFlybyRadius(body), 1e-8)\n        const error = objective(periapsis);\n\n        const inEcc  = 1 - periapsis / inSMA;\n        const outEcc = 1 - periapsis / outSMA;\n        \n        const periapsisSpeedIn  = Math.sqrt((inEnergy  + mu / periapsis) * 2); \n        const periapsisSpeedOut = Math.sqrt((outEnergy + mu / periapsis) * 2);\n        const deltaV = Math.abs(periapsisSpeedOut - periapsisSpeedIn);    \n        // console.log(deltaV)\n\n        return {\n            inSemiMajorAxis:    inSMA,\n            inEccentricity:     inEcc,\n            inDirection:        inDir,\n            outSemiMajorAxis:   outSMA,\n            outEccentricity:    outEcc,\n            outDirection:       outDir,\n            normalDirection:    hDir,\n            deltaV,\n            error,\n            time,\n        }\n    }\n\n    export function flybyFromParameters(params: FlybyParams, body: IOrbitingBody): Trajectory {\n        const soi = body.soi;\n        const mu = body.stdGravParam;\n        \n        const inSMA  = params.inSemiMajorAxis;\n        const outSMA = params.outSemiMajorAxis;\n        const inEcc  = params.inEccentricity;\n        // const outEcc = params.outEccentricity;\n\n        const periapsis = inSMA * (1 - inEcc);\n\n        const inSLR  = inSMA  * (1 - inEcc  * inEcc); \n        const inNu = -Kepler.trueAnomalyAtDistance(soi, inEcc,  inSLR);\n        const inPerifocalDirection  = Kepler.motionDirectionAtTrueAnomaly(inNu,  inEcc);\n\n        const {axis, angle} = alignVectorsAngleAxis(inPerifocalDirection, params.inDirection);\n\n        const periapsisPos = roderigues(vec3(periapsis, 0, 0), axis, angle);\n\n        const inPeriapsisSpeed  = Math.sqrt(mu * (2 / periapsis - 1 / inSMA));\n        const outPeriapsisSpeed = Math.sqrt(mu * (2 / periapsis - 1 / outSMA));\n\n        const inPeriapsisVel  = roderigues(vec3(0, inPeriapsisSpeed,  0), axis, angle);\n        const outPeriapsisVel = roderigues(vec3(0, outPeriapsisSpeed, 0), axis, angle);\n\n        const inPeriapsisState  = {date: params.time, pos: periapsisPos, vel: inPeriapsisVel};\n        const outPeriapsisState = {date: params.time, pos: periapsisPos, vel: outPeriapsisVel};\n\n        const inOrbit  = Kepler.stateToOrbit(inPeriapsisState,  body);\n        const outOrbit = Kepler.stateToOrbit(outPeriapsisState, body);\n        const maneuver = Kepler.maneuverFromOrbitalStates(inPeriapsisState, outPeriapsisState);\n        \n        const inDate  = DepartArrive.insertionDate(inOrbit, body);\n        const outDate = DepartArrive.ejectionDate(outOrbit, body);\n\n        const trajectory: Trajectory = {\n            orbits:         [inOrbit, outOrbit],\n            intersectTimes: [inDate, params.time, outDate],\n            maneuvers:      [maneuver],\n        };\n\n        return trajectory;\n    }\n\n    export function multiFlybyInputsFromAgent(agent: Agent, inputs: MultiFlybySearchInputs): MultiFlybyInputs {\n        const startDate = lerp(inputs.startDateMin, inputs.startDateMax, agent[0]);\n        const flightTimes: number[] = [];\n        for(let j=0; j<agent.length-1; j++) {\n            let ft = lerp(inputs.flightTimesMax[j], inputs.flightTimesMin[j], agent[j+1]);\n            flightTimes.push(ft);\n        }\n        return  {\n            system:                 inputs.system,\n            startOrbit:             inputs.startOrbit,\n            endOrbit:               inputs.endOrbit,\n            flybyIdSequence:        inputs.flybyIdSequence,\n            startDate,\n            flightTimes,\n            ejectionInsertionType:  inputs.ejectionInsertionType,\n            planeChange:            inputs.planeChange,\n            matchStartMo:           inputs.matchStartMo,\n            matchEndMo:             inputs.matchEndMo,\n            noInsertionBurn:        inputs.noInsertionBurn,\n        };\n    }\n}\n\nexport default FlybyCalcs;","import { TWO_PI, HALF_PI, X_DIR, Z_DIR, copysign, acosClamped, wrapAngle, vec3, magSq3, mag3, sub3, div3, mult3, dot3, cross3, zxz, normalize3, add3 } from \"./math\"\nimport { newtonRootSolve } from \"./optim\"\n\nnamespace Kepler {\n    // export function orbitElementsFromOrbitData(orbit: IOrbit): OrbitalElements {  \n    //     const p = (orbit.semiLatusRectum) ? orbit.semiLatusRectum : orbit.semiMajorAxis * (1 - orbit.eccentricity * orbit.eccentricity)\n    //     return {\n    //         orbiting:           orbit.orbiting,\n    //         semiMajorAxis:      orbit.semiMajorAxis,\n    //         eccentricity:       orbit.eccentricity,\n    //         inclination:        orbit.inclination,\n    //         argOfPeriapsis:     orbit.argOfPeriapsis,\n    //         ascNodeLongitude:   orbit.ascNodeLongitude,\n    //         meanAnomalyEpoch:   orbit.meanAnomalyEpoch,\n    //         epoch:              orbit.epoch,\n    //         semiLatusRectum:    p,\n    //     };\n    // }\n\n    export function orbitFromElements(elements: OrbitalElements, attractor: ICelestialBody): IOrbit {\n        const p = (elements.semiLatusRectum) ? elements.semiLatusRectum : elements.semiMajorAxis * (1 - elements.eccentricity * elements.eccentricity)\n        const T = (elements.siderealPeriod) ? elements.siderealPeriod : siderealPeriod(elements.semiMajorAxis, attractor.stdGravParam)\n        return {\n            orbiting:           attractor.id,\n            semiMajorAxis:      elements.semiMajorAxis,\n            eccentricity:       elements.eccentricity,\n            inclination:        elements.inclination,\n            argOfPeriapsis:     elements.argOfPeriapsis,\n            ascNodeLongitude:   elements.ascNodeLongitude,\n            meanAnomalyEpoch:   elements.meanAnomalyEpoch,\n            epoch:              elements.epoch,\n            semiLatusRectum:    p,\n            siderealPeriod:     T,\n        }\n    }\n\n    export function maneuverFromOrbitalStates(preState: OrbitalState, postState: OrbitalState): Maneuver {\n        const deltaV = sub3(postState.vel, preState.vel);\n        const deltaVMag = mag3(deltaV)\n        return {\n            preState:   preState,\n            postState:  postState,\n            deltaV:     deltaV,\n            deltaVMag:  deltaVMag,\n        }\n    }\n\n    export function maneuverToComponents(maneuver: Maneuver) {\n        const progradeDir = normalize3(maneuver.preState.vel);\n        const normalDir   = normalize3(cross3(maneuver.preState.pos, progradeDir));\n        const radialDir   = cross3(progradeDir, normalDir);\n\n        return {\n            prograde: dot3(maneuver.deltaV, progradeDir),\n            normal:   dot3(maneuver.deltaV, normalDir),\n            radial:   dot3(maneuver.deltaV, radialDir),\n            date:     maneuver.preState.date,\n        }\n    }\n\n    export function maneuverComponentsToManeuver(components: ManeuverComponents, preState: OrbitalState): Maneuver {\n        const progradeDir = normalize3(preState.vel);\n        const normalDir   = normalize3(cross3(preState.pos, progradeDir));\n        const radialDir   = cross3(progradeDir, normalDir);\n\n        const deltaV = add3(mult3(progradeDir, components.prograde), add3(mult3(normalDir, components.normal), mult3(radialDir, components.radial)));\n\n        const postState: OrbitalState = {\n            date:   preState.date,\n            pos:    preState.pos,\n            vel:    add3(preState.vel, deltaV),\n        }\n\n        const maneuver: Maneuver = {\n            preState,\n            postState,\n            deltaV,\n            deltaVMag: mag3(deltaV),\n        }\n\n        return maneuver;\n    }\n\n    export function rotateToInertialFromPerifocal(x: Vector3, orbit: OrbitalElements): Vector3 {\n        const lan = orbit.ascNodeLongitude;\n        const i = orbit.inclination;\n        const arg = orbit.argOfPeriapsis;\n        return zxz(x, lan, i, arg)\n    }\n\n    export function rotateToPerifocalFromInertial(x: Vector3, orbit: OrbitalElements): Vector3 {\n        const lan = orbit.ascNodeLongitude;\n        const i = orbit.inclination;\n        const arg = orbit.argOfPeriapsis;\n        return zxz(x, -arg, -i, -lan)\n    }\n\n    export function siderealPeriod(a: number, mu: number) {\n        return TWO_PI * Math.sqrt(Math.abs(a*a*a) / mu)\n    }\n\n    export function flightPathAngleAtTrueAnomaly(nu: number, e: number) {\n        return Math.atan(e*Math.sin(nu) / (1 + e*Math.cos(nu)))\n    }\n\n    export function motionAngleAtTrueAnomaly(nu: number, e: number): number {\n        return nu + HALF_PI - flightPathAngleAtTrueAnomaly(nu, e);\n    }\n\n    export function motionDirectionAtTrueAnomaly(nu: number, e: number): Vector3 {\n        const angle = motionAngleAtTrueAnomaly(nu, e);\n        return vec3(Math.cos(angle), Math.sin(angle), 0);\n    }\n\n    export function distanceAtTrueAnomaly(nu: number, e: number, p: number) {\n        return p / (1 + e*Math.cos(nu))\n    }\n\n    export function distanceAtOrbitTrueAnomaly(nu: number, orbit: IOrbit) {\n        return distanceAtTrueAnomaly(nu, orbit.eccentricity, orbit.semiLatusRectum)\n    }\n\n    export function trueAnomalyAtDistance(r: number, e:number, p: number) {\n        return acosClamped((p/r - 1) / e)\n    }\n\n    export function dateToMeanAnomaly(date: number, T: number, M0: number, epoch: number) {\n        return M0 + TWO_PI * (date - epoch) / T;\n    }\n\n    export function meanAnomalyToDate(M: number, T: number, M0: number, epoch: number, tMin: number | undefined = undefined) {\n        let t = epoch + (M - M0) * T / TWO_PI;\n        if(tMin) {\n            const nPeriods = Math.ceil((tMin - t)/T);\n            t += T * nPeriods;\n        }\n        return t        \n    }\n\n    export function trueToMeanAnomaly(nu: number, e: number) {\n        // The parabolic case (e = 1) is note implemented\n        if(e < 1) {\n            const E = 2 * Math.atan2(Math.sin(nu/2)*Math.sqrt(1-e), Math.cos(nu/2)*Math.sqrt(1+e));\n            return E - e * Math.sin(E);\n        } else {\n            const H = 2 * Math.atanh(Math.tan(nu/2)*Math.sqrt((e-1)/(e+1)));\n            return e * Math.sinh(H) - H;\n        }\n    }\n\n    export function meanToTrueAnomaly(M: number, e: number){\n        // Solving Kepler's equation for eccentric anomaly with Newton's method.\n        if(e < 1) {\n            const E = newtonRootSolve(\n                E => E - e * Math.sin(E) - M,\n                E => 1 - e * Math.cos(E),\n                M,\n                1e-12\n            );\n            return 2 * Math.atan(Math.sqrt((1 + e)/(1 - e)) * Math.tan(E * 0.5));\n        } else {\n            const H0 = Math.abs(M) > 4*Math.PI ? Math.sign(M) * 4*Math.PI : M;\n            const H = newtonRootSolve(\n                H => e * Math.sinh(H) - H - M,\n                H => e * Math.cosh(H) - 1,\n                H0,\n                1e-12\n            );\n            return 2 * Math.atan(Math.sqrt((e + 1)/(e - 1)) * Math.tanh(H * 0.5));\n        }\n    }\n\n    export function dateToTrueAnomaly(date: number, e: number, T: number, M0: number, epoch: number) {\n        const M = dateToMeanAnomaly(date, T, M0, epoch);\n        return meanToTrueAnomaly(M, e)\n    }\n\n    export function trueAnomalyToDate(nu: number, e: number, T: number, M0: number, epoch: number, tMin: number = 0) {\n        const M = trueToMeanAnomaly(nu, e)\n        return meanAnomalyToDate(M, T, M0, epoch, tMin)\n    }\n\n    export function dateToOrbitTrueAnomaly(date: number, orbit: IOrbit) {\n        return dateToTrueAnomaly(date, orbit.eccentricity, orbit.siderealPeriod, orbit.meanAnomalyEpoch, orbit.epoch)\n    }\n\n    export function trueAnomalyToOrbitDate(nu: number, orbit: IOrbit, tMin: number = orbit.epoch) {\n        return trueAnomalyToDate(nu, orbit.eccentricity, orbit.siderealPeriod, orbit.meanAnomalyEpoch, orbit.epoch, tMin)\n    }\n\n    export function angleInPlane(pos: Vector3, lan: number, i: number, arg: number) {\n        const perifocalPos = zxz(pos, -arg, -i, -lan);\n        return Math.atan2(perifocalPos.y, perifocalPos.x);\n    }\n\n    export function angleInOrbitPlane(pos: Vector3, orbit: OrbitalElements) {\n        return angleInPlane(pos, orbit.ascNodeLongitude, orbit.inclination, orbit.argOfPeriapsis)\n    }\n\n    export function positionAtTrueAnomaly(orbit: IOrbit, nu: number): Vector3 {\n        const e = orbit.eccentricity;\n        const i = orbit.inclination;\n        const lan = orbit.ascNodeLongitude;\n        const arg = orbit.argOfPeriapsis;\n        const p = orbit.semiLatusRectum;\n\n        const r = distanceAtTrueAnomaly(nu, e, p);\n        const perifocalPos = vec3(r*Math.cos(nu), r*Math.sin(nu), 0);\n        const pos = zxz(perifocalPos, lan, i, arg);\n        return pos\n    }\n\n    export function velocityAtTrueAnomaly(orbit: IOrbit, mu: number, nu: number): Vector3 {\n        const a = orbit.semiMajorAxis;\n        const e = orbit.eccentricity;\n        const i = orbit.inclination;\n        const lan = orbit.ascNodeLongitude;\n        const arg = orbit.argOfPeriapsis;\n        const p = orbit.semiLatusRectum;\n\n        const r = distanceAtTrueAnomaly(nu, e, p);\n        const v = Math.sqrt(mu * (2/r - 1/a));\n\n        const perifocalVel = mult3(motionDirectionAtTrueAnomaly(nu, e), v);\n        const vel = zxz(perifocalVel, lan, i, arg);\n        return vel\n    }\n\n    export function orbitToPositionAtDate(orbit: IOrbit, date: number): Vector3 {\n        const e = orbit.eccentricity;\n        const M0 = orbit.meanAnomalyEpoch;\n        const epoch = orbit.epoch;\n        const T = orbit.siderealPeriod;\n\n        const nu = dateToTrueAnomaly(date, e, T, M0, epoch);\n        return positionAtTrueAnomaly(orbit, nu)\n    }\n\n    export function orbitToVelocityAtDate(orbit: IOrbit, attractor: ICelestialBody, date: number): Vector3 {\n        const e = orbit.eccentricity;\n        const M0 = orbit.meanAnomalyEpoch;\n        const epoch = orbit.epoch;\n        const T = orbit.siderealPeriod;\n\n        const mu = attractor.stdGravParam;\n\n        const nu = dateToTrueAnomaly(date, e, T, M0, epoch);\n        return velocityAtTrueAnomaly(orbit, mu, nu)\n    }\n\n    export function orbitToStateAtDate(orbit: IOrbit, attractor: ICelestialBody, date: number): OrbitalState {\n        const e = orbit.eccentricity;\n        const M0 = orbit.meanAnomalyEpoch;\n        const epoch = orbit.epoch;\n        const T = orbit.siderealPeriod;\n        \n        const mu = attractor.stdGravParam;\n\n        const nu = dateToTrueAnomaly(date, e, T, M0, epoch);\n        const pos = positionAtTrueAnomaly(orbit, nu);\n        const vel = velocityAtTrueAnomaly(orbit, mu, nu);\n\n        return {date, pos, vel}\n    }\n\n    export function stateToOrbit(state: OrbitalState, attractor: ICelestialBody) : IOrbit {\n        const nullEps = 1e-12;\n        \n        const mu = attractor.stdGravParam;\n        \n        const pos = state.pos;\n        const vel = state.vel;\n        const r = mag3(pos);\n        const v2 = magSq3(vel);\n\n        const t = state.date\n\n        // Semi-major Axis\n        const a = 1 / (2/r - v2/mu);\n\n        // Momentum\n        const h = cross3(pos, vel);\n        \n        // Inclination\n        const i = acosClamped(h.z / mag3(h));\n\n        // Eccentricity vector (points toward periapsis)\n        const eVec = sub3(div3(cross3(vel, h), mu), div3(pos, r));\n        let e = mag3(eVec);\n        let eHat = div3(eVec, e);\n        if(e <=nullEps) {\n            eHat = X_DIR;\n            e = 0;\n        }\n\n        // Vector pointing to the ascending node\n        const nVec = cross3(Z_DIR, h);\n        let n = mag3(nVec);\n        let nHat = div3(nVec, n);\n        if(n <= nullEps) {\n            nHat = eHat;\n            n = 0;\n        }\n\n        // Longitude of the ascending node\n        const lan = wrapAngle(copysign(acosClamped(nHat.x), nHat.y), 0)\n        \n        // Argument of the periapsis\n        const arg = wrapAngle(copysign(acosClamped(dot3(nHat, eHat)), eHat.z), 0)\n\n        // True anomaly\n        const nu = wrapAngle(angleInPlane(pos, lan, i, arg), 0);\n\n        // Mean anomaly\n        const M = trueToMeanAnomaly(nu, e);\n\n        // Semi-latus rectum\n        const p = a * (1 - e*e);\n\n        // Orbital period\n        const T = siderealPeriod(a, mu)\n\n        return {\n            orbiting:               attractor.id,\n            semiMajorAxis:          a,\n            eccentricity:           e,\n            inclination:            i,\n            ascNodeLongitude:       lan,\n            argOfPeriapsis:         arg,\n            meanAnomalyEpoch:       M,\n            epoch:                  t,\n            semiLatusRectum:        p,\n            siderealPeriod:         T,\n        }\n    }\n}\n\nexport default Kepler","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}"],"names":["fastDepartureArrival","parkOrbit","parkBody","relativeVel","soiDate","ejection","matchParkMo","c","mu","stdGravParam","soi","soiSpeedSq","magSq3","a","etol","relativeVelPlane","Kepler","periapsis","semiMajorAxis","eccentricity","periapsisErr","fastDepartureArrivalForPeriapsis","err","min","max","brentRootFind","parkNu","e","soiNu","pPos","pVel","deltaT","periapsisDate","siderealPeriod","periapsisState","date","pos","vel","parkState","orbit","maneuver","orbits","intersectTimes","epoch","maneuvers","pSpeedSq","pSpeed","Math","sqrt","p","soiVel","mult3","X_DIR","Y_DIR","rotAngle1","atan2","z","abs","y","roderigues","rotAngle2","x","Z_DIR","fastOberthDepartureArrival","soiPatchPosition","vec3","FlybyCalcs","hypSMA","hypEcc","hypSLR","hypNu","obrNu","PI","hypDelta","delta","wrapAngle","parkNuObj","parkPos","startPos","add3","nDir","normalize3","cross3","deltaForNu","counterClockwiseAngleInPlane","brentMinimize","insertionTrueAnomaly","ejectionTrueAnomaly","apoapsis","mag3","soiVelSq","hypEnergy","obrEcc","obrSMA","obrEnergy","obrPeriapsisSpeed","hypPeriapsisSpeed","rotInc","alignVectorsAngleAxis","perifocalSoiDir","cos","sin","tiltSoiDir","axis","angle","rotArg","periapsisPos","periapsisVelDir","hypPeriapsisVel","obrPeriapsisVel","hypDuration","obrDuration","obrDate","hypPreState","hypPostState","obrEpoch","adjustedSoiDate","obrOrbit","meanAnomalyEpoch","hypOrbit","parkVel","obrVel","obrPreState","obrPostState","obrManeuver","hypManeuver","optimalDepartureArrival","type","minNu","TWO_PI","maxNu","Number","EPSILON","nuFun","directDepartArriveForTrueAnomaly","oberthDepartArriveForTrueAnomaly","nuObjFun","nu","isNaN","Infinity","console","log","Error","deltaV","exp","res","trajectoryInfo","fullResult","departArriveForPosition","preState","postState","deltaVMag","mr","hHat","n","nMag","nHat","div3","i","acosClamped","lan","copysign","eMax","eMin","clamp","eObjFun","departArriveForEccentricity","id","semiLatusRectum","mNu","T","mM","deltat","mt","orbiting","inclination","ascNodeLongitude","argOfPeriapsis","dot3","oberthDepartArriveForPosition","parkPosDir","soiDir","denominator","minPeriapsis","minDenomPeriapsis","minDenom","objective","obrSpeed","perifocalObrDir","obrDir","sub3","name","patchTrueAnomaly","orb","attractor","patchDate","tMin","undefined","patchPosition","patchVelocity","DepartArrive","minFlybyRadius","body","atmosphereHeight","radius","terrain","maxTerrainHeight","maxFlybyRadius","orb1","orb2","meanSMA","midPeriod","lb","ub","velIn","velOut","time","inVelSq","outVelSq","inDir","outDir","inEnergy","outEnergy","inSMA","outSMA","hDir","inEcc","outEcc","inSLR","outSLR","inNu","outNu","deltaIn","deltaOut","obj","error","periapsisSpeedIn","periapsisSpeedOut","inSemiMajorAxis","inEccentricity","inDirection","outSemiMajorAxis","outEccentricity","outDirection","normalDirection","params","inPerifocalDirection","inPeriapsisSpeed","outPeriapsisSpeed","inPeriapsisVel","outPeriapsisVel","inPeriapsisState","outPeriapsisState","inOrbit","outOrbit","inDate","outDate","agent","inputs","startDate","lerp","startDateMin","startDateMax","flightTimes","j","length","ft","flightTimesMax","flightTimesMin","push","system","startOrbit","endOrbit","flybyIdSequence","ejectionInsertionType","planeChange","matchStartMo","matchEndMo","noInsertionBurn","flightPathAngleAtTrueAnomaly","atan","motionAngleAtTrueAnomaly","HALF_PI","motionDirectionAtTrueAnomaly","distanceAtTrueAnomaly","dateToMeanAnomaly","M0","meanAnomalyToDate","M","t","nPeriods","ceil","trueToMeanAnomaly","E","H","atanh","tan","sinh","meanToTrueAnomaly","newtonRootSolve","H0","sign","cosh","tanh","dateToTrueAnomaly","trueAnomalyToDate","angleInPlane","arg","perifocalPos","zxz","positionAtTrueAnomaly","r","velocityAtTrueAnomaly","v","perifocalVel","elements","progradeDir","normalDir","radialDir","prograde","normal","radial","components","state","v2","h","eVec","eHat","nVec","_arrayLikeToArray","arr","len","arr2","Array","_toConsumableArray","isArray","arrayLikeToArray","iter","Symbol","iterator","from","unsupportedIterableToArray","TypeError","_unsupportedIterableToArray","o","minLen","Object","prototype","toString","call","slice","constructor","test"],"sourceRoot":""}