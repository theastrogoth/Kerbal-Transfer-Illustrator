{"version":3,"file":"static/js/774.b0806af3.chunk.js","mappings":"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","sources":["main/libs/departarrive.ts","main/libs/flybycalcs.ts","main/libs/kepler.ts","main/libs/lambert.ts","main/libs/optim.ts","main/libs/trajectories.ts","main/objects/body.ts","main/objects/color.ts","main/objects/orbit.ts","main/objects/system.ts","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/createClass.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/createSuper.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/get.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/inherits.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/superPropBase.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/typeof.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"],"sourcesContent":["import FlybyCalcs from \"./flybycalcs\";\nimport Kepler from \"./kepler\";\nimport { TWO_PI, X_DIR, Y_DIR, Z_DIR, copysign, acosClamped, wrapAngle, vec3, magSq3, mag3, normalize3, add3, sub3, div3, mult3, dot3, cross3, roderigues, counterClockwiseAngleInPlane, alignVectorsAngleAxis, clamp } from \"./math\"\nimport { brentRootFind, brentMinimize } from \"./optim\"\n\n// const blankOrbit: IOrbit = {\n//     orbiting:   -1,\n//     semiMajorAxis: 0,\n//     eccentricity: 0,\n//     inclination: 0,\n//     argOfPeriapsis: 0,\n//     ascNodeLongitude: 0,\n//     meanAnomalyEpoch: 0,\n//     epoch: 0,\n//     siderealPeriod: 0,\n//     semiLatusRectum: 0,\n// }\n\nnamespace DepartArrive {\n    // \"Direct\" ejection/insertion\n    export function simpleDeparture(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, matchParkMo: boolean = true): Trajectory {\n        return simpleDepartureArrival(parkOrbit, parkBody, relativeVel, soiDate, true, matchParkMo)\n    }\n\n    export function simpleArrival(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, matchParkMo: boolean = true): Trajectory {\n        return simpleDepartureArrival(parkOrbit, parkBody, relativeVel, soiDate, false, matchParkMo)\n    }\n\n    export function simpleDepartureArrival(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, ejection: boolean, matchParkMo: boolean = true): Trajectory {     \n        const c = ejection ? 1 : -1;\n        const mu = parkBody.stdGravParam;\n        const soi = parkBody.soi;\n        const soiSpeedSq = magSq3(relativeVel);\n\n        const a = 1 / (2 / soi - soiSpeedSq / mu);\n        const etol = 1e-8;\n\n        // Rotate the relative velocity to the perifocal frame of the parking orbit\n        const relativeVelPlane = Kepler.rotateToPerifocalFromInertial(relativeVel, parkOrbit);\n\n        // If the orbit is circular, there is no need to search for a periapsis height\n        let periapsis = parkOrbit.semiMajorAxis;\n\n        // use Brent's method to find when the difference between the departure/arrival hyperbola and parking orbit radius is 0\n        if(parkOrbit.eccentricity > etol) {\n            const periapsisErr = (periapsis: number) => {\n                const res = simpleDepartureArrivalPeriapsisResult(periapsis, parkOrbit, mu, soi, relativeVelPlane, soiSpeedSq, a, c);\n                return res.err\n            }\n            const min = parkOrbit.semiMajorAxis * (1 - parkOrbit.eccentricity);\n            const max = parkOrbit.eccentricity > 1 ? soi : parkOrbit.semiMajorAxis * (1 + parkOrbit.eccentricity);\n            periapsis = brentRootFind(periapsisErr, min, max);\n        }\n        const res = simpleDepartureArrivalPeriapsisResult(periapsis, parkOrbit, mu, soi, relativeVelPlane, soiSpeedSq, a, c);\n        const parkNu = res.parkNu;\n        const e = res.e;\n        const soiNu = res.soiNu;\n        const pPos = res.pPos;\n        const pVel = res.pVel;\n\n        const deltaT = Kepler.trueAnomalyToDate(soiNu, e, Kepler.siderealPeriod(a, mu), 0, 0);\n\n        const periapsisDate = matchParkMo ? Kepler.trueAnomalyToOrbitDate(parkNu, parkOrbit, soiDate - deltaT - parkOrbit.siderealPeriod / 2) \n                                          : soiDate - deltaT;\n        const periapsisState = {\n            date:   periapsisDate,\n            pos:    pPos,\n            vel:    pVel,\n        };\n        \n        const parkState = {\n            date:   periapsisDate,\n            pos:    pPos,\n            vel:    Kepler.velocityAtTrueAnomaly(parkOrbit, mu, parkNu),\n        };\n        const orbit = Kepler.stateToOrbit(periapsisState, parkBody);\n\n        if(c === 1) {\n            const maneuver = Kepler.maneuverFromOrbitalStates(parkState, periapsisState);\n            return {\n                orbits:             [orbit], \n                intersectTimes:     [orbit.epoch, orbit.epoch + deltaT],\n                maneuvers:          [maneuver],\n            }\n        } else {\n            const maneuver = Kepler.maneuverFromOrbitalStates(periapsisState, parkState);\n            return {\n                orbits:             [orbit], \n                intersectTimes:     [orbit.epoch + deltaT, orbit.epoch],\n                maneuvers:          [maneuver],\n            }\n        }\n    }\n\n    function simpleDepartureArrivalPeriapsisResult(periapsis: number, parkOrbit: IOrbit, mu: number, soi: number, relativeVelPlane: Vector3, soiSpeedSq: number, a: number, c: 1 | -1) {\n\n        const pSpeedSq = soiSpeedSq + 2 * mu * (1 / periapsis - 1 / soi);\n        const pSpeed = Math.sqrt(pSpeedSq);\n\n        const e = Math.sqrt(1 + 2 * (0.5 * pSpeedSq - mu / periapsis) * periapsis * periapsis * pSpeedSq / mu  / mu);\n        const p = a * (1 - e*e);\n\n        // Start in perifocal coordinates of the ejection/insertion orbit\n        // The assumption is made that the periapsis of the ejection/insertion orbit intersects with the parking orbit (which is not necessarily optimal, but is good for near-circular cases)\n        const soiNu = c * Kepler.trueAnomalyAtDistance(soi, e, p);\n        let soiVel = mult3(Kepler.motionDirectionAtTrueAnomaly(soiNu, e), Math.sqrt(soiSpeedSq));\n        let pPos = mult3(X_DIR, periapsis);\n        let pVel = mult3(Y_DIR, pSpeed);\n\n        // Rotate about the x-axis to match the inclination of the relative velocity (in the plane of the parking orbit)\n        const rotAngle1 = Math.atan2(relativeVelPlane.z, Math.sqrt(Math.abs(soiVel.y*soiVel.y - relativeVelPlane.z*relativeVelPlane.z)));\n        soiVel = roderigues(soiVel, X_DIR, rotAngle1);\n        pPos = roderigues(pPos, X_DIR, rotAngle1);\n        pVel = roderigues(pVel, X_DIR, rotAngle1);\n\n        // Rotate about the z-axs to match the direction of the relative velocity (in the plane of the parking orbit)\n        const rotAngle2 = Math.atan2(relativeVelPlane.y, relativeVelPlane.x) - Math.atan2(soiVel.y, soiVel.x);\n        soiVel = roderigues(soiVel, Z_DIR, rotAngle2);\n        pPos = roderigues(pPos, Z_DIR, rotAngle2);\n        pVel = roderigues(pVel, Z_DIR, rotAngle2);\n\n        // Rotate back into the reference plane\n        soiVel = Kepler.rotateToInertialFromPerifocal(soiVel, parkOrbit);\n        pPos = Kepler.rotateToInertialFromPerifocal(pPos, parkOrbit);\n        pVel = Kepler.rotateToInertialFromPerifocal(pVel, parkOrbit);\n\n        // check error in periapsis height against parking orbit\n        const parkNu = Kepler.angleInOrbitPlane(pPos, parkOrbit);\n        const parkRadius = Kepler.distanceAtOrbitTrueAnomaly(parkNu, parkOrbit);\n        const err = periapsis - parkRadius;\n        return {err,  parkNu, e, soiNu, pPos, pVel}\n    }\n\n    // Optimal ejection/insertion orbits similar to KSPTOT\n    // An important difference is that velocity at SOI encounter/exit is used instead of vInf\n\n    export function optimalDeparture(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, \n                                     matchParkMo: boolean = true, type: \"direct\" | \"oberth\" = \"direct\", soiPatchPosition: Vector3 = vec3(0,0,0)): Trajectory {\n        return optimalDepartureArrival(parkOrbit, parkBody, relativeVel, soiDate, true, matchParkMo, type ,soiPatchPosition);\n    }\n\n    export function optimalArrival(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number,  \n                                   matchParkMo: boolean = true, type: \"direct\" | \"oberth\" = \"direct\", soiPatchPosition: Vector3 = vec3(0,0,0)): Trajectory {\n        return optimalDepartureArrival(parkOrbit, parkBody, relativeVel, soiDate, false, matchParkMo, type, soiPatchPosition);\n    }\n\n    export function optimalDepartureArrival(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, ejection: boolean,\n                                            matchParkMo: boolean = true, type: \"direct\" | \"oberth\" = \"direct\", soiPatchPosition: Vector3 = vec3(0, 0, 0)): Trajectory {\n        const c = ejection ? 1 : -1;\n        \n        // optimize the true anomaly of the parking orbit at the maneuver\n        // bounds for elliptical starting orbit\n        let minNu = -TWO_PI;\n        let maxNu = TWO_PI - Number.EPSILON;\n        // bounds for hyperbolic starting orbit\n        if(parkOrbit.eccentricity > 1) {\n            maxNu = ejectionTrueAnomaly(parkOrbit, parkBody) - 2 * Number.EPSILON;\n            minNu = -maxNu;\n        }\n\n        // console.log(minNu, maxNu)\n\n        const nuFun = type === \"direct\" ? directDepartArriveForTrueAnomaly : \n                      type === \"oberth\" ? oberthDepartArriveForTrueAnomaly :\n                      directDepartArriveForTrueAnomaly;\n\n        // objective export function for true anomaly optimization\n        function nuObjFun(nu: number) {\n            if(isNaN(nu) || nu === Infinity) {\n                console.log(nu)\n                throw Error(\"nu cannot be NaN\")\n            }\n            const {deltaV, err} = nuFun(nu, parkOrbit, parkBody, relativeVel, soiDate, c, matchParkMo, soiPatchPosition, false);\n            const obj = (deltaV * Math.exp(Math.min(100 * err, 10)))  // minimize delta v, and penalize direction mismatch from the intended excess velocity vector\n            return obj;\n        }\n\n        const nu = brentMinimize(nuObjFun, minNu, maxNu, 1e-4);\n        const res = nuFun(nu, parkOrbit, parkBody, relativeVel, soiDate, c, matchParkMo, soiPatchPosition, true);\n        \n        return res.trajectoryInfo\n    }\n\n    function directDepartArriveForTrueAnomaly(nu: number, parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, c: 1 | -1, \n                                              matchParkMo: boolean = true, soiPatchPosition: Vector3 = vec3(0,0,0), fullResult: boolean = true) {\n        const parkPos = add3(Kepler.positionAtTrueAnomaly(parkOrbit, nu), soiPatchPosition);\n        if(isNaN(parkPos.x)) {\n            throw Error(\"nu cannot be NaN\")\n        }\n        const {err, orbit} =  departArriveForPosition(parkPos, parkBody, relativeVel, soiDate, c, fullResult);\n\n        const epoch = matchParkMo ? Kepler.trueAnomalyToOrbitDate(nu, parkOrbit, orbit.epoch - parkOrbit.siderealPeriod/2) : orbit.epoch;\n        const adjustedSoiDate = soiDate + epoch - orbit.epoch;\n        orbit.epoch = epoch;\n\n        const preState = {\n            date: orbit.epoch,\n            pos:  Kepler.positionAtTrueAnomaly(parkOrbit, nu),\n            vel:  Kepler.velocityAtTrueAnomaly(parkOrbit, parkBody.stdGravParam, nu),\n        }\n        const postState = Kepler.orbitToStateAtDate(orbit, parkBody, orbit.epoch);\n\n        // console.log(mag3(sub3(preState.pos, postState.pos)))\n\n        let trajectoryInfo: Trajectory;\n        if(c === 1) {\n            const maneuver = Kepler.maneuverFromOrbitalStates(preState, postState);\n            trajectoryInfo = {\n                orbits:         [orbit],\n                intersectTimes: [orbit.epoch, adjustedSoiDate], \n                maneuvers:      [maneuver],\n            }\n        } else {\n            const maneuver = Kepler.maneuverFromOrbitalStates(postState, preState);\n            trajectoryInfo = {\n                orbits:         [orbit],\n                intersectTimes: [adjustedSoiDate, orbit.epoch],\n                maneuvers:      [maneuver],\n            }\n        }\n        const deltaV = trajectoryInfo.maneuvers[0].deltaVMag;\n\n        \n        return {deltaV, err, trajectoryInfo}\n    }\n\n    export function departArriveForPosition(parkPos: Vector3, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, c: 1 | -1, fullResult: boolean = true) {\n        // from a known position and a known velocity (at another position), we can calculate a, i, and lan\n        const mu = parkBody.stdGravParam;\n        const mr = mag3(parkPos);\n        const soi = parkBody.soi;\n\n        const hHat = normalize3(cross3(parkPos, relativeVel));\n        const n = cross3(Z_DIR, hHat);\n        const nMag = mag3(n);\n        const nHat = (nMag === 0) ? X_DIR : div3(n, nMag);\n\n        const a = 1 / (2 / soi - magSq3(relativeVel) / mu);\n        const i = acosClamped(hHat.z);\n        const lan = wrapAngle(copysign(1, nHat.y) * acosClamped(nHat.x));\n\n        // set bounds for eccentricity\n        // elliptical case\n        let eMax = 1 - 2 * Number.EPSILON;\n        let eMin = clamp(soi / a - 1 + Number.EPSILON, 0, eMax);\n        // hyperbolic case\n        if(a < 0) {\n            eMin = 1 + 2 * Number.EPSILON;\n            eMax = Math.max(1 - mr / a, mr / a - 1);\n            eMax = eMax === 1 ? 1 + 4 * Number.EPSILON : eMax;\n        }\n\n        // objective export function for eccentricity optimization\n        function eObjFun(e: number) {\n            if(isNaN(e)) {\n                return 2;\n            }\n            const {err} =  departArriveForEccentricity(e, a, lan, i, parkPos, mr, soi, mu, relativeVel, parkBody.id, c);\n            return err;\n        }\n\n        // Determine eccentricity (and argument of the periapsis, which depends on eccentricity) that ensure the correct excess velocity\n        const e = brentMinimize(eObjFun, eMin, eMax, 1e-6);\n        let {err, orbit} = departArriveForEccentricity(e, a, lan, i, parkPos, mr, soi, mu, relativeVel, parkBody.id, c);\n\n        if(fullResult) {\n            // Calculate the maneuver time, and consider it the orbit's epoch\n            const p = orbit.semiLatusRectum;\n            const mNu = c * Kepler.trueAnomalyAtDistance(mr, e, p);\n            const soiNu = c * Kepler.trueAnomalyAtDistance(soi, e, p);\n            const T = Kepler.siderealPeriod(a, mu);\n            const mM = Kepler.trueToMeanAnomaly(mNu, e);\n            const deltat = Kepler.trueAnomalyToDate(soiNu, e, T, mM, 0);\n            const mt = soiDate - deltat;\n\n            // Construct orbital objects and state vectors\n            orbit.meanAnomalyEpoch = mM;\n            orbit.epoch = mt;\n        }\n        return {err, orbit}\n    }\n\n    function departArriveForEccentricity(e: number, a: number, lan: number, i: number, parkPos: Vector3, mr: number, soi: number, mu: number, relativeVel: Vector3, orbiting: number, c: 1 | -1) {\n        const p = a * (1 - e * e);\n        const mNu = c * Kepler.trueAnomalyAtDistance(mr, e, p);\n        const soiNu = c * Kepler.trueAnomalyAtDistance(soi, e, p);\n\n        // determine arg that ensures that the optimized orbit intersects with the parking orbit at the provided point, parkPos \n        const arg = wrapAngle(Kepler.angleInPlane(parkPos, lan, i, 0.) - mNu);\n\n        const orbit: IOrbit = {\n            orbiting:           orbiting,\n            semiMajorAxis:      a,\n            eccentricity:       e,\n            inclination:        i,\n            ascNodeLongitude:   lan,\n            argOfPeriapsis:     arg,\n            meanAnomalyEpoch:   0.,     // does not affect the error or deltaV, and can be filled in later\n            epoch:              0.,     // does not affect the error or deltaV, and can be filled in later\n            semiLatusRectum:    p,\n            siderealPeriod:     Kepler.siderealPeriod(a, mu),\n        };\n\n        const soiVel = Kepler.velocityAtTrueAnomaly(orbit, mu, soiNu);\n\n        // calculate direction mismatch between the optimized orbit and the intended excess velocity\n        let err = 1 - dot3(normalize3(relativeVel), normalize3(soiVel))\n        if(isNaN(err)) {\n            err = 2;\n        }\n        console.log()\n        return {err, orbit}\n    }\n\n\n    // Oberth ejection/insertion (flyby style)\n    export function oberthDepartArriveForTrueAnomaly(nu: number, parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, c: -1 | 1,\n                                                     matchParkMo: boolean = true, soiPatchPosition: Vector3 = vec3(0,0,0), fullResult: boolean = true) {\n        const parkPos = add3(Kepler.positionAtTrueAnomaly(parkOrbit, nu), soiPatchPosition);\n        const parkVel = Kepler.velocityAtTrueAnomaly(parkOrbit, parkBody.stdGravParam, nu);\n        \n        const {deltaV, obrPreState, obrPostState, hypPreState, hypPostState} = oberthDepartArriveForPosition(parkPos, parkVel, parkBody, relativeVel, soiDate, c);\n\n        let trajectoryInfo: Trajectory = {orbits: [], intersectTimes: [], maneuvers: []};\n        if(fullResult) {\n            const obrEpoch = matchParkMo ? Kepler.trueAnomalyToOrbitDate(nu, parkOrbit, obrPreState.date - parkOrbit.siderealPeriod/2) : obrPreState.date;\n            const adjustedSoiDate = soiDate + obrEpoch - obrPreState.date;\n            hypPreState.date  = hypPreState.date + obrEpoch - obrPreState.date;\n            hypPostState.date = hypPreState.date;\n            obrPreState.date  = obrEpoch;\n            obrPostState.date = obrEpoch;\n\n            const obrOrbit = Kepler.stateToOrbit(obrPostState, parkBody);\n            const hypOrbit = Kepler.stateToOrbit(hypPostState, parkBody);\n\n            if(c === 1) {\n                const obrManeuver = Kepler.maneuverFromOrbitalStates(obrPreState, obrPostState);\n                const hypManeuver = Kepler.maneuverFromOrbitalStates(hypPostState, hypPostState);\n                trajectoryInfo = {\n                    orbits:             [obrOrbit, hypOrbit],\n                    intersectTimes:     [obrOrbit.epoch, hypOrbit.epoch, adjustedSoiDate],\n                    maneuvers:          [obrManeuver, hypManeuver],\n                }\n            } else {\n                const obrManeuver = Kepler.maneuverFromOrbitalStates(obrPostState, obrPreState);\n                const hypManeuver = Kepler.maneuverFromOrbitalStates(hypPostState, hypPostState);\n                trajectoryInfo = {\n                    orbits:             [hypOrbit, obrOrbit],\n                    intersectTimes:     [adjustedSoiDate, hypOrbit.epoch, obrOrbit.epoch],\n                    maneuvers:          [hypManeuver, obrManeuver],\n                }\n            }\n        }\n\n        return {deltaV, err: 0, trajectoryInfo}\n    }\n\n\n    export function oberthDepartArriveForPosition(parkPos: Vector3, parkVel: Vector3, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, c: 1 | -1) {\n        const mu = parkBody.stdGravParam;\n        const soi = parkBody.soi;\n\n        const mr = mag3(parkPos);\n        const parkPosDir = div3(parkPos, mr);\n\n        const soiVelSq = magSq3(relativeVel);\n        const soiDir = div3(relativeVel, Math.sqrt(soiVelSq));\n        const hypEnergy  = soiVelSq  / 2 - mu / soi;\n        const hypSMA = -mu / (2 * hypEnergy);  \n\n        const hDir = normalize3(cross3(parkPosDir, soiDir));            // direction of angular moment vector, normal to the trajectory plane\n        const delta = counterClockwiseAngleInPlane(parkPosDir, soiDir, hDir);  // angle between incoming and outgoing velocity vectors (flyby angle)\n\n        // require that the incoming and outgoing orbits intersect at their periapses.\n        // find the periapsis height that gives the correct flyby angle at the lowest deltaV\n        const objective = (periapsis: number, fullResult: boolean = false) => {\n            const hypEcc    = 1 - periapsis / hypSMA;\n            const hypSLR    = hypSMA  * (1 - hypEcc  * hypEcc); \n            const hypNu     = c * Kepler.trueAnomalyAtDistance(soi, hypEcc,  hypSLR);   // true anomaly at SoI\n            const hypDelta  = Kepler.motionAngleAtTrueAnomaly(hypNu, hypEcc);           // angle of motion direction at SoI\n            const obrNu     = wrapAngle(hypDelta - delta, -Math.PI * (c + 1));          // true anomaly at Oberth maneuver start\n            const obrEcc    = (periapsis / mr - 1) / Math.cos(obrNu);\n            const obrSMA    = periapsis / (1 - obrEcc);\n            const obrEnergy = -mu  / (2 * obrSMA) ;\n\n            const obrPeriapsisSpeed = Math.sqrt((obrEnergy + mu / periapsis) * 2); \n            const hypPeriapsisSpeed = Math.sqrt((hypEnergy + mu / periapsis) * 2); \n\n            // align perifocal frame with the inertial frame \n            const perifocalSoiDir = vec3(Math.cos(hypDelta), Math.sin(hypDelta), 0);\n            const {rotationAxis, rotationAngle} = alignVectorsAngleAxis(perifocalSoiDir, soiDir);\n\n            // velocity of the Oberth maneuver at the intersect with the parking orbit\n            const obrSpeed = Math.sqrt((obrEnergy + mu / mr) * 2);\n            const perifocalObrDir = Kepler.motionDirectionAtTrueAnomaly(obrNu, obrEcc);\n            const obrDir = roderigues(perifocalObrDir, rotationAxis, rotationAngle);\n            const obrVel = mult3(obrDir, obrSpeed);\n\n            // results\n            const deltaV = Math.abs(obrPeriapsisSpeed - hypPeriapsisSpeed) + mag3(sub3(obrVel, parkVel));\n            let periapsisPos: Vector3 = vec3(0,0,0);        // store useless values during optimization\n            let hypPeriapsisVel: Vector3 = vec3(0,0,0);     \n            let obrPeriapsisVel: Vector3 = vec3(0,0,0);\n            let hypDuration: number = 0;\n            let obrDuration: number = 0;\n            if(fullResult) {    // only prepare the full info outisde of the optimization loop, since only deltaV is optimized\n                periapsisPos = mult3(roderigues(vec3(1,0,0), rotationAxis, rotationAngle), periapsis);\n                const periapsisVelDir = roderigues(vec3(0,1,0), rotationAxis, rotationAngle);\n                hypPeriapsisVel = mult3(periapsisVelDir, hypPeriapsisSpeed);\n                obrPeriapsisVel = mult3(periapsisVelDir, obrPeriapsisSpeed);\n                hypDuration = Math.abs(Kepler.trueAnomalyToDate(hypNu, hypEcc, Kepler.siderealPeriod(hypSMA, mu), 0, 0));     \n                obrDuration = Math.abs(Kepler.trueAnomalyToDate(obrNu, obrEcc, Kepler.siderealPeriod(obrSMA, mu), 0, 0));\n            }\n\n            return {\n                deltaV,\n                obrVel,\n                periapsisPos,\n                hypPeriapsisVel,\n                obrPeriapsisVel,\n                hypDuration,\n                obrDuration,\n            };\n        }\n        const periapsis = brentMinimize((p: number) => objective(p).deltaV, FlybyCalcs.minFlybyRadius(parkBody), FlybyCalcs.maxFlybyRadius(parkBody), 1e-8)\n        const {deltaV, obrVel, periapsisPos, hypPeriapsisVel, obrPeriapsisVel, hypDuration, obrDuration} = objective(periapsis);\n\n        const periapsisDate = soiDate - c * hypDuration;\n        const obrDate = periapsisDate - c * obrDuration;\n\n        const obrPreState:  OrbitalState = {date: obrDate,       pos: parkPos,      vel: parkVel};\n        const obrPostState: OrbitalState = {date: obrDate,       pos: parkPos,      vel: obrVel};\n        const hypPreState:  OrbitalState = {date: periapsisDate, pos: periapsisPos, vel: obrPeriapsisVel};\n        const hypPostState: OrbitalState = {date: periapsisDate, pos: periapsisPos, vel: hypPeriapsisVel};\n\n        return {deltaV, obrPreState, obrPostState, hypPreState, hypPostState};\n    }\n\n\n    // At the SoI boundary...\n\n    function patchTrueAnomaly(orb: IOrbit, attractor: IOrbitingBody, c: 1 | -1) {\n        return c * Kepler.trueAnomalyAtDistance(attractor.soi, orb.eccentricity, orb.semiLatusRectum)\n    }\n\n    export function ejectionTrueAnomaly(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchTrueAnomaly(orb, attractor, 1)\n    }\n\n    export function insertionTrueAnomaly(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchTrueAnomaly(orb, attractor, -1)\n    }\n\n\n    function patchDate(orb: IOrbit, attractor: IOrbitingBody, c: 1 | -1) {\n        let tMin: number | undefined = undefined;\n        // take care to get correct time for elliptical (periodic) orbits\n        if(orb.eccentricity < 1) {\n            tMin = c === 1 ? orb.epoch : orb.epoch - orb.siderealPeriod;\n        }\n        return Kepler.trueAnomalyToDate(patchTrueAnomaly(orb, attractor, c), orb.eccentricity, orb.siderealPeriod, orb.meanAnomalyEpoch, orb.epoch, tMin)\n    }\n\n    export function ejectionDate(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchDate(orb, attractor, 1)\n    }\n\n    export function insertionDate(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchDate(orb, attractor, -1)\n    }\n\n\n    function patchPosition(orb: IOrbit, attractor: IOrbitingBody, c: 1 | -1) {\n        return Kepler.positionAtTrueAnomaly(orb, patchTrueAnomaly(orb, attractor, c))\n    }\n\n    export function ejectionPosition(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchPosition(orb, attractor, 1)\n    }\n\n    export function insertionPosition(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchPosition(orb, attractor, -1)\n    }\n\n\n    function patchVelocity(orb: IOrbit, attractor: IOrbitingBody, c: 1 | -1) {\n        return Kepler.velocityAtTrueAnomaly(orb, attractor.stdGravParam, patchTrueAnomaly(orb, attractor, c))\n    }\n\n    export function ejectionVelocity(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchVelocity(orb, attractor, 1)\n    }\n\n    export function insertionVelocity(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchPosition(orb, attractor, -1)\n    }\n}\n\nexport default DepartArrive","import Kepler from \"./kepler\";\nimport DepartArrive from \"./departarrive\";\nimport { lerp, vec3, magSq3, div3, normalize3, cross3, dot3, acosClamped, roderigues, alignVectorsAngleAxis, wrapAngle } from \"./math\";\nimport { brentMinimize } from \"./optim\";\n\nnamespace FlybyCalcs {\n    export function minFlybyRadius(body: IOrbitingBody) {\n        return body.radius +body.atmosphereHeight;\n    }\n\n    export function maxFlybyRadius(body: IOrbitingBody) {\n        return body.soi;\n    }\n\n    export function legDurationBounds(orb1: IOrbit, orb2: IOrbit, attractor: ICelestialBody) {\n        const meanSMA = 0.5 * (orb1.semiMajorAxis + orb2.semiMajorAxis);\n        const midPeriod = Kepler.siderealPeriod(meanSMA, attractor.stdGravParam);\n        return {lb: midPeriod / 25, ub: midPeriod * 2}\n    }\n\n    export function flybyParameters({velIn, velOut, body, time}: FlybyInputs): FlybyParams {\n        const mu = body.stdGravParam;\n        const soi = body.soi;\n\n        const inVelSq = magSq3(velIn);\n        const outVelSq = magSq3(velOut);\n        const inDir = div3(velIn, Math.sqrt(inVelSq));\n        const outDir = div3(velOut, Math.sqrt(outVelSq));\n\n        const inEnergy  = inVelSq  / 2 - mu / soi; // account for gravitational potential energy as well as\n        const outEnergy = outVelSq / 2 - mu / soi; // kinetic energy.\n        const inSMA  = -mu / (2 * inEnergy);  \n        const outSMA = -mu / (2 * outEnergy);  \n\n        const hDir = normalize3(cross3(inDir, outDir));     // direction of angular moment vector, normal to the flyby plane\n        const delta = acosClamped(dot3(inDir, outDir));     // angle between incoming and outgoing velocity vectors (flyby angle)\n\n        // require that the incoming and outgoing orbits intersect at their periapses.\n        // find the periapsis height that gives the correct flyby angle\n        const objective = (periapsis: number) => {\n            const inEcc  = 1 - periapsis / inSMA;\n            const outEcc = 1 - periapsis / outSMA;\n            const inSLR  = inSMA  * (1 - inEcc  * inEcc); \n            const outSLR = outSMA * (1 - outEcc * outEcc);\n            const inNu   = -Kepler.trueAnomalyAtDistance(soi, inEcc,  inSLR);     // true anomaly at encounter\n            const outNu  =  Kepler.trueAnomalyAtDistance(soi, outEcc, outSLR);    // true anomaly at escape\n\n            const deltaIn  = Kepler.motionAngleAtTrueAnomaly(inNu,  inEcc);\n            const deltaOut = Kepler.motionAngleAtTrueAnomaly(outNu, outEcc);\n            const obj = Math.abs(delta - wrapAngle(deltaOut - deltaIn))\n            return isNaN(obj) ? Math.PI : obj;\n        }\n        const periapsis = brentMinimize(objective, minFlybyRadius(body), maxFlybyRadius(body), 1e-8)\n        const error = objective(periapsis);\n\n        const inEcc  = 1 - periapsis / inSMA;\n        const outEcc = 1 - periapsis / outSMA;\n        \n        const periapsisSpeedIn  = Math.sqrt((inEnergy  + mu / periapsis) * 2); \n        const periapsisSpeedOut = Math.sqrt((outEnergy + mu / periapsis) * 2);\n        const deltaV = Math.abs(periapsisSpeedOut - periapsisSpeedIn);    \n        // console.log(deltaV)\n\n        return {\n            inSemiMajorAxis:    inSMA,\n            inEccentricity:     inEcc,\n            inDirection:        inDir,\n            outSemiMajorAxis:   outSMA,\n            outEccentricity:    outEcc,\n            outDirection:       outDir,\n            normalDirection:    hDir,\n            deltaV,\n            error,\n            time,\n        }\n    }\n\n    export function flybyFromParameters(params: FlybyParams, body: IOrbitingBody): Trajectory {\n        const soi = body.soi;\n        const mu = body.stdGravParam;\n        \n        const inSMA  = params.inSemiMajorAxis;\n        const outSMA = params.outSemiMajorAxis;\n        const inEcc  = params.inEccentricity;\n        // const outEcc = params.outEccentricity;\n\n        const periapsis = inSMA * (1 - inEcc);\n\n        const inSLR  = inSMA  * (1 - inEcc  * inEcc); \n        const inNu = -Kepler.trueAnomalyAtDistance(soi, inEcc,  inSLR);\n        const inPerifocalDirection  = Kepler.motionDirectionAtTrueAnomaly(inNu,  inEcc);\n\n        const {rotationAngle, rotationAxis} = alignVectorsAngleAxis(inPerifocalDirection, params.inDirection);\n\n        const periapsisPos = roderigues(vec3(periapsis, 0, 0), rotationAxis, rotationAngle);\n\n        const inPeriapsisSpeed  = Math.sqrt(mu * (2 / periapsis - 1 / inSMA));\n        const outPeriapsisSpeed = Math.sqrt(mu * (2 / periapsis - 1 / outSMA));\n\n        const inPeriapsisVel  = roderigues(vec3(0, inPeriapsisSpeed,  0), rotationAxis, rotationAngle);\n        const outPeriapsisVel = roderigues(vec3(0, outPeriapsisSpeed, 0), rotationAxis, rotationAngle);\n\n        const inPeriapsisState  = {date: params.time, pos: periapsisPos, vel: inPeriapsisVel};\n        const outPeriapsisState = {date: params.time, pos: periapsisPos, vel: outPeriapsisVel};\n\n        const inOrbit  = Kepler.stateToOrbit(inPeriapsisState,  body);\n        const outOrbit = Kepler.stateToOrbit(outPeriapsisState, body);\n        const maneuver = Kepler.maneuverFromOrbitalStates(inPeriapsisState, outPeriapsisState);\n        \n        const inDate  = DepartArrive.insertionDate(inOrbit, body);\n        const outDate = DepartArrive.ejectionDate(outOrbit, body);\n\n        const trajectory: Trajectory = {\n            orbits:         [inOrbit, outOrbit],\n            intersectTimes: [inDate, params.time, outDate],\n            maneuvers:      [maneuver],\n        };\n\n        return trajectory;\n    }\n\n    export function multiFlybyInputsFromAgent(agent: Agent, inputs: MultiFlybySearchInputs): MultiFlybyInputs {\n        const startDate = lerp(inputs.startDateMin, inputs.startDateMax, agent[0]);\n        const flightTimes: number[] = [];\n        for(let j=0; j<agent.length-1; j++) {\n            let ft = lerp(inputs.flightTimesMax[j], inputs.flightTimesMin[j], agent[j+1]);\n            flightTimes.push(ft);\n        }\n        return  {\n            system:          inputs.system,\n            startOrbit:      inputs.startOrbit,\n            endOrbit:        inputs.endOrbit,\n            flybyIdSequence: inputs.flybyIdSequence,\n            startDate,\n            flightTimes,\n            planeChange:     inputs.planeChange,\n            matchStartMo:    inputs.matchStartMo,\n            matchEndMo:      inputs.matchEndMo,\n            noInsertionBurn: inputs.noInsertionBurn,\n        };\n    }\n}\n\nexport default FlybyCalcs;","import { TWO_PI, HALF_PI, X_DIR, Z_DIR, copysign, acosClamped, wrapAngle, vec3, magSq3, mag3, sub3, div3, mult3, dot3, cross3, zxz, normalize3 } from \"./math\"\nimport { newtonRootSolve } from \"./optim\"\n\nnamespace Kepler {\n    // export function orbitElementsFromOrbitData(orbit: IOrbit): OrbitalElements {  \n    //     const p = (orbit.semiLatusRectum) ? orbit.semiLatusRectum : orbit.semiMajorAxis * (1 - orbit.eccentricity * orbit.eccentricity)\n    //     return {\n    //         orbiting:           orbit.orbiting,\n    //         semiMajorAxis:      orbit.semiMajorAxis,\n    //         eccentricity:       orbit.eccentricity,\n    //         inclination:        orbit.inclination,\n    //         argOfPeriapsis:     orbit.argOfPeriapsis,\n    //         ascNodeLongitude:   orbit.ascNodeLongitude,\n    //         meanAnomalyEpoch:   orbit.meanAnomalyEpoch,\n    //         epoch:              orbit.epoch,\n    //         semiLatusRectum:    p,\n    //     };\n    // }\n\n    export function orbitFromElements(elements: OrbitalElements, attractor: ICelestialBody): IOrbit {\n        const p = (elements.semiLatusRectum) ? elements.semiLatusRectum : elements.semiMajorAxis * (1 - elements.eccentricity * elements.eccentricity)\n        const T = (elements.siderealPeriod) ? elements.siderealPeriod : siderealPeriod(elements.semiMajorAxis, attractor.stdGravParam)\n        return {\n            orbiting:           attractor.id,\n            semiMajorAxis:      elements.semiMajorAxis,\n            eccentricity:       elements.eccentricity,\n            inclination:        elements.inclination,\n            argOfPeriapsis:     elements.argOfPeriapsis,\n            ascNodeLongitude:   elements.ascNodeLongitude,\n            meanAnomalyEpoch:   elements.meanAnomalyEpoch,\n            epoch:              elements.epoch,\n            semiLatusRectum:    p,\n            siderealPeriod:     T,\n        }\n    }\n\n    export function maneuverFromOrbitalStates(preState: OrbitalState, postState: OrbitalState): Maneuver {\n        const deltaV = sub3(postState.vel, preState.vel);\n        const deltaVMag = mag3(deltaV)\n        return {\n            preState:   preState,\n            postState:  postState,\n            deltaV:     deltaV,\n            deltaVMag:  deltaVMag,\n        }\n    }\n\n    export function maneuverToComponents(maneuver: Maneuver) {\n        const progradeDir = normalize3(maneuver.preState.vel);\n        const normalDir   = normalize3(cross3(maneuver.preState.pos, progradeDir));\n        const radialDir   = cross3(normalDir, progradeDir);\n\n        return {\n            prograde: dot3(maneuver.deltaV, progradeDir),\n            normal:   dot3(maneuver.deltaV, normalDir),\n            radial:   dot3(maneuver.deltaV, radialDir),\n        }\n    }\n\n    export function rotateToInertialFromPerifocal(x: Vector3, orbit: OrbitalElements): Vector3 {\n        const lan = orbit.ascNodeLongitude;\n        const i = orbit.inclination;\n        const arg = orbit.argOfPeriapsis;\n        return zxz(x, lan, i, arg)\n    }\n\n    export function rotateToPerifocalFromInertial(x: Vector3, orbit: OrbitalElements): Vector3 {\n        const lan = orbit.ascNodeLongitude;\n        const i = orbit.inclination;\n        const arg = orbit.argOfPeriapsis;\n        return zxz(x, -arg, -i, -lan)\n    }\n\n    export function siderealPeriod(a: number, mu: number) {\n        return TWO_PI * Math.sqrt(Math.abs(a*a*a) / mu)\n    }\n\n    export function flightPathAngleAtTrueAnomaly(nu: number, e: number) {\n        return Math.atan(e*Math.sin(nu) / (1 + e*Math.cos(nu)))\n    }\n\n    export function motionAngleAtTrueAnomaly(nu: number, e: number): number {\n        return nu + HALF_PI - flightPathAngleAtTrueAnomaly(nu, e);\n    }\n\n    export function motionDirectionAtTrueAnomaly(nu: number, e: number): Vector3 {\n        const angle = motionAngleAtTrueAnomaly(nu, e);\n        return vec3(Math.cos(angle), Math.sin(angle), 0);\n    }\n\n    export function distanceAtTrueAnomaly(nu: number, e: number, p: number) {\n        return p / (1 + e*Math.cos(nu))\n    }\n\n    export function distanceAtOrbitTrueAnomaly(nu: number, orbit: IOrbit) {\n        return distanceAtTrueAnomaly(nu, orbit.eccentricity, orbit.semiLatusRectum)\n    }\n\n    export function trueAnomalyAtDistance(r: number, e:number, p: number) {\n        return acosClamped((p/r - 1) / e)\n    }\n\n    export function dateToMeanAnomaly(date: number, T: number, M0: number, epoch: number) {\n        return M0 + TWO_PI * (date - epoch) / T;\n    }\n\n    export function meanAnomalyToDate(M: number, T: number, M0: number, epoch: number, tMin: number | undefined = undefined) {\n        let t = epoch + (M - M0) * T / TWO_PI;\n        if(tMin) {\n            const nPeriods = Math.ceil((tMin - t)/T);\n            t += T * nPeriods;\n        }\n        return t        \n    }\n\n    export function trueToMeanAnomaly(nu: number, e: number) {\n        // The parabolic case (e = 1) is note implemented\n        if(e < 1) {\n            const E = 2 * Math.atan2(Math.sin(nu/2)*Math.sqrt(1-e), Math.cos(nu/2)*Math.sqrt(1+e));\n            return E - e * Math.sin(E);\n        } else {\n            const H = 2 * Math.atanh(Math.tan(nu/2)*Math.sqrt((e-1)/(e+1)));\n            return e * Math.sinh(H) - H;\n        }\n    }\n\n    export function meanToTrueAnomaly(M: number, e: number){\n        // Solving Kepler's equation for eccentric anomaly with Newton's method.\n        if(e < 1) {\n            const E = newtonRootSolve(\n                E => E - e * Math.sin(E) - M,\n                E => 1 - e * Math.cos(E),\n                M,\n                1e-12\n            );\n            return 2 * Math.atan(Math.sqrt((1 + e)/(1 - e)) * Math.tan(E * 0.5));\n        } else {\n            const H0 = Math.abs(M) > 4*Math.PI ? Math.sign(M) * 4*Math.PI : M;\n            const H = newtonRootSolve(\n                H => e * Math.sinh(H) - H - M,\n                H => e * Math.cosh(H) - 1,\n                H0,\n                1e-12\n            );\n            return 2 * Math.atan(Math.sqrt((e + 1)/(e - 1)) * Math.tanh(H * 0.5));\n        }\n    }\n\n    export function dateToTrueAnomaly(date: number, e: number, T: number, M0: number, epoch: number) {\n        const M = dateToMeanAnomaly(date, T, M0, epoch);\n        return meanToTrueAnomaly(M, e)\n    }\n\n    export function trueAnomalyToDate(nu: number, e: number, T: number, M0: number, epoch: number, tMin: number = 0) {\n        const M = trueToMeanAnomaly(nu, e)\n        return meanAnomalyToDate(M, T, M0, epoch, tMin)\n    }\n\n    export function dateToOrbitTrueAnomaly(date: number, orbit: IOrbit) {\n        return dateToTrueAnomaly(date, orbit.eccentricity, orbit.siderealPeriod, orbit.meanAnomalyEpoch, orbit.epoch)\n    }\n\n    export function trueAnomalyToOrbitDate(nu: number, orbit: IOrbit, tMin: number = orbit.epoch) {\n        return trueAnomalyToDate(nu, orbit.eccentricity, orbit.siderealPeriod, orbit.meanAnomalyEpoch, orbit.epoch, tMin)\n    }\n\n    export function angleInPlane(pos: Vector3, lan: number, i: number, arg: number) {\n        const perifocalPos = zxz(pos, -arg, -i, -lan);\n        return Math.atan2(perifocalPos.y, perifocalPos.x);\n    }\n\n    export function angleInOrbitPlane(pos: Vector3, orbit: OrbitalElements) {\n        return angleInPlane(pos, orbit.ascNodeLongitude, orbit.inclination, orbit.argOfPeriapsis)\n    }\n\n    export function positionAtTrueAnomaly(orbit: IOrbit, nu: number): Vector3 {\n        const e = orbit.eccentricity;\n        const i = orbit.inclination;\n        const lan = orbit.ascNodeLongitude;\n        const arg = orbit.argOfPeriapsis;\n        const p = orbit.semiLatusRectum;\n\n        const r = distanceAtTrueAnomaly(nu, e, p);\n        const perifocalPos = vec3(r*Math.cos(nu), r*Math.sin(nu), 0);\n        const pos = zxz(perifocalPos, lan, i, arg);\n        return pos\n    }\n\n    export function velocityAtTrueAnomaly(orbit: IOrbit, mu: number, nu: number): Vector3 {\n        const a = orbit.semiMajorAxis;\n        const e = orbit.eccentricity;\n        const i = orbit.inclination;\n        const lan = orbit.ascNodeLongitude;\n        const arg = orbit.argOfPeriapsis;\n        const p = orbit.semiLatusRectum;\n\n        const r = distanceAtTrueAnomaly(nu, e, p);\n        const v = Math.sqrt(mu * (2/r - 1/a));\n\n        const perifocalVel = mult3(motionDirectionAtTrueAnomaly(nu, e), v);\n        const vel = zxz(perifocalVel, lan, i, arg);\n        return vel\n    }\n\n    export function orbitToPositionAtDate(orbit: IOrbit, date: number): Vector3 {\n        const e = orbit.eccentricity;\n        const M0 = orbit.meanAnomalyEpoch;\n        const epoch = orbit.epoch;\n        const T = orbit.siderealPeriod;\n\n        const nu = dateToTrueAnomaly(date, e, T, M0, epoch);\n        return positionAtTrueAnomaly(orbit, nu)\n    }\n\n    export function orbitToVelocityAtDate(orbit: IOrbit, attractor: ICelestialBody, date: number): Vector3 {\n        const e = orbit.eccentricity;\n        const M0 = orbit.meanAnomalyEpoch;\n        const epoch = orbit.epoch;\n        const T = orbit.siderealPeriod;\n\n        const mu = attractor.stdGravParam;\n\n        const nu = dateToTrueAnomaly(date, e, T, M0, epoch);\n        return velocityAtTrueAnomaly(orbit, mu, nu)\n    }\n\n    export function orbitToStateAtDate(orbit: IOrbit, attractor: ICelestialBody, date: number): OrbitalState {\n        const e = orbit.eccentricity;\n        const M0 = orbit.meanAnomalyEpoch;\n        const epoch = orbit.epoch;\n        const T = orbit.siderealPeriod;\n        \n        const mu = attractor.stdGravParam;\n\n        const nu = dateToTrueAnomaly(date, e, T, M0, epoch);\n        const pos = positionAtTrueAnomaly(orbit, nu);\n        const vel = velocityAtTrueAnomaly(orbit, mu, nu);\n\n        return {date, pos, vel}\n    }\n\n    export function stateToOrbit(state: OrbitalState, attractor: ICelestialBody) : IOrbit {\n        const nullEps = 1e-12;\n        \n        const mu = attractor.stdGravParam;\n        \n        const pos = state.pos;\n        const vel = state.vel;\n        const r = mag3(pos);\n        const v2 = magSq3(vel);\n\n        const t = state.date\n\n        // Semi-major Axis\n        const a = 1 / (2/r - v2/mu);\n\n        // Momentum\n        const h = cross3(pos, vel);\n        \n        // Inclination\n        const i = acosClamped(h.z / mag3(h));\n\n        // Eccentricity vector (points toward periapsis)\n        const eVec = sub3(div3(cross3(vel, h), mu), div3(pos, r));\n        let e = mag3(eVec);\n        let eHat = div3(eVec, e);\n        if(e <=nullEps) {\n            eHat = X_DIR;\n            e = 0;\n        }\n\n        // Vector pointing to the ascending node\n        const nVec = cross3(Z_DIR, h);\n        let n = mag3(nVec);\n        let nHat = div3(nVec, n);\n        if(n <= nullEps) {\n            nHat = eHat;\n            n = 0;\n        }\n\n        // Longitude of the ascending node\n        const lan = wrapAngle(copysign(acosClamped(nHat.x), nHat.y), 0)\n        \n        // Argument of the periapsis\n        const arg = wrapAngle(copysign(acosClamped(dot3(nHat, eHat)), eHat.z), 0)\n\n        // True anomaly\n        const nu = wrapAngle(angleInPlane(pos, lan, i, arg), 0);\n\n        // Mean anomaly\n        const M = trueToMeanAnomaly(nu, e);\n\n        // Semi-latus rectum\n        const p = a * (1 - e*e);\n\n        // Orbital period\n        const T = siderealPeriod(a, mu)\n\n        return {\n            orbiting:               attractor.id,\n            semiMajorAxis:          a,\n            eccentricity:           e,\n            inclination:            i,\n            ascNodeLongitude:       lan,\n            argOfPeriapsis:         arg,\n            meanAnomalyEpoch:       M,\n            epoch:                  t,\n            semiLatusRectum:        p,\n            siderealPeriod:         T,\n        }\n    }\n}\n\nexport default Kepler","// Includes a direct port to TypeScript of ESA's Lambert problem solver\n// from : https://github.com/esa/pykep/blob/master/src/lambert_problem.cpp\n// extended from original port by krafpy to cover multiple revolutions\n// from : \n\n/*****************************************************************************\n *   Copyright (C) 2004-2018 The pykep development team,                     *\n *   Advanced Concepts Team (ACT), European Space Agency (ESA)               *\n *                                                                           *\n *   https://gitter.im/esa/pykep                                             *\n *   https://github.com/esa/pykep                                            *\n *                                                                           *\n *   act@esa.int                                                             *\n *                                                                           *\n *   This program is free software; you can redistribute it and/or modify    *\n *   it under the terms of the GNU General Public License as published by    *\n *   the Free Software Foundation; either version 2 of the License, or       *\n *   (at your option) any later version.                                     *\n *                                                                           *\n *   This program is distributed in the hope that it will be useful,         *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *   GNU General Public License for more details.                            *\n *                                                                           *\n *   You should have received a copy of the GNU General Public License       *\n *   along with this program; if not, write to the                           *\n *   Free Software Foundation, Inc.,                                         *\n *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.               *\n *****************************************************************************/\n\nimport { TWO_PI, mag3, normalize3, add3, sub3, div3, mult3, cross3, dot3, wrapAngle} from \"./math\"\n\nnamespace Lambert\n{\n    /**\n     * Solves the Lambert's problem considering 0 revolutions and prograde direction only.\n     * @param r1vec The start position in space\n     * @param r2vec The end position in space\n     * @param tof The time of flight between the two positions\n     * @param attractor The attractor body\n     * @param retro Designates the orbit as retrograde if true.\n     * @param left Uses the left branch for the multiple revolutions problem if true\n     * @returns The velocities at each point\n     */\n    export function solve(r1vec: Vector3, r2vec: Vector3, tof: number, attractor: ICelestialBody, revs: number = 0, retro: boolean = false, left: boolean = false) {\n        const mu = attractor.stdGravParam;\n\n        // Calculating lambda and T\n        const r1 = mag3(r1vec);\n        const r2 = mag3(r2vec);\n        const c = mag3(sub3(r2vec, r1vec));\n\n        const s = 0.5 * (r1 + r2 + c);\n\n        const ir1 = div3(r1vec, r1);\n        const ir2 = div3(r2vec, r2);\n\n        const ih = normalize3(cross3(ir1, ir2));\n\n        const lambda2 = 1 - c / s;\n        let lambda = Math.sqrt(lambda2);\n         let it1: Vector3, it2: Vector3;\n\n        if(ih.z < 0) { // transfer angle is larger than 180 (viewed from upper y axis)\n            lambda = -lambda;\n            it1 = cross3(ir1, ih);\n            it2 = cross3(ir2, ih);\n        } else {\n            it1 = cross3(ih, ir1);\n            it2 = cross3(ih, ir2);\n        }\n        it1 = normalize3(it1);\n        it2 = normalize3(it2);\n\n        if(retro) {\n            lambda = -lambda;\n            it1 = mult3(it1, -1);\n            it2 = mult3(it2, -1);\n        }\n\n        const lambda3 = lambda * lambda2;\n        const T = Math.sqrt(2 * mu / (s*s*s)) * tof;\n \n        // Detect maximum number of revolutions for which there exists a solution\n        let nRevs = T / Math.PI;\n        const T00 = Math.acos(lambda) + lambda * Math.sqrt(1.0 - lambda2);\n        const T0 = (T00 + nRevs * Math.PI);\n        const T1 = 2 / 3 * (1 - lambda3);\n        let DT = 0.0, DDT = 0.0, DDDT = 0.0;\n        let DTs = {DT, DDT, DDDT};\n        if(nRevs > 0) {\n            if(T > T0) { // Use Halley iterations\n                let it = 0;\n                let err = 1.0;\n                let Tmin = T0;\n                let xOld = 0.0, xNew = 0.0;\n                while(1) {\n                    DTs = dTdx(DT, DDT, DDDT, xOld, Tmin, lambda);\n                    DT = DTs.DT;\n                    DDT = DTs.DDT;\n                    DDDT = DTs.DDDT;\n                    if(DT !== 0) {\n                        xNew = xOld - DT * DDT / (DDT * DDT - DT * DDDT / 2.0);\n                    }\n                    err = Math.abs(xOld - xNew);\n                    if ((err < 1e-13) || (it > 12)) {\n                        break;\n                    }\n                    Tmin = x2tof(Tmin, xNew, nRevs);\n                    xOld = xNew;\n                    it++;\n                }\n                if(Tmin > T) {\n                    nRevs -= 1;\n                }\n            }\n        }\n\n        // Crop maximum revolutions to the input value, revs\n        nRevs = revs < nRevs ? revs : nRevs;\n\n        //  // Initialize arrays to store output\n        //  const solslen = 2 * nRevs + 1;\n        //  const x: number[] = new Array<number>(solslen);\n        //  const v1: Vector3[] = new Array<Vector3>(solslen);\n        //  const v2: Vector3[] = new Array<Vector3>(solslen);\n        \n        let x: number;\n\n        // Single revolution case\n        if(nRevs === 0) {\n            // Initial guess\n            let x0: number;\n            if(T >= T00) {\n                x0 = -(T - T00) / (T - T00 + 4);\n            } else if(T <= T1) {\n                x0 = T1 * (T1 - T) / (2 / 5 * (1 - lambda2 * lambda3) * T) + 1;\n            } else {\n                x0 = Math.pow(T / T00, 0.69314718055994529 / Math.log(T1 / T00)) - 1;\n            } \n            // Householder iterations for 0 rev case\n            x = householderIterations(T, x0, 0, 1e-15, lambda, 15);\n\n        // Multi-rev case\n        } else {\n            let tmp = 0.0;\n            if(left) {  // left Household iterations\n                tmp = Math.pow((nRevs * Math.PI + Math.PI) / (8 * T), 2 / 3);\n            } else {    // right Householder iterations \n                tmp = Math.pow((8 * T) / (nRevs * Math.PI), 2 / 3);\n            }\n            x = (tmp - 1) / (tmp + 1);\n            x = householderIterations(T, x, nRevs, 1e-8, lambda, 15);\n        }\n\n        // Reconstruct the terminal velocities from x\n        const gamma = Math.sqrt(mu * s / 2.0);\n        const rho = (r1 - r2) / c;\n        const sigma = Math.sqrt(1 - rho * rho);\n        const y = Math.sqrt(1.0 - lambda2 + lambda2 * x * x);\n        const vr1 = gamma * ((lambda * y - x) - rho * (lambda * y + x)) / r1;\n        const vr2 = -gamma * ((lambda * y - x) + rho * (lambda * y + x)) / r2;\n        const vt = gamma * sigma * (y + lambda * x);\n        const vt1 = vt / r1;\n        const vt2 = vt / r2;\n\n        const v1 = add3(mult3(ir1, vr1), mult3(it1, vt1));\n        const v2 = add3(mult3(ir2, vr2), mult3(it2, vt2));\n        return {v1, v2};\n    }\n \n    function householderIterations(T: number, x0: number, N: number, eps: number, lambda: number, maxIters: number) {\n        let xnew = 0;\n        let tof = 0;\n        let delta = 0;\n        let DT = 0, DDT = 0, DDDT = 0;\n        \n        for(let it = 0; it < maxIters; it++) {\n            tof = x2tof(x0, lambda, N);\n            const DTs = dTdx(DT, DDT, DDDT, x0, tof, lambda);\n            DT = DTs.DT;\n            DDT = DTs.DDT;\n            DDDT = DTs.DDDT;\n\n            delta = tof - T;\n            const DT2 = DT * DT;\n            xnew = x0 - delta * (DT2 - delta * DDT / 2) / (DT * (DT2 - delta * DDT) + DDDT * delta * delta / 6);\n            x0 = xnew;\n            if(Math.abs(x0 - xnew) < eps) {\n                break\n            }\n        }\n \n        return x0;\n    }\n \n    function dTdx(DT: number, DDT: number, DDDT: number, x: number, T: number, lambda: number) {\n        const l2 = lambda * lambda;\n        const  l3 = l2 * lambda;\n        const  umx2 = 1.0 - x * x;\n        const  y = Math.sqrt(1.0 - l2 * umx2);\n        const y2 = y * y;\n        const y3 = y2 * y;\n        DT = 1.0 / umx2 * (3.0 * T * x - 2.0 + 2.0 * l3 * x / y);\n        DDT = 1.0 / umx2 * (3.0 * T + 5.0 * x * DT + 2.0 * (1.0 - l2) * l3 / y3);\n        DDDT = 1.0 / umx2 * (7.0 * x * DDT + 8.0 * DT - 6.0 * (1.0 - l2) * l2 * l3 * x / y3 / y2);\n        return {DT, DDT, DDDT};\n    }\n \n    function x2tof2(x: number, lambda: number, N: number)\n    {\n        const a = 1.0 / (1.0 - x * x);\n        if (a > 0) // ellipse\n        {\n            let alfa = 2.0 * Math.acos(x);\n            let beta = 2.0 * Math.asin(Math.sqrt(lambda * lambda / a));\n            if (lambda < 0.0) beta = -beta;\n            return ((a * Math.sqrt(a) * ((alfa - Math.sin(alfa)) - (beta - Math.sin(beta) * TWO_PI * N))) / 2.0);\n        } else {\n            let alfa = 2.0 * Math.acosh(x);\n            let beta = 2.0 * Math.asinh(Math.sqrt(-lambda * lambda / a));\n            if (lambda < 0.0) beta = -beta;\n            return (-a * Math.sqrt(-a) * ((beta - Math.sinh(beta)) - (alfa - Math.sinh(alfa))) / 2.0);\n        }\n    }\n \n    function x2tof(x: number, lambda: number, N: number)\n    {\n        const battin = 0.01;\n        const lagrange = 0.2;\n        const dist = Math.abs(x - 1);\n        if (dist < lagrange && dist > battin) { // We use Lagrange tof expression\n            return x2tof2(x, lambda, N);\n        }\n        const K = lambda * lambda;\n        const E = x * x - 1.0;\n        const rho = Math.abs(E);\n        const z = Math.sqrt(1 + K * E);\n        if (dist < battin) { // We use Battin series tof expression\n            const eta = z - lambda * x;\n            const S1 = 0.5 * (1.0 - lambda - x * eta);\n            let Q = hypergeometricF(S1, 1e-11);\n            Q = 4.0 / 3.0 * Q;\n            return (eta * eta * eta * Q + 4.0 * lambda * eta) / 2.0 + Math.PI * N / (rho**1.5);\n        } else { // We use Lancaster tof expresion\n            const y = Math.sqrt(rho);\n            const g = x * z - lambda * E;\n            let d = 0.0;\n            if (E < 0) {\n                const l = Math.acos(g);\n                d = Math.PI * N + l;\n            } else {\n                const f = y * (z - lambda * x);\n                d = Math.log(f + g);\n            }\n            return (x - lambda * z - d / y) / E;\n        }\n    }\n \n    function hypergeometricF(z: number, tol: number)\n    {\n        let Sj = 1.0;\n        let Cj = 1.0;\n        let err = 1.0;\n        let Cj1 = 0.0;\n        let Sj1 = 0.0;\n        let j = 0;\n        while (err > tol) {\n            Cj1 = Cj * (3.0 + j) * (1.0 + j) / (2.5 + j) * z / (j + 1);\n            Sj1 = Sj + Cj1;\n            err = Math.abs(Cj1);\n            Sj = Sj1;\n            Cj = Cj1;\n            j++;\n        }\n        return Sj;\n    }\n \n    // p-iteration\n    export function psolve(r1vec: Vector3, r2vec: Vector3, tof: number, attractor: ICelestialBody, revs: number = 0, retro: boolean = false) {\n        const mu = attractor.stdGravParam;\n\n        const r1 = mag3(r1vec);\n        const r2 = mag3(r2vec);\n\n        let dTheta = Math.atan2(mag3(cross3(r1vec, r2vec)), dot3(r1vec, r2vec))\n        dTheta = retro ? -dTheta : dTheta;\n        const ih = normalize3(cross3(r1vec, r2vec));\n        if (ih.z < 0) { // transfer angle is larger than 180 (viewed from upper y axis)\n            dTheta = TWO_PI - dTheta;\n        }\n\n        // p-iteration constants\n        const k = r1 * r2 * (1 - Math.cos(dTheta));\n        const L = r1 + r2;\n        const m = r1 * r2 * (1 + Math.cos(dTheta));\n\n        // bounds\n        const pj  = k / (L + Math.sqrt(2 * m));\n        const pjj = k / (L - Math.sqrt(2 * m));\n        let pmin: number;\n        let pmax: number;\n        if (dTheta > Math.PI) {\n            pmin = 0.0;\n            pmax = pjj;\n        } else {\n            pmin = pj;\n            pmax = Infinity;\n        }\n\n        // Newton p-iteration\n        const tol = 1e-12;\n        const warntol = tol*1000;\n        const maxit = 200;\n        let it = 0;\n        let err = tol + 1;\n        let p = (pj + pjj) / 2;\n        let pNext = p;\n        let a = 0.0;\n        let f = 0.0;\n        let g = 0.0;\n        let df = 0.0;\n        while (err > tol && it < maxit) {\n            it++;\n            p = pNext;\n            a = m * k * p / ((2*m - L * L) * (p * p) + 2 * k * L * p - k * k);\n            a = a === 0 ? 1e-100 : a;    // Guarantee that parabolic case does not occur\n            f = 1 - r2 / p * (1 - Math.cos(dTheta));\n            g = r1 * r2 * Math.sin(dTheta) / Math.sqrt(mu * p);\n\n            let t: number;\n            let dtdp: number;\n            df = Math.sqrt(mu / p) * Math.tan(dTheta / 2) * ((1 - Math.cos(dTheta)) / p - 1 / r1 - 1 / r2);\n            if (a>0) { // elliptical case\n                const sinDeltaE = -r1 * r2 * df / Math.sqrt(mu * a);\n                const cosDeltaE = 1 - r1 / a * (1 - f);\n                const deltaE = wrapAngle(Math.atan2(sinDeltaE, cosDeltaE));\n                const angularspeed = Math.sqrt(a * a * a / mu);\n                t = g + angularspeed * (deltaE - sinDeltaE);\n                dtdp = -g / 2 / p - 1.5 * a * (t - g) * (k * k + (2 * m - L * L) * p * p) / (m * k * p * p) + angularspeed * (2 * k * sinDeltaE) / (p * (k - L * p));\n            } else { // hyperbolic case\n                const dF = Math.acosh(1 - r1 / a * (1 - f));\n                const angularspeed = Math.sqrt(-a * a * a / mu);\n                t = g + angularspeed * (Math.sinh(dF) - dF);\n                dtdp = -g / 2 / p - 1.5 * a * (t - g) * (k * k + (2 * m - L * L) * p * p) / (m * k * p * p) - angularspeed * (2 * k * Math.sinh(dF)) / (p * (k - L * p));\n            }\n            err = Math.abs(tof - t) / tof;\n            pNext = p + (tof - t) / dtdp;\n\n            // if the next guess is outside the allowed bounds, use bisection\n            if (pNext < pmin) {\n                pNext = (p + pmin) / 2;\n            } else if (pNext > pmax) {\n                pNext = (p + pmax) / 2;\n            }\n        }\n\n        if (err > warntol) {\n            console.log('Lambert p-iteration failed to converge. error: %f', err);\n        }\n\n        const v1 = div3(sub3(r2vec, mult3(r1vec,f)), g);\n        const v2 = add3(mult3(r1vec, df), mult3(v1, g));\n        return {v1, v2}\n    }\n\n }\n \n export default Lambert","const GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;\n\n// https://en.wikipedia.org/wiki/Golden-section_search\nexport function goldenSectionSearch(func: Function, min: number, max: number, tol: number = 1e-5) {\n    const GR = GOLDEN_RATIO - 1;\n    const GRsq = 2 - GOLDEN_RATIO;\n    let a = min, b = max;\n    let h = b - a;\n    if(h < tol) {\n        return (b + a) / 2;\n    }\n    let c = a + GRsq * h;\n    let d = a + GR * h;\n    let fc = func(c);\n    let fd = func(d);\n\n    while(h > tol) {\n        if(fc < fd) {\n            b = d;\n            d = c;\n            fd = fc;\n            h = GR * h;\n            c = a + GRsq * h;\n            fc = func(c);\n        } else {\n            a = c;\n            c = d;\n            fc = fd;\n            h = GR * h;\n            d = a + GR * h;\n            fd = func(d);\n        }\n    }\n\n    if(fc < fd) {\n        return (a + d) / 2;\n    } else {\n        return (c + b) / 2;\n    }\n}\n\n// https://en.wikipedia.org/wiki/Brent%27s_method\nexport function brentRootFind(func: Function, min: number, max: number, tol: number = 1e-12, maxIters: number = 100, warntol: number = 1.0) {\n    const errtol = 2*Number.EPSILON;\n\n    let a = min, b = max;\n    let fa = func(a);\n    let fb = func(b);\n\n    // Make sure the bounds bracket a root\n    if(Math.sign(fa) === Math.sign(fb)) {\n        throw new Error(\"The provided bounds do not bracket a root.\")\n    }\n\n    // Swap a and b to ensure that func(b) is closer to 0 than func(a) \n    if(Math.abs(fa) < Math.abs(fb)) {\n        const temp_a = a;\n        a = b;\n        b = temp_a;\n\n        const temp_fa = fa;\n        fa = fb;\n        fb = temp_fa;\n    }\n\n    let c = a;\n    let fc = fa;\n\n    let d = c;\n    let bisected = true;\n\n    let s = 0.0;\n    let fs = 1.0;\n\n    let itsRemaining = maxIters;\n    while (itsRemaining) {\n        itsRemaining--;\n\n        if(Math.abs(b - a) < tol) {\n            return b\n        }\n        if(Math.abs(fb) < errtol) {\n            return b\n        }\n\n        s = 0.0;\n\n        // Inverse quadratice interpolation\n        if((Math.abs(fa - fc) > errtol) && (Math.abs(fb - fc) > errtol)) {\n            s = ((a * fb * fc) / ((fa - fb) * (fa - fc))) + \n                ((b * fa * fc) / ((fb - fa) * (fb - fc))) +\n                ((c * fa * fb) / ((fc - fa) * (fc - fb)));\n        // Otherwise, use the secant method\n        } else {\n            s = b - (fc * ((b - a) / (fb - fa)))\n        }\n        const delta = Math.abs(errtol * b);\n        const currentStep = Math.abs(s - b);\n        const previousStep = Math.abs(b - c);\n        const secondStep = Math.abs(c - d);\n\n        // bisection conditions\n        if(\n            // s is not between (((3 * a) + b) / 4)) and b\n            ((s - (((3 * a) + b) / 4)) * (s - b) >= 0) ||\n            // the interpolation step is very small\n            (bisected && (currentStep >= previousStep / 2)) ||\n            (!bisected && (currentStep >= secondStep / 2)) ||\n            // the prvious steps were close to b\n            (bisected && previousStep < delta) ||\n            (!bisected && secondStep < delta)\n        ) {\n            s = (a + b) / 2;\n            bisected = true;\n        } else {\n            bisected = false;\n        }\n\n        // return s if func(s) is sufficiently close to 0\n        fs = func(s);\n        if(Math.abs(fs) < errtol) {\n            return s;\n        }\n\n        // reset positions and bracket\n        d = c;\n        c = b;\n\n        if(Math.sign(fa) !== Math.sign(fs)) {\n            b = s;\n            fb = fs;\n        } else {\n            a = s;\n            fa = fs;\n        }\n\n        // Swap a and b to ensure that func(b) is closer to 0 than func(a) \n        if(Math.abs(fa) < Math.abs(fb)) {\n            const temp_a = a;\n            a = b;\n            b = temp_a;\n\n            const temp_fa = fa;\n            fa = fb;\n            fb = temp_fa;\n        }\n    }\n\n    // no root found, throw error\n    if (Math.abs(fs) > warntol) {\n        console.log(\"Brent's method failed to find a root. Function value of %f at %f\", fs, s)\n    }\n    return s;\n}\n\n// https://courses.seas.harvard.edu/courses/am205/g_act/am205_workshop_optimization.pdf\nexport function brentMinimize(func: Function, min: number, max: number, tol: number = 1e-8, maxIters: number = 50) {\n    // const GR = GOLDEN_RATIO - 1;\n    const GRsq = 2 - GOLDEN_RATIO;\n    const etol = tol; // 1e-3;\n    \n    let a = min, b = max;\n    let h = (b - a);\n    let x = a + GRsq * h;\n    let w = x;\n    let v = w;\n\n    let fv = func(v);\n    let fw = func(w);\n    let fx = func(x);\n\n    let u = 0.0;\n    let fu = 0.0;\n\n    let m = (a + b) / 2\n\n    let p = 0.0;\n    let q = 0.0;\n    let delta = 0.0;\n    let d = 0.0;\n    let e = 0.0;\n\n    let itsRemaining = maxIters;\n\n    while(itsRemaining) {\n        itsRemaining--;\n\n        if (h < tol) {\n            return m;\n        }\n\n        p = (w - x) * (w - x) * (fx - fv) + (v - x) * (v - x) * (fw - fx);\n        q = (w - x) * (fx -fv) + (v - x) * (fw - fx);\n\n        delta = 0.5 * p / q;\n\n        // If SPI is not well behaved, perform a Golden Section search\n        if(\n            // q is zero\n            (q === 0) ||\n            // u is not in between a and b\n            (a > u || u > b) ||\n            // p/q is not shrinking fast enough\n            (Math.abs(p/q) > 0.5 * Math.abs(e))  ||\n            // e is too small\n            (Math.abs(e) < etol) \n        ) {\n            e = (x < m) ? b-x : a-x;\n            d = GRsq * e;\n        // Otherwise, carry on with SPI\n        } else {\n            e = d;\n            d = delta;\n        }\n\n        u = x + d;\n\n        // newest function evaluation\n        fu = func(u);\n\n        // update bracket and previous guesses\n        // u is the best guess so far\n        if(fu <= fx) {\n            a = (u < x) ? a : x;\n            b = (u < x) ? x : b;\n            v = w;\n            w = x;\n            x = u;\n            fv = fw;\n            fw = fx;\n            fx = fu;\n        // fu is worse than fx\n        } else {\n            a = (u < x) ? u : a;\n            b = (u < x) ? b : u;\n            // fu is the second-best guess\n            if((fu <= fw) || (w === x)) {\n                v = w;\n                w = u;\n                fv = fw;\n                fw = fu;\n            // fu is the third-best guess\n            } else if((fu <= fv) || (v === x) || (v === w)) {\n                v = u;\n                fv = fu;\n            // fu is the worst guess\n            } else {\n                // Don't keep u, only the bracket is updated\n            }\n        }\n\n        // update interval size and midpoint\n        h = b - a;\n        m = (a + b) / 2;\n    }\n    // if(h > tol) {\n    //     console.log(\"Brent's minimization method failed to converge. Interval size: \", h)\n    // }\n    return m\n}\n\nexport function newtonRootSolve(\n    f: (x: number) => number,\n    df: (x: number) => number,\n    x0: number,\n    eps: number,\n    maxIters: number = 1000\n){\n    let n = 0;\n    let prevX: number;\n    let x = x0;\n    let err = eps + 1;\n    let errp = err + 1;\n    while(err > eps && n < maxIters){\n        prevX = x;\n        x -= f(x) / df(x);\n        errp = err;\n        err = Math.abs(x - prevX);\n        if(errp < err) {            // Modification to Newton's method, using bisection in case the error gets worse with an iteration\n            x = (x + prevX) / 2;    // This helps in case of poor initializations that lead to large overshoot, where the algorithm would not otherwise converge\n        }\n        n++;\n    }\n    if (n >= maxIters) {\n        console.log(\"Newton's method failed to find a root. Error of %f. \", err)\n    }\n    return x;\n}\n\ninterface NMpoint\n{\n    x:       number[],\n    objx:    number,\n}\n\nfunction sortNMpoints(p1: NMpoint, p2: NMpoint) : number {\n    return p1.objx - p2.objx;\n}\n\n\n// https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method#One_possible_variation_of_the_NM_algorithm\nexport function nelderMeadMinimize(\n    initialPoints:  number[][],\n    objective:      (x: number[]) => number,\n    tol:            number = 1.0,   // Non-standard approach to termination, since my objective functions have an assumed minimum (0.0)\n    maxIt:          number = initialPoints[0].length * 250,\n    alpha:          number = 1.0,\n    gamma:          number = 2.0,\n    rho:            number = 0.5,\n    sigma:          number = 0.5,\n    \n): number[] {\n\n    const n: number = initialPoints[0].length;\n    const simplex: NMpoint[]    = [];\n    const centroid: number[]    = initialPoints[0].slice()\n    const reflect: number[]     = centroid.slice();\n    const contract: number[]    = centroid.slice();\n    const expand: number[]      = centroid.slice();\n\n    // create simplex from initial points\n    for(let i = 0; i <= n; i++) {\n        simplex.push({x: initialPoints[i], objx: objective(initialPoints[i])})\n    }\n\n    // iterate until termination\n    let err = tol + 1;\n    for(let it = 0; it < maxIt; it++) {\n        // sort the simplex by objective function value\n        simplex.sort(sortNMpoints);\n        err = simplex[0].objx;\n        if(err < tol) {\n            break\n        }\n\n        // TODO: add convergence test for general case\n\n        // calculate the centroid of the simplex\n        for(let i = 0; i <= n; i++) {\n            centroid[i] = 0.0;\n            for(let j = 0; j < n; j++) {\n                centroid[i] = centroid[i] + simplex[j].x[i];\n            }\n            centroid[i] = centroid[i] / n;\n        }\n\n        // reflect worst point across the centroid\n        for(let i = 0; i < n; i++) {\n            reflect[i] = centroid[i] + alpha * (centroid[i] - simplex[n].x[i]);\n        }\n        const objReflect = objective(reflect);\n\n        // if the point is better than second worse, but not the best,\n        // replace the worst point with the reflected point and iterate\n            if(objReflect < simplex[n - 1].objx && objReflect >= simplex[0].objx) {\n                simplex[n].x = reflect.slice();\n                simplex[n].objx = objReflect;\n                continue\n            }\n\n        // if the relfected point is the best so far, expand the reflected point\n        if(objReflect < simplex[0].objx) {\n            for(let i = 0; i < n; i++) {\n                expand[i] = centroid[i] + gamma * (reflect[i] - centroid[i]);\n            }\n            const objExpand = objective(expand);\n\n            // use the better of the expanded and reflected points to replace the worst point\n            // then, iterate\n            if(objExpand < objReflect) {\n                simplex[n].x = expand.slice();\n                simplex[n].objx = objExpand;\n            } else {\n                simplex[n].x = reflect.slice();\n                simplex[n].objx = objReflect;\n            }\n            continue\n        }\n\n        // Here, the reflected point is at least as bad as the second worst point\n        // If it is the worst point, compute the contracted point on the inside\n        if(objReflect > simplex[n].objx) {\n            for(let i = 0; i < n; i++) {\n                contract[i] = centroid[i] + rho * (simplex[n].x[i] - centroid[i]);\n            }        \n            const objContract = objective(contract);\n            // replace worst point if this one is any better, then iterate\n            if(objContract < simplex[n].objx) {\n                simplex[n].x = contract.slice();\n                simplex[n].objx = objContract;\n                continue\n            }\n        // otherwise, compute the contracted point on the outside\n        } else {\n            for(let i = 0; i < n; i++) {\n                contract[i] = centroid[i] + rho * (reflect[i] - centroid[i]);\n            }    \n            const objContract = objective(contract);\n            // replace worst point if this one is an improvement on the reflection, then iterate\n            if(objContract < objReflect) {\n                simplex[n].x = contract.slice();\n                simplex[n].objx = objContract;\n                continue\n            }\n        }\n\n        // At this step, all points will be shrunk toward the best point\n        for(let i = 1; i <= n; i++) {\n            for(let j = 1; j < n; j++) {\n                simplex[i].x[j] = simplex[0].x[j] + sigma * (simplex[i].x[j] - simplex[0].x[j]);\n            }\n            simplex[i].objx = objective(simplex[i].x);\n        }\n    }\n    return simplex[0].x\n}\n\n","import Kepler from './kepler';\nimport Lambert from './lambert';\nimport DepartArrive from './departarrive';\nimport { vec3, add3, sub3, mag3, normalize3, cross3, dot3, roderigues, wrapAngle, acosClamped, HALF_PI, Z_DIR } from './math';\n\nnamespace Trajectories {\n    export function transferTrajectory(startOrbit: IOrbit, endOrbit: IOrbit, transferBody: ICelestialBody, startDate: number, flightTime: number, endDate: number, \n                                       planeChange: boolean, startPatchPosition: Vector3 = vec3(0,0,0), endPatchPosition: Vector3 = vec3(0,0,0)): Trajectory {\n        \n        const startState = Kepler.orbitToStateAtDate(startOrbit, transferBody, startDate);\n        const endState   = Kepler.orbitToStateAtDate(endOrbit,   transferBody, endDate); \n        const startPos = add3(startState.pos, startPatchPosition);\n        const endPos   = add3(endState.pos,   endPatchPosition);\n\n        if(planeChange) { // for plane-change-style transfer...\n            // project the end position to the perifocal plane of the pre-transfer orbit, and compute a transfer\n            let planeEndPos = Kepler.rotateToPerifocalFromInertial(endPos, startOrbit);\n            planeEndPos = Kepler.rotateToInertialFromPerifocal(vec3(planeEndPos.x, planeEndPos.y, 0.0), startOrbit);\n\n            const {v1} = Lambert.solve(startPos, planeEndPos, flightTime, transferBody);\n            const transferOrbit1 = Kepler.stateToOrbit(\n                {\n                    date: startDate,\n                    pos:  startPos,\n                    vel:  v1\n                },\n                transferBody\n            );\n            \n            // identify the true anomaly and date at the plane change (use PI/2 prior to target encounter)\n            const startNu = Kepler.angleInOrbitPlane(startPos, transferOrbit1);\n            // let startNu = Kepler.dateToOrbitTrueAnomaly(startDate, transferOrbit1);\n            // if(isNaN(startNu)) {    // in case Newton root solving fails for the inverse Kepler equation (near parabolic orbits?)\n            //     startNu = Kepler.angleInOrbitPlane(startPos, transferOrbit1);\n            // }\n            const endNu = Kepler.angleInOrbitPlane(planeEndPos, transferOrbit1);\n            // let endNu = Kepler.dateToOrbitTrueAnomaly(endDate, transferOrbit1);\n            // if(isNaN(endNu)) {      // in case Newton root solving fails for the inverse Kepler equation (near parabolic orbits?)\n            //     endNu = Kepler.angleInOrbitPlane(planeEndPos, transferOrbit1);\n            // }\n            const planeChangeNu = startNu + Math.max(0.0, (wrapAngle(endNu - startNu) - HALF_PI));\n            const planeChangeDate = Kepler.trueAnomalyToOrbitDate(planeChangeNu, transferOrbit1, startDate);\n\n            // rotate the velocity vector at the plane change location to hit the target at encounter\n            const planeChangePreState = {\n                date: planeChangeDate,\n                pos:  Kepler.positionAtTrueAnomaly(transferOrbit1, planeChangeNu),\n                vel:  Kepler.velocityAtTrueAnomaly(transferOrbit1, transferBody.stdGravParam, planeChangeNu),\n            };\n            const n1vec = normalize3(cross3(planeChangePreState.pos, planeChangePreState.vel));\n            const n2vec = normalize3(cross3(planeChangePreState.pos, endPos));\n            const rotationAngle = acosClamped(dot3(n1vec, n2vec));\n            let rotationAxis = rotationAngle === 0 ? Z_DIR : normalize3(cross3(n1vec, n2vec));\n            rotationAxis = isNaN(rotationAxis.x) ? Z_DIR : rotationAxis;\n            const newVel = roderigues(planeChangePreState.vel, rotationAxis, rotationAngle);\n\n            // compute the transfer orbit from the plane change position and post-maneuver velocity;\n            const planeChangePostState = {\n                date: planeChangeDate, \n                pos: planeChangePreState.pos, \n                vel: newVel,\n            };\n            const transferOrbit2 = Kepler.stateToOrbit(planeChangePostState,transferBody);\n\n            // prepare maneuvers at beginning and end of transfer\n            const departState: OrbitalState = {\n                date: startDate,\n                pos:  startPos,\n                vel:  v1,\n            }\n            let arriveState = Kepler.orbitToStateAtDate(transferOrbit2, transferBody, endDate);\n            if(isNaN(arriveState.pos.x)) {  // in case Newton root solving fails for the inverse Kepler equation (near parabolic orbits?)\n                const arriveNu = Kepler.angleInOrbitPlane(endPos, transferOrbit2);\n                arriveState = {\n                    date: endDate,\n                    pos:  endPos,\n                    vel:  Kepler.velocityAtTrueAnomaly(transferOrbit2, transferBody.stdGravParam, arriveNu),\n                };\n            }\n\n            const departManeuver = Kepler.maneuverFromOrbitalStates(startState, departState);\n            const arriveManeuver = Kepler.maneuverFromOrbitalStates(arriveState, endState);\n            const planeManeuver  = Kepler.maneuverFromOrbitalStates(planeChangePreState, planeChangePostState)\n\n            const trajectory = {orbits:         [transferOrbit1, transferOrbit2],\n                                intersectTimes: [startDate, planeChangeDate, endDate],\n                                maneuvers:      [departManeuver, planeManeuver, arriveManeuver]};\n                   \n            return trajectory;    \n        } else {\n            const {v1, v2} = Lambert.solve(startPos, endPos, flightTime, transferBody)\n\n            // prepare maneuvers at beginning and end of transfer\n            const departState: OrbitalState = {\n                date: startDate,\n                pos:  startPos,\n                vel:  v1,\n            }\n            const arriveState: OrbitalState = {\n                date: endDate,\n                pos:  endPos,\n                vel:  v2,\n            }\n\n            const departManeuver = Kepler.maneuverFromOrbitalStates(startState, departState);\n            const arriveManeuver = Kepler.maneuverFromOrbitalStates(arriveState, endState);\n\n            const trajectory = {orbits:         [Kepler.stateToOrbit({ date: startDate, pos: startPos, vel: v1}, transferBody)],\n                                intersectTimes: [startDate, endDate],\n                                maneuvers:      [departManeuver, arriveManeuver]};\n            return trajectory;\n        }\n    }\n\n    function bodyFromId(system: ISolarSystem, id: number) {\n        if(id === 0) {\n            return system.sun;\n        } else {\n            const body = system.orbiterIds.get(id);\n            if(!body)\n                throw new Error(`No body with id ${id}`);\n            return body;\n        }\n    }\n\n    export function ejectionTrajectories(system: ISolarSystem, startOrbit: IOrbit, transferOrbit: IOrbit, ejectionSequence: number[], transferStartDate: number, \n                                         matchStartMo: boolean = true, type: \"simple\" | \"direct\" | \"oberth\" = \"simple\", soiPatchPositions: Vector3[] = ejectionSequence.slice(-1).map((i) => vec3(0,0,0))): Trajectory[] {\n        let ejectionInfos: Trajectory[] = [];\n        \n        let nextOrbit: IOrbit;\n        let previousOrbit: IOrbit;\n\n        let nextOrbitVel: Vector3;\n        let currentBodyVel: Vector3;\n\n        let escapeDate = transferStartDate;\n        const nEjections = ejectionSequence.length - 1;\n        for(let i=nEjections - 1; i>=0; i--) {\n            // body around which the ejection orbit takes place\n            const currentBody = (bodyFromId(system, ejectionSequence[i]) as IOrbitingBody);\n            // body after escape\n            const nextBody = bodyFromId(system, ejectionSequence[i+1]);\n            // if this is the first ejection, use the starting orbit\n            if(i === 0) {\n                previousOrbit = startOrbit;\n            // otherwise, use the orbit of the body that has just been escaped\n            } else {\n                const previousBody = (bodyFromId(system, ejectionSequence[i-1]) as IOrbitingBody);\n                previousOrbit = previousBody.orbit;\n            }\n            // if this is the last ejection, use the transfer orbit as the next orbit\n            if(i === nEjections - 1) {\n                nextOrbit = transferOrbit;\n                nextOrbitVel = Kepler.orbitToVelocityAtDate(nextOrbit, nextBody, escapeDate);\n                currentBodyVel = Kepler.orbitToVelocityAtDate(currentBody.orbit, nextBody, escapeDate);\n            // otherwise, use the next ejection orbit\n            } else {\n                const nextEjection = ejectionInfos[ejectionInfos.length-1];\n                nextOrbit      = nextEjection.orbits[0];\n                nextOrbitVel   = nextEjection.maneuvers[0].postState.vel;\n                escapeDate     = nextEjection.maneuvers[0].postState.date;\n                currentBodyVel = nextEjection.maneuvers[0].preState.vel;\n            }\n                        \n            // get relative velocity to the current body at escape\n            const relativeVel = sub3(nextOrbitVel, currentBodyVel);\n\n            // always match the mean anomaly of a body's orbit\n            const matchOrb = i > 0 ? true : matchStartMo;\n\n            // calculate the ejection trajectory\n            let currentEjection: Trajectory = type === \"simple\" ? DepartArrive.simpleDeparture(previousOrbit,  currentBody, relativeVel, escapeDate, matchOrb) :\n                                              type === \"direct\" ? DepartArrive.optimalDeparture(previousOrbit, currentBody, relativeVel, escapeDate, matchOrb, \"direct\", soiPatchPositions[i]) :\n                                              type === \"oberth\" ? DepartArrive.optimalDeparture(previousOrbit, currentBody, relativeVel, escapeDate, matchOrb, \"oberth\", soiPatchPositions[i]) :\n                                              DepartArrive.simpleDeparture(previousOrbit,  currentBody, relativeVel, escapeDate, matchOrb);\n\n            // if there is a nonzero SoI patch position for this ejection, and the \"simple\" type was used, recalculate the ejection with the modified start position\n            if(i > 0 && type === \"simple\") {\n                const currentPatch =soiPatchPositions[i-1]\n                if(mag3(currentPatch) > 0) {\n                    // optimize ejection eccentricity based on starting position\n                    const patchedEjOrb = DepartArrive.departArriveForPosition(add3(currentEjection.maneuvers[0].preState.pos, currentPatch),\n                                                                              currentBody,\n                                                                              relativeVel,\n                                                                              escapeDate,\n                                                                              1).orbit;\n                    // calculate the date when the exited body is at the right place\n                    const previousOrbitNu = Kepler.angleInOrbitPlane(currentEjection.maneuvers[0].preState.pos, previousOrbit);\n                    const ejEpoch = Kepler.trueAnomalyToOrbitDate(previousOrbitNu, previousOrbit, patchedEjOrb.epoch - previousOrbit.siderealPeriod / 2)\n                    const soiDate = escapeDate + ejEpoch - patchedEjOrb.epoch;\n                    patchedEjOrb.epoch = ejEpoch;\n\n                    // prepare orbital states for exited body and ejection orbit at time of ejection\n                    const ejPreVel = Kepler.velocityAtTrueAnomaly(previousOrbit, currentBody.stdGravParam, previousOrbitNu);\n                    const ejPreState: OrbitalState = {date: ejEpoch, pos: currentEjection.maneuvers[0].preState.pos, vel: ejPreVel};\n                    const ejPostState = Kepler.orbitToStateAtDate(patchedEjOrb, currentBody, patchedEjOrb.epoch);\n                    const maneuver = Kepler.maneuverFromOrbitalStates(ejPreState, ejPostState);\n                    currentEjection = {\n                        orbits:             [patchedEjOrb],\n                        intersectTimes:     [ejEpoch, soiDate],\n                        maneuvers:          [maneuver],\n                    }\n                }\n            }\n\n            // add the calculated ejection to the list\n            ejectionInfos.push(currentEjection);\n        }\n\n        return ejectionInfos.reverse();\n    }\n\n    export function insertionTrajectories(system: ISolarSystem, endOrbit: IOrbit, transferOrbit: IOrbit, insertionSequence: number[], transferEndDate: number, \n                                          matchEndMo: boolean = true, type: \"simple\" | \"direct\" | \"oberth\" = \"simple\", soiPatchPositions: Vector3[] = insertionSequence.slice(0,-1).map((i) => vec3(0,0,0))): Trajectory[] {\n        let insertionInfos: Trajectory[] = [];\n\n        let previousOrbit: IOrbit;\n        let nextOrbit: IOrbit;\n\n        let previousOrbitVel: Vector3;\n        let currentBodyVel: Vector3;\n\n        let encounterDate = transferEndDate;\n        const nInsertions = insertionSequence.length - 1;\n        for(let i=1; i<=nInsertions; i++) {\n            // body around which the insertion orbit takes place\n            const currentBody = (bodyFromId(system, insertionSequence[i]) as IOrbitingBody);\n            // body prior to encounter\n            const previousBody = bodyFromId(system, insertionSequence[i-1]);\n            // if this is the last insertion, use the ending orbit\n            if(i === nInsertions) {\n                nextOrbit = endOrbit;\n            // otherwise, use the orbit of the body about to be encountered\n            } else {\n                const nextBody = (bodyFromId(system, insertionSequence[i+1]) as IOrbitingBody);\n                nextOrbit = nextBody.orbit;\n            }\n            // if this is the first insertion, use the transfer orbit as the next orbit\n            if(i === 1) {\n                previousOrbit = transferOrbit;\n                previousOrbitVel = Kepler.orbitToVelocityAtDate(previousOrbit, previousBody, encounterDate);\n                currentBodyVel = Kepler.orbitToVelocityAtDate(currentBody.orbit, previousBody, encounterDate);\n            // otherwise, use the previous insertion orbit\n            } else {\n                const previousInsertion = insertionInfos[insertionInfos.length-1];\n                const prevInLen  = previousInsertion.orbits.length;\n                const prevManLen = previousInsertion.maneuvers.length;\n                previousOrbit    = previousInsertion.orbits[prevInLen - 1];\n                previousOrbitVel = previousInsertion.maneuvers[prevManLen - 1].preState.vel;\n                encounterDate    = previousInsertion.maneuvers[prevManLen - 1].preState.date;\n                currentBodyVel   = previousInsertion.maneuvers[prevManLen - 1].postState.vel;\n            }\n\n            // get relative velocity to the current body at encounter\n            const relativeVel = sub3(previousOrbitVel, currentBodyVel);\n\n            // always match the mean anomaly of a body's orbit\n            const matchOrb = i < nInsertions ? true : matchEndMo;\n\n            // calculate the insertion trajectory\n            let currentInsertion = type === \"simple\" ? DepartArrive.simpleArrival(nextOrbit,  currentBody, relativeVel, encounterDate, matchOrb) :\n                                   type === \"direct\" ? DepartArrive.optimalArrival(nextOrbit, currentBody, relativeVel, encounterDate, matchOrb, \"direct\", soiPatchPositions[i]) :\n                                   type === \"oberth\" ? DepartArrive.optimalArrival(nextOrbit, currentBody, relativeVel, encounterDate, matchOrb, \"oberth\", soiPatchPositions[i]) :\n                                   DepartArrive.simpleArrival(nextOrbit, currentBody, relativeVel, encounterDate, matchOrb);\n            \n            // if there is a nonzero SoI patch position for this insertion, and it's not the last one,  recalculate the ejection with the modified start position\n            if(i < nInsertions && type === \"simple\") {\n                if(mag3(soiPatchPositions[i]) > 0) {\n                    const manLen = currentInsertion.maneuvers.length;\n                    const patchedInOrb = DepartArrive.departArriveForPosition(add3(currentInsertion.maneuvers[manLen - 1].postState.pos, soiPatchPositions[i]),\n                                                                              currentBody,\n                                                                              relativeVel,\n                                                                              encounterDate,\n                                                                              -1).orbit;\n                    // calculate the date when the encountered body is at the right place\n                    const nextOrbitNu = Kepler.angleInOrbitPlane(currentInsertion.maneuvers[manLen - 1].postState.pos, nextOrbit);\n                    const inEpoch = Kepler.trueAnomalyToOrbitDate(nextOrbitNu, nextOrbit, patchedInOrb.epoch - nextOrbit.siderealPeriod / 2);\n                    const soiDate = encounterDate + inEpoch - patchedInOrb.epoch;\n                    patchedInOrb.epoch = inEpoch;\n\n                    // prepare orbital states for encountered body and insertion orbit at time of encounter\n                    const inPreVel = Kepler.velocityAtTrueAnomaly(nextOrbit, currentBody.stdGravParam, nextOrbitNu);\n                    const inPostState: OrbitalState = {date: inEpoch, pos: currentInsertion.maneuvers[manLen - 1].postState.pos, vel: inPreVel};\n                    const inPreState = Kepler.orbitToStateAtDate(patchedInOrb, currentBody, patchedInOrb.epoch);\n                    const maneuver = Kepler.maneuverFromOrbitalStates(inPreState, inPostState);\n\n                    currentInsertion = {\n                        orbits:         [patchedInOrb],\n                        intersectTimes: [soiDate, inEpoch],\n                        maneuvers:      [maneuver],\n                    }\n                }\n            }\n            insertionInfos.push(currentInsertion);\n        }\n        return insertionInfos;\n    }\n\n}\n\nexport default Trajectories;","import Orbit from \"./orbit\"\nimport Color from \"./color\";\n\nexport class CelestialBody implements ICelestialBody {\n    readonly id!:               number;\n    readonly name!:             string;\n    readonly radius!:           number;\n    readonly atmosphereHeight!: number;\n    readonly mass!:             number;\n    readonly stdGravParam!:     number;\n    readonly soi!:              number;\n    readonly color!:            Color;\n    readonly orbiters:          OrbitingBody[] = [];\n\n    constructor(data: ICelestialBody) {\n        this.id                 = data.id;\n        this.name               = data.name;\n        this.radius             = data.radius;\n        this.atmosphereHeight   = data.atmosphereHeight;\n        this.mass               = data.mass;\n        this.stdGravParam       = data.stdGravParam;\n        this.soi                = data.soi;\n        this.color              = new Color(data.color);\n    }\n\n    public get data() : ICelestialBody {\n        return {\n            id:                 this.id,\n            name:               this.name,\n            radius:             this.radius,\n            atmosphereHeight:   this.atmosphereHeight,\n            mass:               this.mass,\n            stdGravParam:       this.stdGravParam,\n            soi:                this.soi,\n            color:              this.color\n        }\n    }\n\n    public get orbiterIds() : number[] {\n        let orbIds: number[] = [];\n        for(let i=0; i<this.orbiters.length; i++) {\n            orbIds.push(this.orbiters[i].id)\n        }\n        return orbIds\n    }\n\n    public get furtherstOrbiterDistance() : number {\n        let maxDist = 0.0;\n        for(let i=0; i<this.orbiters.length; i++) {\n            const orb = this.orbiters[i].orbit;\n            const orbDist = orb.semiMajorAxis * (1 + orb.eccentricity);\n            maxDist = Math.max(orbDist, maxDist)\n        }\n        return maxDist;\n    }\n}\n\nexport class OrbitingBody extends CelestialBody implements IOrbitingBody {\n    readonly orbit!:            Orbit;\n    readonly orbiting!:         number;\n\n    constructor(data: IOrbitingBody, public readonly attractor: CelestialBody, anglesToRad: boolean = false) {\n        super(data);\n        \n        this.orbit        = new Orbit(data.orbit, this.attractor, anglesToRad);\n        this.orbiting     = data.orbiting;\n    }\n\n    public get data(): IOrbitingBody {\n        return {\n            ...super.data,\n            orbit:          this.orbit.data,\n            orbiting:       this.orbiting,\n        };\n    }\n}\n\nexport function isOrbitingBody(body: ICelestialBody): body is OrbitingBody {\n    return (body as OrbitingBody).orbiting !== undefined;\n}\n\nexport default CelestialBody;","export class Color implements IColor {\n    readonly r!:    number;\n    readonly g!:    number;\n    readonly b!:    number;\n\n    constructor(c: IColor) {\n        this.r = c.r;\n        this.g = c.g;\n        this.b = c.b;\n    }\n\n    public rescale(scale: number) {\n        return new Color({r: Math.max(Math.min(scale * this.r, 255), 0), \n                          g: Math.max(Math.min(scale * this.g, 255), 0), \n                          b: Math.max(Math.min(scale * this.b, 255), 0)});\n    }\n\n    public toString() {\n        return 'rgb('.concat(this.r.toString(), \",\", this.g.toString(), \",\", this.b.toString(), \")\");\n    }\n}\n\nexport default Color;","import Kepler from \"../libs/kepler\";\nimport { degToRad } from \"../libs/math\";\n\nexport class Orbit implements IOrbit {\n    readonly semiMajorAxis!:         number;\n    readonly apoapsis!:              number;\n    readonly periapsis!:             number;\n    readonly eccentricity!:          number;\n    readonly inclination!:           number;\n    readonly argOfPeriapsis!:        number;\n    readonly ascNodeLongitude!:      number;\n    readonly meanAnomalyEpoch!:      number;\n    readonly epoch!:                 number; \n    readonly semiLatusRectum!:       number;\n    readonly siderealPeriod!:        number;\n    readonly orbiting!:              number;\n    readonly attractorSoi!:          number;\n    readonly attractorStdGravParam!: number\n\n\n    constructor (data: IOrbit, attractor: ICelestialBody, anglesToRad: boolean = false) {\n        this.semiMajorAxis = data.semiMajorAxis;\n        this.eccentricity  = data.eccentricity;\n        this.meanAnomalyEpoch = data.meanAnomalyEpoch;\n        this.epoch = data.epoch;\n\n        if (anglesToRad) {\n            this.inclination = degToRad(data.inclination);\n            this.argOfPeriapsis = degToRad(data.argOfPeriapsis);\n            this.ascNodeLongitude = degToRad(data.ascNodeLongitude);\n        } else {\n            this.inclination = data.inclination;\n            this.argOfPeriapsis = data.argOfPeriapsis;\n            this.ascNodeLongitude = data.ascNodeLongitude;\n        }\n\n        if(this.eccentricity < 1){\n            this.periapsis = this.semiMajorAxis * (1 - this.eccentricity);\n            this.apoapsis =  this.semiMajorAxis * (1 + this.eccentricity);\n        }\n        else {\n            this.periapsis = this.semiMajorAxis * (this.eccentricity - 1);\n        }\n\n        if(data.semiLatusRectum) {\n            this.semiLatusRectum = data.semiLatusRectum;\n        } else {\n            this.semiLatusRectum = this.semiMajorAxis * (1 - this.eccentricity * this.eccentricity);\n        }\n\n        if(data.siderealPeriod) {\n            this.siderealPeriod = data.siderealPeriod;\n        } else {\n            this.siderealPeriod = Kepler.siderealPeriod(data.semiMajorAxis, attractor.stdGravParam);\n        }\n\n        if(\"orbiting\" in data) {\n            this.orbiting = data.orbiting;\n        } else {\n            this.orbiting = attractor.id;\n        }\n\n        this.attractorSoi = attractor.soi;\n        this.attractorStdGravParam = attractor.stdGravParam;\n    }\n\n    public get data(): IOrbit {\n        return {\n            orbiting:         this.orbiting,\n            semiMajorAxis:    this.semiMajorAxis,\n            apoapsis:         this.apoapsis,\n            periapsis:        this.periapsis,\n            eccentricity:     this.eccentricity,\n            inclination:      this.inclination,\n            argOfPeriapsis:   this.argOfPeriapsis,\n            ascNodeLongitude: this.ascNodeLongitude,\n            meanAnomalyEpoch: this.meanAnomalyEpoch,\n            epoch:            this.epoch,\n            semiLatusRectum:  this.semiLatusRectum,\n            siderealPeriod:   this.siderealPeriod,\n        };\n    }\n\n    public static fromOrbitalElements(elements: OrbitalElements, attractor: ICelestialBody){\n        const data = Kepler.orbitFromElements(elements, attractor);\n        return new Orbit(data, attractor);\n    }\n}\n\nexport default Orbit","import { OrbitingBody, CelestialBody, isOrbitingBody } from \"./body\";\n\nexport class SolarSystem implements ISolarSystem {\n    readonly sun!:              CelestialBody;\n    readonly orbiters!:         OrbitingBody[];\n    readonly orbiterIds!:       Map<number, OrbitingBody>;\n\n    constructor(sun: ICelestialBody, bodies: IOrbitingBody[], anglesToRad: boolean = false) {\n        this.orbiters = [];\n        this.orbiterIds = new Map();\n        this.sun = new CelestialBody(sun);\n        \n        for(let i=0; i<bodies.length; i++){\n            const bodydata = bodies[i];\n            const attractor = bodydata.orbiting === 0 ? this.sun : (this.orbiterIds!.get(bodydata.orbiting) as OrbitingBody);\n            const body = new OrbitingBody(bodydata, attractor, anglesToRad);\n            \n            this.orbiterIds!.set(body.id, body);\n            attractor.orbiters.push(body);\n            this.orbiters.push(body);\n        }\n    }\n\n    public get orbiting() {\n        return [...this.orbiterIds!.values()];\n    }\n\n    public get bodies(){\n        return [this.sun, ...this.orbiters];\n    }\n\n    public get data() {\n        const data = [];\n        for(const body of this.bodies) {\n            data.push(body.data);\n        }\n        return data;\n    }\n\n    public get size() {\n        return (1 + this.orbiterIds.size)\n    }\n\n    public bodyFromName(name: string) {\n        for(const body of [this.sun, ...this.orbiters]) {\n            if(body.name === name)\n                return body;\n        }\n        throw new Error(`No body with name ${name}`);\n    }\n\n    public bodyFromId(id: number) {\n        if(id === 0) {\n            return this.sun;\n        } else {\n            const body = this.orbiterIds.get(id);\n            if(!body)\n                throw new Error(`No body with id ${id}`);\n            return body;\n        }\n    }\n\n    public sequenceToSun(id: number) {\n        let bd = this.bodyFromId(id);\n        let seq: number[] = [bd.id];\n        while(isOrbitingBody(bd)) {\n            bd = this.bodyFromId(bd.orbiting);\n            seq.push(bd.id);\n        }\n        return seq\n    }\n\n    public commonAttractorId(id1: number, id2: number) {\n        const sunSeq1 = this.sequenceToSun(id1);\n        const sunSeq2 = this.sequenceToSun(id2);\n        for(let i=0; i<sunSeq1.length; i++) {\n            if(sunSeq2.includes(sunSeq1[i])) {\n                return sunSeq1[i]\n            }\n        }\n        throw new Error('Bodies do not share a common attractor (error in defining this SolarSystem)')\n    }\n}\n\nexport default SolarSystem;","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport possibleConstructorReturn from \"./possibleConstructorReturn.js\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import superPropBase from \"./superPropBase.js\";\nexport default function _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get.apply(this, arguments);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import defineProperty from \"./defineProperty.js\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}","import _typeof from \"./typeof.js\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}"],"names":["simpleDepartureArrival","parkOrbit","parkBody","relativeVel","soiDate","ejection","matchParkMo","c","mu","stdGravParam","soi","soiSpeedSq","magSq3","a","etol","relativeVelPlane","Kepler","periapsis","semiMajorAxis","eccentricity","periapsisErr","simpleDepartureArrivalPeriapsisResult","err","min","max","brentRootFind","res","parkNu","e","soiNu","pPos","pVel","deltaT","periapsisDate","siderealPeriod","periapsisState","date","pos","vel","parkState","orbit","maneuver","orbits","intersectTimes","epoch","maneuvers","pSpeedSq","pSpeed","Math","sqrt","p","soiVel","mult3","X_DIR","Y_DIR","rotAngle1","atan2","z","abs","y","roderigues","rotAngle2","x","Z_DIR","optimalDepartureArrival","type","soiPatchPosition","vec3","minNu","TWO_PI","maxNu","Number","EPSILON","ejectionTrueAnomaly","nuFun","directDepartArriveForTrueAnomaly","oberthDepartArriveForTrueAnomaly","nuObjFun","nu","isNaN","Infinity","console","log","Error","deltaV","exp","brentMinimize","trajectoryInfo","fullResult","parkPos","add3","departArriveForPosition","adjustedSoiDate","preState","postState","deltaVMag","mr","mag3","hHat","normalize3","cross3","n","nMag","nHat","div3","i","acosClamped","lan","wrapAngle","copysign","eMax","eMin","clamp","eObjFun","departArriveForEccentricity","id","semiLatusRectum","mNu","T","mM","deltat","mt","meanAnomalyEpoch","orbiting","inclination","ascNodeLongitude","argOfPeriapsis","dot3","parkVel","oberthDepartArriveForPosition","obrPreState","obrPostState","hypPreState","hypPostState","obrEpoch","obrOrbit","hypOrbit","obrManeuver","hypManeuver","parkPosDir","soiVelSq","soiDir","hypEnergy","hypSMA","hDir","delta","counterClockwiseAngleInPlane","objective","hypEcc","hypSLR","hypNu","hypDelta","obrNu","PI","obrEcc","cos","obrSMA","obrEnergy","obrPeriapsisSpeed","hypPeriapsisSpeed","perifocalSoiDir","sin","alignVectorsAngleAxis","rotationAxis","rotationAngle","obrSpeed","perifocalObrDir","obrDir","obrVel","sub3","periapsisPos","hypPeriapsisVel","obrPeriapsisVel","hypDuration","obrDuration","periapsisVelDir","FlybyCalcs","obrDate","patchTrueAnomaly","orb","attractor","patchDate","tMin","undefined","patchPosition","patchVelocity","DepartArrive","minFlybyRadius","body","radius","atmosphereHeight","maxFlybyRadius","orb1","orb2","meanSMA","midPeriod","lb","ub","velIn","velOut","time","inVelSq","outVelSq","inDir","outDir","inEnergy","outEnergy","inSMA","outSMA","inEcc","outEcc","inSLR","outSLR","inNu","outNu","deltaIn","deltaOut","obj","error","periapsisSpeedIn","periapsisSpeedOut","inSemiMajorAxis","inEccentricity","inDirection","outSemiMajorAxis","outEccentricity","outDirection","normalDirection","params","inPerifocalDirection","inPeriapsisSpeed","outPeriapsisSpeed","inPeriapsisVel","outPeriapsisVel","inPeriapsisState","outPeriapsisState","inOrbit","outOrbit","inDate","outDate","agent","inputs","startDate","lerp","startDateMin","startDateMax","flightTimes","j","length","ft","flightTimesMax","flightTimesMin","push","system","startOrbit","endOrbit","flybyIdSequence","planeChange","matchStartMo","matchEndMo","noInsertionBurn","flightPathAngleAtTrueAnomaly","atan","motionAngleAtTrueAnomaly","HALF_PI","motionDirectionAtTrueAnomaly","angle","distanceAtTrueAnomaly","dateToMeanAnomaly","M0","meanAnomalyToDate","M","t","nPeriods","ceil","trueToMeanAnomaly","E","H","atanh","tan","sinh","meanToTrueAnomaly","newtonRootSolve","H0","sign","cosh","tanh","dateToTrueAnomaly","trueAnomalyToDate","angleInPlane","arg","perifocalPos","zxz","positionAtTrueAnomaly","r","velocityAtTrueAnomaly","v","perifocalVel","elements","progradeDir","normalDir","radialDir","prograde","normal","radial","state","v2","h","eVec","eHat","nVec","householderIterations","x0","N","eps","lambda","maxIters","xnew","tof","DT","DDT","DDDT","it","DTs","dTdx","x2tof","DT2","l2","l3","umx2","y2","y3","dist","alfa","acos","beta","asin","acosh","asinh","x2tof2","K","rho","eta","Q","tol","Sj","Cj","Cj1","Sj1","hypergeometricF","g","d","l","f","r1vec","r2vec","it1","it2","revs","retro","left","r1","r2","s","ir1","ir2","ih","lambda2","lambda3","nRevs","T00","T0","T1","Tmin","xOld","xNew","pow","tmp","gamma","sigma","vr1","vr2","vt","vt1","vt2","v1","dTheta","pmin","pmax","k","L","m","pj","pjj","warntol","maxit","pNext","df","dtdp","sinDeltaE","cosDeltaE","deltaE","angularspeed","dF","Lambert","GOLDEN_RATIO","func","errtol","b","fa","fb","temp_a","temp_fa","fc","bisected","fs","itsRemaining","currentStep","previousStep","secondStep","GRsq","w","fv","fw","fx","u","fu","q","prevX","sortNMpoints","p1","p2","objx","nelderMeadMinimize","initialPoints","maxIt","alpha","simplex","centroid","slice","reflect","contract","expand","sort","objReflect","objExpand","objContract","bodyFromId","sun","orbiterIds","get","transferBody","flightTime","endDate","startPatchPosition","endPatchPosition","startState","endState","startPos","endPos","planeEndPos","transferOrbit1","startNu","endNu","planeChangeNu","planeChangeDate","planeChangePreState","n1vec","n2vec","newVel","planeChangePostState","transferOrbit2","departState","arriveState","arriveNu","departManeuver","arriveManeuver","planeManeuver","trajectory","transferOrbit","ejectionSequence","transferStartDate","nextOrbit","previousOrbit","nextOrbitVel","currentBodyVel","soiPatchPositions","map","ejectionInfos","escapeDate","nEjections","currentBody","nextBody","previousBody","nextEjection","matchOrb","currentEjection","currentPatch","patchedEjOrb","previousOrbitNu","ejEpoch","ejPreVel","ejPreState","ejPostState","reverse","insertionSequence","transferEndDate","previousOrbitVel","insertionInfos","encounterDate","nInsertions","previousInsertion","prevInLen","prevManLen","currentInsertion","manLen","patchedInOrb","nextOrbitNu","inEpoch","inPreVel","inPostState","inPreState","Trajectories","CelestialBody","data","name","mass","color","orbiters","this","Color","orbIds","maxDist","orbDist","OrbitingBody","anglesToRad","Orbit","isOrbitingBody","scale","concat","toString","apoapsis","attractorSoi","attractorStdGravParam","degToRad","SolarSystem","bodies","Map","bodydata","set","values","size","bd","seq","id1","id2","sunSeq1","sequenceToSun","sunSeq2","includes","_arrayLikeToArray","arr","len","arr2","Array","_assertThisInitialized","self","ReferenceError","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_createForOfIteratorHelper","o","allowArrayLike","Symbol","iterator","isArray","F","done","value","_e","normalCompletion","didErr","call","step","next","_e2","_createSuper","Derived","hasNativeReflectConstruct","result","Super","NewTarget","constructor","Reflect","construct","arguments","apply","_defineProperty","_get","property","receiver","base","desc","getOwnPropertyDescriptor","_getPrototypeOf","setPrototypeOf","getPrototypeOf","__proto__","_inherits","subClass","superClass","create","_isNativeReflectConstruct","sham","Proxy","Boolean","valueOf","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","_objectSpread2","source","forEach","getOwnPropertyDescriptors","defineProperties","_possibleConstructorReturn","_setPrototypeOf","_superPropBase","hasOwnProperty","_toConsumableArray","arrayLikeToArray","iter","from","unsupportedIterableToArray","_typeof","_unsupportedIterableToArray","minLen","test"],"sourceRoot":""}