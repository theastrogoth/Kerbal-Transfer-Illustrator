{"version":3,"file":"static/js/325.1414d37b.chunk.js","mappings":"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","sources":["main/libs/lambert.ts","main/libs/optim.ts","main/libs/trajectories.ts","main/objects/body.ts","main/objects/color.ts","main/objects/orbit.ts","main/objects/system.ts","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/createClass.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/createSuper.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/get.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/inherits.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/superPropBase.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/typeof.js"],"sourcesContent":["// Includes a direct port to TypeScript of ESA's Lambert problem solver\n// from : https://github.com/esa/pykep/blob/master/src/lambert_problem.cpp\n// extended from original port by krafpy to cover multiple revolutions\n// from : \n\n/*****************************************************************************\n *   Copyright (C) 2004-2018 The pykep development team,                     *\n *   Advanced Concepts Team (ACT), European Space Agency (ESA)               *\n *                                                                           *\n *   https://gitter.im/esa/pykep                                             *\n *   https://github.com/esa/pykep                                            *\n *                                                                           *\n *   act@esa.int                                                             *\n *                                                                           *\n *   This program is free software; you can redistribute it and/or modify    *\n *   it under the terms of the GNU General Public License as published by    *\n *   the Free Software Foundation; either version 2 of the License, or       *\n *   (at your option) any later version.                                     *\n *                                                                           *\n *   This program is distributed in the hope that it will be useful,         *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *   GNU General Public License for more details.                            *\n *                                                                           *\n *   You should have received a copy of the GNU General Public License       *\n *   along with this program; if not, write to the                           *\n *   Free Software Foundation, Inc.,                                         *\n *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.               *\n *****************************************************************************/\n\nimport { TWO_PI, mag3, normalize3, add3, sub3, div3, mult3, cross3, dot3, wrapAngle} from \"./math\"\n\nnamespace Lambert\n{\n    /**\n     * Solves the Lambert's problem considering 0 revolutions and prograde direction only.\n     * @param r1vec The start position in space\n     * @param r2vec The end position in space\n     * @param tof The time of flight between the two positions\n     * @param attractor The attractor body\n     * @param retro Designates the orbit as retrograde if true.\n     * @param left Uses the left branch for the multiple revolutions problem if true\n     * @returns The velocities at each point\n     */\n    export function solve(r1vec: Vector3, r2vec: Vector3, tof: number, attractor: ICelestialBody, revs: number = 0, retro: boolean = false, left: boolean = false) {\n        const mu = attractor.stdGravParam;\n\n        // Calculating lambda and T\n        const r1 = mag3(r1vec);\n        const r2 = mag3(r2vec);\n        const c = mag3(sub3(r2vec, r1vec));\n\n        const s = 0.5 * (r1 + r2 + c);\n\n        const ir1 = div3(r1vec, r1);\n        const ir2 = div3(r2vec, r2);\n\n        const ih = normalize3(cross3(ir1, ir2));\n\n        const lambda2 = 1 - c / s;\n        let lambda = Math.sqrt(lambda2);\n         let it1: Vector3, it2: Vector3;\n\n        if(ih.z < 0) { // transfer angle is larger than 180° (viewed from upper y axis)\n            lambda = -lambda;\n            it1 = cross3(ir1, ih);\n            it2 = cross3(ir2, ih);\n        } else {\n            it1 = cross3(ih, ir1);\n            it2 = cross3(ih, ir2);\n        }\n        it1 = normalize3(it1);\n        it2 = normalize3(it2);\n\n        if(retro) {\n            lambda = -lambda;\n            it1 = mult3(it1, -1);\n            it2 = mult3(it2, -1);\n        }\n\n        const lambda3 = lambda * lambda2;\n        const T = Math.sqrt(2 * mu / (s*s*s)) * tof;\n \n        // Detect maximum number of revolutions for which there exists a solution\n        let nRevs = T / Math.PI;\n        const T00 = Math.acos(lambda) + lambda * Math.sqrt(1.0 - lambda2);\n        const T0 = (T00 + nRevs * Math.PI);\n        const T1 = 2 / 3 * (1 - lambda3);\n        let DT = 0.0, DDT = 0.0, DDDT = 0.0;\n        let DTs = {DT, DDT, DDDT};\n        if(nRevs > 0) {\n            if(T > T0) { // Use Halley iterations\n                let it = 0;\n                let err = 1.0;\n                let Tmin = T0;\n                let xOld = 0.0, xNew = 0.0;\n                while(1) {\n                    DTs = dTdx(DT, DDT, DDDT, xOld, Tmin, lambda);\n                    DT = DTs.DT;\n                    DDT = DTs.DDT;\n                    DDDT = DTs.DDDT;\n                    if(DT !== 0) {\n                        xNew = xOld - DT * DDT / (DDT * DDT - DT * DDDT / 2.0);\n                    }\n                    err = Math.abs(xOld - xNew);\n                    if ((err < 1e-13) || (it > 12)) {\n                        break;\n                    }\n                    Tmin = x2tof(Tmin, xNew, nRevs);\n                    xOld = xNew;\n                    it++;\n                }\n                if(Tmin > T) {\n                    nRevs -= 1;\n                }\n            }\n        }\n\n        // Crop maximum revolutions to the input value, revs\n        nRevs = revs < nRevs ? revs : nRevs;\n\n        //  // Initialize arrays to store output\n        //  const solslen = 2 * nRevs + 1;\n        //  const x: number[] = new Array<number>(solslen);\n        //  const v1: Vector3[] = new Array<Vector3>(solslen);\n        //  const v2: Vector3[] = new Array<Vector3>(solslen);\n        \n        let x: number;\n\n        // Single revolution case\n        if(nRevs === 0) {\n            // Initial guess\n            let x0: number;\n            if(T >= T00) {\n                x0 = -(T - T00) / (T - T00 + 4);\n            } else if(T <= T1) {\n                x0 = T1 * (T1 - T) / (2 / 5 * (1 - lambda2 * lambda3) * T) + 1;\n            } else {\n                x0 = Math.pow(T / T00, 0.69314718055994529 / Math.log(T1 / T00)) - 1;\n            } \n            // Householder iterations for 0 rev case\n            x = householderIterations(T, x0, 0, 1e-15, lambda, 15);\n\n        // Multi-rev case\n        } else {\n            let tmp = 0.0;\n            if(left) {  // left Household iterations\n                tmp = Math.pow((nRevs * Math.PI + Math.PI) / (8 * T), 2 / 3);\n            } else {    // right Householder iterations \n                tmp = Math.pow((8 * T) / (nRevs * Math.PI), 2 / 3);\n            }\n            x = (tmp - 1) / (tmp + 1);\n            x = householderIterations(T, x, nRevs, 1e-8, lambda, 15);\n        }\n\n        // Reconstruct the terminal velocities from x\n        const gamma = Math.sqrt(mu * s / 2.0);\n        const rho = (r1 - r2) / c;\n        const sigma = Math.sqrt(1 - rho * rho);\n        const y = Math.sqrt(1.0 - lambda2 + lambda2 * x * x);\n        const vr1 = gamma * ((lambda * y - x) - rho * (lambda * y + x)) / r1;\n        const vr2 = -gamma * ((lambda * y - x) + rho * (lambda * y + x)) / r2;\n        const vt = gamma * sigma * (y + lambda * x);\n        const vt1 = vt / r1;\n        const vt2 = vt / r2;\n\n        const v1 = add3(mult3(ir1, vr1), mult3(it1, vt1));\n        const v2 = add3(mult3(ir2, vr2), mult3(it2, vt2));\n        return {v1, v2};\n    }\n \n    function householderIterations(T: number, x0: number, N: number, eps: number, lambda: number, maxIters: number) {\n        let xnew = 0;\n        let tof = 0;\n        let delta = 0;\n        let DT = 0, DDT = 0, DDDT = 0;\n        \n        for(let it = 0; it < maxIters; it++) {\n            tof = x2tof(x0, lambda, N);\n            const DTs = dTdx(DT, DDT, DDDT, x0, tof, lambda);\n            DT = DTs.DT;\n            DDT = DTs.DDT;\n            DDDT = DTs.DDDT;\n\n            delta = tof - T;\n            const DT2 = DT * DT;\n            xnew = x0 - delta * (DT2 - delta * DDT / 2) / (DT * (DT2 - delta * DDT) + DDDT * delta * delta / 6);\n            x0 = xnew;\n            if(Math.abs(x0 - xnew) < eps) {\n                break\n            }\n        }\n \n        return x0;\n    }\n \n    function dTdx(DT: number, DDT: number, DDDT: number, x: number, T: number, lambda: number) {\n        const l2 = lambda * lambda;\n        const  l3 = l2 * lambda;\n        const  umx2 = 1.0 - x * x;\n        const  y = Math.sqrt(1.0 - l2 * umx2);\n        const y2 = y * y;\n        const y3 = y2 * y;\n        DT = 1.0 / umx2 * (3.0 * T * x - 2.0 + 2.0 * l3 * x / y);\n        DDT = 1.0 / umx2 * (3.0 * T + 5.0 * x * DT + 2.0 * (1.0 - l2) * l3 / y3);\n        DDDT = 1.0 / umx2 * (7.0 * x * DDT + 8.0 * DT - 6.0 * (1.0 - l2) * l2 * l3 * x / y3 / y2);\n        return {DT, DDT, DDDT};\n    }\n \n    function x2tof2(x: number, lambda: number, N: number)\n    {\n        const a = 1.0 / (1.0 - x * x);\n        if (a > 0) // ellipse\n        {\n            let alfa = 2.0 * Math.acos(x);\n            let beta = 2.0 * Math.asin(Math.sqrt(lambda * lambda / a));\n            if (lambda < 0.0) beta = -beta;\n            return ((a * Math.sqrt(a) * ((alfa - Math.sin(alfa)) - (beta - Math.sin(beta) * TWO_PI * N))) / 2.0);\n        } else {\n            let alfa = 2.0 * Math.acosh(x);\n            let beta = 2.0 * Math.asinh(Math.sqrt(-lambda * lambda / a));\n            if (lambda < 0.0) beta = -beta;\n            return (-a * Math.sqrt(-a) * ((beta - Math.sinh(beta)) - (alfa - Math.sinh(alfa))) / 2.0);\n        }\n    }\n \n    function x2tof(x: number, lambda: number, N: number)\n    {\n        const battin = 0.01;\n        const lagrange = 0.2;\n        const dist = Math.abs(x - 1);\n        if (dist < lagrange && dist > battin) { // We use Lagrange tof expression\n            return x2tof2(x, lambda, N);\n        }\n        const K = lambda * lambda;\n        const E = x * x - 1.0;\n        const rho = Math.abs(E);\n        const z = Math.sqrt(1 + K * E);\n        if (dist < battin) { // We use Battin series tof expression\n            const eta = z - lambda * x;\n            const S1 = 0.5 * (1.0 - lambda - x * eta);\n            let Q = hypergeometricF(S1, 1e-11);\n            Q = 4.0 / 3.0 * Q;\n            return (eta * eta * eta * Q + 4.0 * lambda * eta) / 2.0 + Math.PI * N / (rho**1.5);\n        } else { // We use Lancaster tof expresion\n            const y = Math.sqrt(rho);\n            const g = x * z - lambda * E;\n            let d = 0.0;\n            if (E < 0) {\n                const l = Math.acos(g);\n                d = Math.PI * N + l;\n            } else {\n                const f = y * (z - lambda * x);\n                d = Math.log(f + g);\n            }\n            return (x - lambda * z - d / y) / E;\n        }\n    }\n \n    function hypergeometricF(z: number, tol: number)\n    {\n        let Sj = 1.0;\n        let Cj = 1.0;\n        let err = 1.0;\n        let Cj1 = 0.0;\n        let Sj1 = 0.0;\n        let j = 0;\n        while (err > tol) {\n            Cj1 = Cj * (3.0 + j) * (1.0 + j) / (2.5 + j) * z / (j + 1);\n            Sj1 = Sj + Cj1;\n            err = Math.abs(Cj1);\n            Sj = Sj1;\n            Cj = Cj1;\n            j++;\n        }\n        return Sj;\n    }\n \n    // p-iteration\n    export function psolve(r1vec: Vector3, r2vec: Vector3, tof: number, attractor: ICelestialBody, revs: number = 0, retro: boolean = false) {\n        const mu = attractor.stdGravParam;\n\n        const r1 = mag3(r1vec);\n        const r2 = mag3(r2vec);\n\n        let dTheta = Math.atan2(mag3(cross3(r1vec, r2vec)), dot3(r1vec, r2vec))\n        dTheta = retro ? -dTheta : dTheta;\n        const ih = normalize3(cross3(r1vec, r2vec));\n        if (ih.z < 0) { // transfer angle is larger than 180° (viewed from upper y axis)\n            dTheta = TWO_PI - dTheta;\n        }\n\n        // p-iteration constants\n        const k = r1 * r2 * (1 - Math.cos(dTheta));\n        const L = r1 + r2;\n        const m = r1 * r2 * (1 + Math.cos(dTheta));\n\n        // bounds\n        const pj  = k / (L + Math.sqrt(2 * m));\n        const pjj = k / (L - Math.sqrt(2 * m));\n        let pmin: number;\n        let pmax: number;\n        if (dTheta > Math.PI) {\n            pmin = 0.0;\n            pmax = pjj;\n        } else {\n            pmin = pj;\n            pmax = Infinity;\n        }\n\n        // Newton p-iteration\n        const tol = 1e-12;\n        const warntol = tol*1000;\n        const maxit = 200;\n        let it = 0;\n        let err = tol + 1;\n        let p = (pj + pjj) / 2;\n        let pNext = p;\n        let a = 0.0;\n        let f = 0.0;\n        let g = 0.0;\n        let df = 0.0;\n        while (err > tol && it < maxit) {\n            it++;\n            p = pNext;\n            a = m * k * p / ((2*m - L * L) * (p * p) + 2 * k * L * p - k * k);\n            a = a === 0 ? 1e-100 : a;    // Guarantee that parabolic case does not occur\n            f = 1 - r2 / p * (1 - Math.cos(dTheta));\n            g = r1 * r2 * Math.sin(dTheta) / Math.sqrt(mu * p);\n\n            let t: number;\n            let dtdp: number;\n            df = Math.sqrt(mu / p) * Math.tan(dTheta / 2) * ((1 - Math.cos(dTheta)) / p - 1 / r1 - 1 / r2);\n            if (a>0) { // elliptical case\n                const sinDeltaE = -r1 * r2 * df / Math.sqrt(mu * a);\n                const cosDeltaE = 1 - r1 / a * (1 - f);\n                const deltaE = wrapAngle(Math.atan2(sinDeltaE, cosDeltaE));\n                const angularspeed = Math.sqrt(a * a * a / mu);\n                t = g + angularspeed * (deltaE - sinDeltaE);\n                dtdp = -g / 2 / p - 1.5 * a * (t - g) * (k * k + (2 * m - L * L) * p * p) / (m * k * p * p) + angularspeed * (2 * k * sinDeltaE) / (p * (k - L * p));\n            } else { // hyperbolic case\n                const dF = Math.acosh(1 - r1 / a * (1 - f));\n                const angularspeed = Math.sqrt(-a * a * a / mu);\n                t = g + angularspeed * (Math.sinh(dF) - dF);\n                dtdp = -g / 2 / p - 1.5 * a * (t - g) * (k * k + (2 * m - L * L) * p * p) / (m * k * p * p) - angularspeed * (2 * k * Math.sinh(dF)) / (p * (k - L * p));\n            }\n            err = Math.abs(tof - t) / tof;\n            pNext = p + (tof - t) / dtdp;\n\n            // if the next guess is outside the allowed bounds, use bisection\n            if (pNext < pmin) {\n                pNext = (p + pmin) / 2;\n            } else if (pNext > pmax) {\n                pNext = (p + pmax) / 2;\n            }\n        }\n\n        if (err > warntol) {\n            console.log('Lambert p-iteration failed to converge. error: %f', err);\n        }\n\n        const v1 = div3(sub3(r2vec, mult3(r1vec,f)), g);\n        const v2 = add3(mult3(r1vec, df), mult3(v1, g));\n        return {v1, v2}\n    }\n\n }\n \n export default Lambert","const GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;\n\n// https://en.wikipedia.org/wiki/Golden-section_search\nexport function goldenSectionSearch(func: Function, min: number, max: number, tol: number = 1e-5) {\n    const GR = GOLDEN_RATIO - 1;\n    const GRsq = 2 - GOLDEN_RATIO;\n    let a = min, b = max;\n    let h = b - a;\n    if(h < tol) {\n        return (b + a) / 2;\n    }\n    let c = a + GRsq * h;\n    let d = a + GR * h;\n    let fc = func(c);\n    let fd = func(d);\n\n    while(h > tol) {\n        if(fc < fd) {\n            b = d;\n            d = c;\n            fd = fc;\n            h = GR * h;\n            c = a + GRsq * h;\n            fc = func(c);\n        } else {\n            a = c;\n            c = d;\n            fc = fd;\n            h = GR * h;\n            d = a + GR * h;\n            fd = func(d);\n        }\n    }\n\n    if(fc < fd) {\n        return (a + d) / 2;\n    } else {\n        return (c + b) / 2;\n    }\n}\n\n// https://en.wikipedia.org/wiki/Brent%27s_method\nexport function brentRootFind(func: Function, min: number, max: number, tol: number = 1e-12, maxIters: number = 100, warntol: number = 1.0) {\n    const errtol = 2*Number.EPSILON;\n\n    let a = min, b = max;\n    let fa = func(a);\n    let fb = func(b);\n\n    // Make sure the bounds bracket a root\n    if(Math.sign(fa) === Math.sign(fb)) {\n        throw new Error(\"The provided bounds do not bracket a root.\")\n    }\n\n    // Swap a and b to ensure that func(b) is closer to 0 than func(a) \n    if(Math.abs(fa) < Math.abs(fb)) {\n        const temp_a = a;\n        a = b;\n        b = temp_a;\n\n        const temp_fa = fa;\n        fa = fb;\n        fb = temp_fa;\n    }\n\n    let c = a;\n    let fc = fa;\n\n    let d = c;\n    let bisected = true;\n\n    let s = 0.0;\n    let fs = 1.0;\n\n    let itsRemaining = maxIters;\n    while (itsRemaining) {\n        itsRemaining--;\n\n        if(Math.abs(b - a) < tol) {\n            return b\n        }\n        if(Math.abs(fb) < errtol) {\n            return b\n        }\n\n        s = 0.0;\n\n        // Inverse quadratice interpolation\n        if((Math.abs(fa - fc) > errtol) && (Math.abs(fb - fc) > errtol)) {\n            s = ((a * fb * fc) / ((fa - fb) * (fa - fc))) + \n                ((b * fa * fc) / ((fb - fa) * (fb - fc))) +\n                ((c * fa * fb) / ((fc - fa) * (fc - fb)));\n        // Otherwise, use the secant method\n        } else {\n            s = b - (fc * ((b - a) / (fb - fa)))\n        }\n        const delta = Math.abs(errtol * b);\n        const currentStep = Math.abs(s - b);\n        const previousStep = Math.abs(b - c);\n        const secondStep = Math.abs(c - d);\n\n        // bisection conditions\n        if(\n            // s is not between (((3 * a) + b) / 4)) and b\n            ((s - (((3 * a) + b) / 4)) * (s - b) >= 0) ||\n            // the interpolation step is very small\n            (bisected && (currentStep >= previousStep / 2)) ||\n            (!bisected && (currentStep >= secondStep / 2)) ||\n            // the prvious steps were close to b\n            (bisected && previousStep < delta) ||\n            (!bisected && secondStep < delta)\n        ) {\n            s = (a + b) / 2;\n            bisected = true;\n        } else {\n            bisected = false;\n        }\n\n        // return s if func(s) is sufficiently close to 0\n        fs = func(s);\n        if(Math.abs(fs) < errtol) {\n            return s;\n        }\n\n        // reset positions and bracket\n        d = c;\n        c = b;\n\n        if(Math.sign(fa) !== Math.sign(fs)) {\n            b = s;\n            fb = fs;\n        } else {\n            a = s;\n            fa = fs;\n        }\n\n        // Swap a and b to ensure that func(b) is closer to 0 than func(a) \n        if(Math.abs(fa) < Math.abs(fb)) {\n            const temp_a = a;\n            a = b;\n            b = temp_a;\n\n            const temp_fa = fa;\n            fa = fb;\n            fb = temp_fa;\n        }\n    }\n\n    // no root found, print warning message\n    // if (Math.abs(fs) > warntol) {\n    //     console.log(\"Brent's method failed to find a root. Function value of %f at %f\", fs, s)\n    // }\n    return s;\n}\n\n// https://courses.seas.harvard.edu/courses/am205/g_act/am205_workshop_optimization.pdf\nexport function brentMinimize(func: Function, min: number, max: number, tol: number = 1e-8, maxIters: number = 50) {\n    // const GR = GOLDEN_RATIO - 1;\n    const GRsq = 2 - GOLDEN_RATIO;\n    const etol = tol; // 1e-3;\n    \n    let a = min, b = max;\n    let h = (b - a);\n    let x = a + GRsq * h;\n    let w = x;\n    let v = w;\n\n    let fv = func(v);\n    let fw = func(w);\n    let fx = func(x);\n\n    let u = 0.0;\n    let fu = 0.0;\n\n    let m = (a + b) / 2\n\n    let p = 0.0;\n    let q = 0.0;\n    let delta = 0.0;\n    let d = 0.0;\n    let e = 0.0;\n\n    let itsRemaining = maxIters;\n\n    while(itsRemaining) {\n        itsRemaining--;\n\n        if (h < tol) {\n            return m;\n        }\n\n        p = (w - x) * (w - x) * (fx - fv) + (v - x) * (v - x) * (fw - fx);\n        q = (w - x) * (fx -fv) + (v - x) * (fw - fx);\n\n        delta = 0.5 * p / q;\n\n        // If SPI is not well behaved, perform a Golden Section search\n        if(\n            // q is zero\n            (q === 0) ||\n            // u is not in between a and b\n            (a > u || u > b) ||\n            // p/q is not shrinking fast enough\n            (Math.abs(p/q) > 0.5 * Math.abs(e))  ||\n            // e is too small\n            (Math.abs(e) < etol) \n        ) {\n            e = (x < m) ? b-x : a-x;\n            d = GRsq * e;\n        // Otherwise, carry on with SPI\n        } else {\n            e = d;\n            d = delta;\n        }\n\n        u = x + d;\n\n        // newest function evaluation\n        fu = func(u);\n\n        // update bracket and previous guesses\n        // u is the best guess so far\n        if(fu <= fx) {\n            a = (u < x) ? a : x;\n            b = (u < x) ? x : b;\n            v = w;\n            w = x;\n            x = u;\n            fv = fw;\n            fw = fx;\n            fx = fu;\n        // fu is worse than fx\n        } else {\n            a = (u < x) ? u : a;\n            b = (u < x) ? b : u;\n            // fu is the second-best guess\n            if((fu <= fw) || (w === x)) {\n                v = w;\n                w = u;\n                fv = fw;\n                fw = fu;\n            // fu is the third-best guess\n            } else if((fu <= fv) || (v === x) || (v === w)) {\n                v = u;\n                fv = fu;\n            // fu is the worst guess\n            } else {\n                // Don't keep u, only the bracket is updated\n            }\n        }\n\n        // update interval size and midpoint\n        h = b - a;\n        m = (a + b) / 2;\n    }\n    // if(h > tol) {\n    //     console.log(\"Brent's minimization method failed to converge. Interval size: \", h)\n    // }\n    return m\n}\n\nexport function newtonRootSolve(\n    f: (x: number) => number,\n    df: (x: number) => number,\n    x0: number,\n    eps: number,\n    maxIters: number = 1000\n){\n    let n = 0;\n    let prevX: number;\n    let x = x0;\n    let err = eps + 1;\n    let errp = err + 1;\n    while(err > eps && n < maxIters){\n        prevX = x;\n        x -= f(x) / df(x);\n        errp = err;\n        err = Math.abs(x - prevX);\n        if(errp < err) {            // Modification to Newton's method, using bisection in case the error gets worse with an iteration\n            x = (x + prevX) / 2;    // This helps in case of poor initializations that lead to large overshoot, where the algorithm would not otherwise converge\n        }\n        n++;\n    }\n    if (n >= maxIters) {\n        console.log(\"Newton's method failed to find a root. Error of %f. \", err)\n    }\n    return x;\n}\n\ninterface NMpoint\n{\n    x:       number[],\n    objx:    number,\n}\n\nfunction sortNMpoints(p1: NMpoint, p2: NMpoint) : number {\n    return p1.objx - p2.objx;\n}\n\n\n// https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method#One_possible_variation_of_the_NM_algorithm\nexport function nelderMeadMinimize(\n    initialPoints:  number[][],\n    objective:      (x: number[]) => number,\n    tol:            number = 1.0,   // Non-standard approach to termination, since my objective functions have an assumed minimum (0.0)\n    maxIt:          number = initialPoints[0].length * 250,\n    alpha:          number = 1.0,\n    gamma:          number = 2.0,\n    rho:            number = 0.5,\n    sigma:          number = 0.5,\n    \n): number[] {\n\n    const n: number = initialPoints[0].length;\n    const simplex: NMpoint[]    = [];\n    const centroid: number[]    = initialPoints[0].slice()\n    const reflect: number[]     = centroid.slice();\n    const contract: number[]    = centroid.slice();\n    const expand: number[]      = centroid.slice();\n\n    // create simplex from initial points\n    for(let i = 0; i <= n; i++) {\n        simplex.push({x: initialPoints[i], objx: objective(initialPoints[i])})\n    }\n\n    // iterate until termination\n    let err = tol + 1;\n    for(let it = 0; it < maxIt; it++) {\n        // sort the simplex by objective function value\n        simplex.sort(sortNMpoints);\n        err = simplex[0].objx;\n        if(err < tol) {\n            break\n        }\n\n        // TODO: add convergence test for general case\n\n        // calculate the centroid of the simplex\n        for(let i = 0; i <= n; i++) {\n            centroid[i] = 0.0;\n            for(let j = 0; j < n; j++) {\n                centroid[i] = centroid[i] + simplex[j].x[i];\n            }\n            centroid[i] = centroid[i] / n;\n        }\n\n        // reflect worst point across the centroid\n        for(let i = 0; i < n; i++) {\n            reflect[i] = centroid[i] + alpha * (centroid[i] - simplex[n].x[i]);\n        }\n        const objReflect = objective(reflect);\n\n        // if the point is better than second worse, but not the best,\n        // replace the worst point with the reflected point and iterate\n            if(objReflect < simplex[n - 1].objx && objReflect >= simplex[0].objx) {\n                simplex[n].x = reflect.slice();\n                simplex[n].objx = objReflect;\n                continue\n            }\n\n        // if the relfected point is the best so far, expand the reflected point\n        if(objReflect < simplex[0].objx) {\n            for(let i = 0; i < n; i++) {\n                expand[i] = centroid[i] + gamma * (reflect[i] - centroid[i]);\n            }\n            const objExpand = objective(expand);\n\n            // use the better of the expanded and reflected points to replace the worst point\n            // then, iterate\n            if(objExpand < objReflect) {\n                simplex[n].x = expand.slice();\n                simplex[n].objx = objExpand;\n            } else {\n                simplex[n].x = reflect.slice();\n                simplex[n].objx = objReflect;\n            }\n            continue\n        }\n\n        // Here, the reflected point is at least as bad as the second worst point\n        // If it is the worst point, compute the contracted point on the inside\n        if(objReflect > simplex[n].objx) {\n            for(let i = 0; i < n; i++) {\n                contract[i] = centroid[i] + rho * (simplex[n].x[i] - centroid[i]);\n            }        \n            const objContract = objective(contract);\n            // replace worst point if this one is any better, then iterate\n            if(objContract < simplex[n].objx) {\n                simplex[n].x = contract.slice();\n                simplex[n].objx = objContract;\n                continue\n            }\n        // otherwise, compute the contracted point on the outside\n        } else {\n            for(let i = 0; i < n; i++) {\n                contract[i] = centroid[i] + rho * (reflect[i] - centroid[i]);\n            }    \n            const objContract = objective(contract);\n            // replace worst point if this one is an improvement on the reflection, then iterate\n            if(objContract < objReflect) {\n                simplex[n].x = contract.slice();\n                simplex[n].objx = objContract;\n                continue\n            }\n        }\n\n        // At this step, all points will be shrunk toward the best point\n        for(let i = 1; i <= n; i++) {\n            for(let j = 1; j < n; j++) {\n                simplex[i].x[j] = simplex[0].x[j] + sigma * (simplex[i].x[j] - simplex[0].x[j]);\n            }\n            simplex[i].objx = objective(simplex[i].x);\n        }\n    }\n    return simplex[0].x\n}\n\n","import Kepler from './kepler';\nimport Lambert from './lambert';\nimport DepartArrive from './departarrive';\nimport { vec3, add3, sub3, mag3, normalize3, cross3, dot3, roderigues, wrapAngle, acosClamped, HALF_PI, Z_DIR, magSq3 } from './math';\nimport FlybyCalcs from './flybycalcs';\n\nnamespace Trajectories {\n    export function transferTrajectory(startOrbit: IOrbit, endOrbit: IOrbit, transferBody: ICelestialBody, startDate: number, flightTime: number, endDate: number, \n                                       planeChange: boolean, startPatchPosition: Vector3 = vec3(0,0,0), endPatchPosition: Vector3 = vec3(0,0,0)): Trajectory {\n        \n        const startState = Kepler.orbitToStateAtDate(startOrbit, transferBody, startDate);\n        const endState   = Kepler.orbitToStateAtDate(endOrbit,   transferBody, endDate); \n        const startPos = add3(startState.pos, startPatchPosition);\n        const endPos   = add3(endState.pos,   endPatchPosition);\n\n        if(planeChange) { // for plane-change-style transfer...\n            // project the end position to the perifocal plane of the pre-transfer orbit, and compute a transfer\n            let planeEndPos = Kepler.rotateToPerifocalFromInertial(endPos, startOrbit);\n            planeEndPos = Kepler.rotateToInertialFromPerifocal(vec3(planeEndPos.x, planeEndPos.y, 0.0), startOrbit);\n\n            const {v1} = Lambert.solve(startPos, planeEndPos, flightTime, transferBody);\n            const transferOrbit1 = Kepler.stateToOrbit(\n                {\n                    date: startDate,\n                    pos:  startPos,\n                    vel:  v1\n                },\n                transferBody\n            );\n            \n            // identify the true anomaly and date at the plane change (use PI/2 prior to target encounter)\n            const startNu = Kepler.angleInOrbitPlane(startPos, transferOrbit1);\n            // let startNu = Kepler.dateToOrbitTrueAnomaly(startDate, transferOrbit1);\n            // if(isNaN(startNu)) {    // in case Newton root solving fails for the inverse Kepler equation (near parabolic orbits?)\n            //     startNu = Kepler.angleInOrbitPlane(startPos, transferOrbit1);\n            // }\n            const endNu = Kepler.angleInOrbitPlane(planeEndPos, transferOrbit1);\n            // let endNu = Kepler.dateToOrbitTrueAnomaly(endDate, transferOrbit1);\n            // if(isNaN(endNu)) {      // in case Newton root solving fails for the inverse Kepler equation (near parabolic orbits?)\n            //     endNu = Kepler.angleInOrbitPlane(planeEndPos, transferOrbit1);\n            // }\n            const planeChangeNu = startNu + Math.max(0.0, (wrapAngle(endNu - startNu) - HALF_PI));\n            const planeChangeDate = Kepler.trueAnomalyToOrbitDate(planeChangeNu, transferOrbit1, startDate);\n\n            // rotate the velocity vector at the plane change location to hit the target at encounter\n            const planeChangePreState = {\n                date: planeChangeDate,\n                pos:  Kepler.positionAtTrueAnomaly(transferOrbit1, planeChangeNu),\n                vel:  Kepler.velocityAtTrueAnomaly(transferOrbit1, transferBody.stdGravParam, planeChangeNu),\n            };\n            const n1vec = normalize3(cross3(planeChangePreState.pos, planeChangePreState.vel));\n            const n2vec = normalize3(cross3(planeChangePreState.pos, endPos));\n            const rotationAngle = acosClamped(dot3(n1vec, n2vec));\n            let rotationAxis = rotationAngle === 0 ? Z_DIR : normalize3(cross3(n1vec, n2vec));\n            rotationAxis = isNaN(rotationAxis.x) ? Z_DIR : rotationAxis;\n            const newVel = roderigues(planeChangePreState.vel, rotationAxis, rotationAngle);\n\n            // compute the transfer orbit from the plane change position and post-maneuver velocity;\n            const planeChangePostState = {\n                date: planeChangeDate, \n                pos: planeChangePreState.pos, \n                vel: newVel,\n            };\n            const transferOrbit2 = Kepler.stateToOrbit(planeChangePostState,transferBody);\n\n            // prepare maneuvers at beginning and end of transfer\n            const departState: OrbitalState = {\n                date: startDate,\n                pos:  startPos,\n                vel:  v1,\n            }\n            let arriveState = Kepler.orbitToStateAtDate(transferOrbit2, transferBody, endDate);\n            if(isNaN(arriveState.pos.x)) {  // in case Newton root solving fails for the inverse Kepler equation (near parabolic orbits?)\n                const arriveNu = Kepler.angleInOrbitPlane(endPos, transferOrbit2);\n                arriveState = {\n                    date: endDate,\n                    pos:  endPos,\n                    vel:  Kepler.velocityAtTrueAnomaly(transferOrbit2, transferBody.stdGravParam, arriveNu),\n                };\n            }\n\n            const departManeuver = Kepler.maneuverFromOrbitalStates(startState, departState);\n            const arriveManeuver = Kepler.maneuverFromOrbitalStates(arriveState, endState);\n            const planeManeuver  = Kepler.maneuverFromOrbitalStates(planeChangePreState, planeChangePostState)\n\n            const trajectory = {orbits:         [transferOrbit1, transferOrbit2],\n                                intersectTimes: [startDate, planeChangeDate, endDate],\n                                maneuvers:      [departManeuver, planeManeuver, arriveManeuver]};\n                   \n            return trajectory;    \n        } else {\n            const {v1, v2} = Lambert.solve(startPos, endPos, flightTime, transferBody)\n\n            // prepare maneuvers at beginning and end of transfer\n            const departState: OrbitalState = {\n                date: startDate,\n                pos:  startPos,\n                vel:  v1,\n            }\n            const arriveState: OrbitalState = {\n                date: endDate,\n                pos:  endPos,\n                vel:  v2,\n            }\n\n            const departManeuver = Kepler.maneuverFromOrbitalStates(startState, departState);\n            const arriveManeuver = Kepler.maneuverFromOrbitalStates(arriveState, endState);\n\n            const trajectory = {orbits:         [Kepler.stateToOrbit({ date: startDate, pos: startPos, vel: v1}, transferBody)],\n                                intersectTimes: [startDate, endDate],\n                                maneuvers:      [departManeuver, arriveManeuver]};\n            return trajectory;\n        }\n    }\n\n    function bodyFromId(system: ISolarSystem, id: number) {\n        if(id === 0) {\n            return system.sun;\n        } else {\n            const body = system.orbiterIds.get(id);\n            if(!body)\n                throw new Error(`No body with id ${id}`);\n            return body;\n        }\n    }\n\n    export function ejectionTrajectories(system: ISolarSystem, startOrbit: IOrbit, transferOrbit: IOrbit, ejectionSequence: number[], transferStartDate: number, \n                                         matchStartMo: boolean = true, eitype: \"fastdirect\" | \"direct\" | \"fastoberth\" | \"oberth\" = \"fastdirect\", soiPatchPositions: Vector3[] = ejectionSequence.slice(-1).map((i) => vec3(0,0,0))): Trajectory[] {\n        let ejectionInfos: Trajectory[] = [];\n        \n        let nextOrbit: IOrbit;\n        let previousOrbit: IOrbit;\n\n        let nextOrbitVel: Vector3;\n        let currentBodyVel: Vector3;\n\n        let escapeDate = transferStartDate;\n        const nEjections = ejectionSequence.length - 1;\n        for(let i=nEjections - 1; i>=0; i--) {\n            // body around which the ejection orbit takes place\n            const currentBody = (bodyFromId(system, ejectionSequence[i]) as IOrbitingBody);\n            // body after escape\n            const nextBody = bodyFromId(system, ejectionSequence[i+1]);\n            // if this is the first ejection, use the starting orbit\n            if(i === 0) {\n                previousOrbit = startOrbit;\n            // otherwise, use the orbit of the body that has just been escaped\n            } else {\n                const previousBody = (bodyFromId(system, ejectionSequence[i-1]) as IOrbitingBody);\n                previousOrbit = previousBody.orbit;\n            }\n            // if this is the last ejection, use the transfer orbit as the next orbit\n            if(i === nEjections - 1) {\n                nextOrbit = transferOrbit;\n                nextOrbitVel = Kepler.orbitToVelocityAtDate(nextOrbit, nextBody, escapeDate);\n                currentBodyVel = Kepler.orbitToVelocityAtDate(currentBody.orbit, nextBody, escapeDate);\n            // otherwise, use the next ejection orbit\n            } else {\n                const nextEjection = ejectionInfos[ejectionInfos.length-1];\n                nextOrbit      = nextEjection.orbits[0];\n                nextOrbitVel   = nextEjection.maneuvers[0].postState.vel;\n                escapeDate     = nextEjection.maneuvers[0].postState.date;\n                currentBodyVel = nextEjection.maneuvers[0].preState.vel;\n            }\n                        \n            // get relative velocity to the current body at escape\n            const relativeVel = sub3(nextOrbitVel, currentBodyVel);\n\n            // always match the mean anomaly of a body's orbit\n            const matchOrb = i > 0 ? true : matchStartMo;\n\n            // type check\n            let type = eitype;\n            if(type === \"fastoberth\") {\n                // try to perform a quick check to see if a direct transfer would be better\n                const soi = currentBody.soi;\n                const mu = currentBody.stdGravParam;\n                const soiSpeedSq = magSq3(relativeVel);\n                const apoapsis = previousOrbit.semiMajorAxis;\n                const periapsis = FlybyCalcs.minFlybyRadius(currentBody);\n\n                const escapeEnergy = soiSpeedSq  / 2 - mu / soi;\n                const parkSpeed = Math.sqrt(mu / apoapsis);\n\n                const obrEcc    = (apoapsis - periapsis) / (periapsis + apoapsis);\n                const obrSMA    = periapsis / (1 - obrEcc);\n                const obrEnergy = -mu  / (2 * obrSMA) ;\n        \n                const obrPeriapsisSpeed = Math.sqrt((obrEnergy + mu / periapsis) * 2); \n                const escPeriapsisSpeed = Math.sqrt((escapeEnergy + mu / periapsis) * 2); \n                const obrApoapsisSpeed  = Math.sqrt((obrEnergy + mu / apoapsis) * 2);\n                const directSpeed = Math.sqrt((escapeEnergy + mu / apoapsis) * 2);\n        \n                const directDeltaV = Math.abs(parkSpeed - directSpeed);\n                const oberthDeltaV = Math.abs(escPeriapsisSpeed - obrPeriapsisSpeed) + Math.abs(obrApoapsisSpeed - parkSpeed);\n\n                if(directDeltaV < oberthDeltaV) {\n                    type = \"fastdirect\";\n                }\n            }\n\n            // patch position\n            const patchPos = i === 0 ? vec3(0,0,0) : soiPatchPositions[i - 1];\n\n            // calculate the ejection trajectory\n            let currentEjection: Trajectory = type === \"fastdirect\" ? DepartArrive.fastDeparture(previousOrbit,       currentBody, relativeVel, escapeDate, matchOrb) :\n                                              type === \"direct\"     ? DepartArrive.optimalDeparture(previousOrbit,    currentBody, relativeVel, escapeDate, matchOrb, \"direct\", patchPos) :\n                                              type === \"fastoberth\" ? DepartArrive.fastOberthDeparture(previousOrbit, currentBody, relativeVel, escapeDate, matchOrb, patchPos) :\n                                              type === \"oberth\"     ? DepartArrive.optimalDeparture(previousOrbit,    currentBody, relativeVel, escapeDate, matchOrb, \"oberth\", patchPos) :\n                                              DepartArrive.fastDeparture(previousOrbit,  currentBody, relativeVel, escapeDate, matchOrb);\n\n            // if there is a nonzero SoI patch position for this ejection, and the \"fastdirect\" type was used, recalculate the ejection with the modified start position\n            if(i > 0 && type === \"fastdirect\" && mag3(patchPos) > 0) {\n                // optimize ejection eccentricity based on starting position\n                const patchedEjOrb = DepartArrive.departArriveForPosition(add3(currentEjection.maneuvers[0].preState.pos, patchPos),\n                                                                            currentBody,\n                                                                            relativeVel,\n                                                                            escapeDate,\n                                                                            1).orbit;\n                // calculate the date when the exited body is at the right place\n                const previousOrbitNu = Kepler.angleInOrbitPlane(currentEjection.maneuvers[0].preState.pos, previousOrbit);\n                const ejEpoch = Kepler.trueAnomalyToOrbitDate(previousOrbitNu, previousOrbit, patchedEjOrb.epoch - previousOrbit.siderealPeriod / 2)\n                const soiDate = escapeDate + ejEpoch - patchedEjOrb.epoch;\n                patchedEjOrb.epoch = ejEpoch;\n\n                // prepare orbital states for exited body and ejection orbit at time of ejection\n                const ejPreVel = Kepler.velocityAtTrueAnomaly(previousOrbit, currentBody.stdGravParam, previousOrbitNu);\n                const ejPreState: OrbitalState = {date: ejEpoch, pos: currentEjection.maneuvers[0].preState.pos, vel: ejPreVel};\n                const ejPostState = Kepler.orbitToStateAtDate(patchedEjOrb, currentBody, patchedEjOrb.epoch);\n                const maneuver = Kepler.maneuverFromOrbitalStates(ejPreState, ejPostState);\n                currentEjection = {\n                    orbits:             [patchedEjOrb],\n                    intersectTimes:     [ejEpoch, soiDate],\n                    maneuvers:          [maneuver],\n                }\n            }\n\n            // add the calculated ejection to the list\n            ejectionInfos.push(currentEjection);\n        }\n\n        return ejectionInfos.reverse();\n    }\n\n    export function insertionTrajectories(system: ISolarSystem, endOrbit: IOrbit, transferOrbit: IOrbit, insertionSequence: number[], transferEndDate: number, \n                                          matchEndMo: boolean = true, eitype: \"fastdirect\" | \"direct\" | \"fastoberth\" | \"oberth\" = \"fastdirect\", soiPatchPositions: Vector3[] = insertionSequence.slice(0,-1).map((i) => vec3(0,0,0))): Trajectory[] {\n        let insertionInfos: Trajectory[] = [];\n\n        let previousOrbit: IOrbit;\n        let nextOrbit: IOrbit;\n\n        let previousOrbitVel: Vector3;\n        let currentBodyVel: Vector3;\n\n        let encounterDate = transferEndDate;\n        const nInsertions = insertionSequence.length - 1;\n        for(let i=0; i<nInsertions; i++) {\n            // body around which the insertion orbit takes place\n            const currentBody = (bodyFromId(system, insertionSequence[i+1]) as IOrbitingBody);\n            // body prior to encounter\n            const previousBody = bodyFromId(system, insertionSequence[i]);\n            // if this is the last insertion, use the ending orbit\n            if(i === nInsertions - 1) {\n                nextOrbit = endOrbit;\n            // otherwise, use the orbit of the body about to be encountered\n            } else {\n                const nextBody = (bodyFromId(system, insertionSequence[i+2]) as IOrbitingBody);\n                nextOrbit = nextBody.orbit;\n            }\n            // if this is the first insertion, use the transfer orbit as the next orbit\n            if(i === 0) {\n                previousOrbit = transferOrbit;\n                previousOrbitVel = Kepler.orbitToVelocityAtDate(previousOrbit, previousBody, encounterDate);\n                currentBodyVel = Kepler.orbitToVelocityAtDate(currentBody.orbit, previousBody, encounterDate);\n            // otherwise, use the previous insertion orbit\n            } else {\n                const previousInsertion = insertionInfos[insertionInfos.length-1];\n                const prevInLen  = previousInsertion.orbits.length;\n                const prevManLen = previousInsertion.maneuvers.length;\n                previousOrbit    = previousInsertion.orbits[prevInLen - 1];\n                previousOrbitVel = previousInsertion.maneuvers[prevManLen - 1].preState.vel;\n                encounterDate    = previousInsertion.maneuvers[prevManLen - 1].preState.date;\n                currentBodyVel   = previousInsertion.maneuvers[prevManLen - 1].postState.vel;\n            }\n\n            // get relative velocity to the current body at encounter\n            const relativeVel = sub3(previousOrbitVel, currentBodyVel);\n\n            // always match the mean anomaly of a body's orbit\n            const matchOrb = i < nInsertions - 1 ? true : matchEndMo;\n\n            // type check\n            let type = eitype;\n            if(type === \"fastoberth\") {\n                // try to perform a quick check to see if a direct transfer would be better\n                const soi = currentBody.soi;\n                const mu = currentBody.stdGravParam;\n                const soiSpeedSq = magSq3(relativeVel);\n                const apoapsis = nextOrbit.semiMajorAxis;\n                const periapsis = FlybyCalcs.minFlybyRadius(currentBody);\n\n                const encounterEnergy = soiSpeedSq  / 2 - mu / soi;\n                const parkSpeed = Math.sqrt(mu / apoapsis);\n\n                const obrSMA    = (apoapsis + periapsis) / 2;\n                const obrEnergy = -mu  / (2 * obrSMA) ;\n        \n                const obrPeriapsisSpeed = Math.sqrt((obrEnergy + mu / periapsis) * 2); \n                const encPeriapsisSpeed = Math.sqrt((encounterEnergy + mu / periapsis) * 2); \n                const obrApoapsisSpeed  = Math.sqrt((obrEnergy + mu / apoapsis) * 2);\n                const directSpeed = Math.sqrt((encounterEnergy + mu / apoapsis) * 2);\n        \n                const directDeltaV = Math.abs(parkSpeed - directSpeed);\n                const oberthDeltaV = Math.abs(encPeriapsisSpeed - obrPeriapsisSpeed) + Math.abs(obrApoapsisSpeed - parkSpeed);\n\n                if(directDeltaV < oberthDeltaV) {\n                    type = \"fastdirect\";\n                }\n            }\n\n            // patch position\n            const patchPos = i === nInsertions - 1 ? vec3(0,0,0) : soiPatchPositions[i+1];\n\n            // calculate the insertion trajectory\n            let currentInsertion = type === \"fastdirect\"   ? DepartArrive.fastArrival(nextOrbit,     currentBody, relativeVel, encounterDate, matchOrb) :\n                                   type === \"direct\" ? DepartArrive.optimalArrival(nextOrbit,        currentBody, relativeVel, encounterDate, matchOrb, \"direct\", patchPos) :\n                                   type === \"fastoberth\" ? DepartArrive.fastOberthArrival(nextOrbit, currentBody, relativeVel, encounterDate, matchOrb, patchPos) :\n                                   type === \"oberth\" ? DepartArrive.optimalArrival(nextOrbit,        currentBody, relativeVel, encounterDate, matchOrb, \"oberth\", patchPos) :\n                                   DepartArrive.fastArrival(nextOrbit, currentBody, relativeVel, encounterDate, matchOrb);\n            \n            // if there is a nonzero SoI patch position for this insertion, and it's not the last one,  recalculate the ejection with the modified start position\n            if(i < nInsertions && type === \"fastdirect\" && mag3(patchPos) > 0) {\n                const manLen = currentInsertion.maneuvers.length;\n                const patchedInOrb = DepartArrive.departArriveForPosition(add3(currentInsertion.maneuvers[manLen - 1].postState.pos, patchPos),\n                                                                            currentBody,\n                                                                            relativeVel,\n                                                                            encounterDate,\n                                                                            -1).orbit;\n                // calculate the date when the encountered body is at the right place\n                const nextOrbitNu = Kepler.angleInOrbitPlane(currentInsertion.maneuvers[manLen - 1].postState.pos, nextOrbit);\n                const inEpoch = Kepler.trueAnomalyToOrbitDate(nextOrbitNu, nextOrbit, patchedInOrb.epoch - nextOrbit.siderealPeriod / 2);\n                const soiDate = encounterDate + inEpoch - patchedInOrb.epoch;\n                patchedInOrb.epoch = inEpoch;\n\n                // prepare orbital states for encountered body and insertion orbit at time of encounter\n                const inPreVel = Kepler.velocityAtTrueAnomaly(nextOrbit, currentBody.stdGravParam, nextOrbitNu);\n                const inPostState: OrbitalState = {date: inEpoch, pos: currentInsertion.maneuvers[manLen - 1].postState.pos, vel: inPreVel};\n                const inPreState = Kepler.orbitToStateAtDate(patchedInOrb, currentBody, patchedInOrb.epoch);\n                const maneuver = Kepler.maneuverFromOrbitalStates(inPreState, inPostState);\n\n                currentInsertion = {\n                    orbits:         [patchedInOrb],\n                    intersectTimes: [soiDate, inEpoch],\n                    maneuvers:      [maneuver],\n                }\n            }\n            insertionInfos.push(currentInsertion);\n        }\n        return insertionInfos;\n    }\n\n}\n\nexport default Trajectories;","import Orbit from \"./orbit\"\nimport Color from \"./color\";\n\nexport class CelestialBody implements ICelestialBody {\n    readonly id!:               number;\n    readonly name!:             string;\n    readonly radius!:           number;\n    readonly maxTerrainHeight:  number;\n    readonly atmosphereHeight!: number;\n    readonly mass!:             number;\n    readonly geeASL:            number;\n    readonly stdGravParam!:     number;\n    readonly soi!:              number;\n    readonly color!:            Color;\n    readonly orbiters:          OrbitingBody[] = [];\n\n    constructor(data: ICelestialBody) {\n        this.id                 = data.id;\n        this.name               = data.name;\n        this.radius             = data.radius;\n        this.maxTerrainHeight   = data.maxTerrainHeight ? data.maxTerrainHeight : 0.0;\n        this.atmosphereHeight   = data.atmosphereHeight ? data.atmosphereHeight : 0.0;\n        this.mass               = data.mass ? data.mass : data.stdGravParam / 6.7430e-11;\n        this.geeASL             = data.geeASL ? data.geeASL : data.stdGravParam / (data.radius * data.radius * 9.80665);\n        this.stdGravParam       = data.stdGravParam;\n        this.soi                = data.soi;\n        this.color              = new Color(data.color);\n    }\n\n    public get data() : ICelestialBody {\n        return {\n            id:                 this.id,\n            name:               this.name,\n            radius:             this.radius,\n            atmosphereHeight:   this.atmosphereHeight,\n            mass:               this.mass,\n            geeASL:             this.geeASL,\n            stdGravParam:       this.stdGravParam,\n            soi:                this.soi,\n            color:              this.color\n        }\n    }\n\n    public get orbiterIds() : number[] {\n        let orbIds: number[] = [];\n        for(let i=0; i<this.orbiters.length; i++) {\n            orbIds.push(this.orbiters[i].id)\n        }\n        return orbIds\n    }\n\n    public get furtherstOrbiterDistance() : number {\n        let maxDist = 0.0;\n        for(let i=0; i<this.orbiters.length; i++) {\n            const orb = this.orbiters[i].orbit;\n            const orbDist = orb.semiMajorAxis * (1 + orb.eccentricity);\n            maxDist = Math.max(orbDist, maxDist)\n        }\n        return maxDist;\n    }\n}\n\nexport class OrbitingBody extends CelestialBody implements IOrbitingBody {\n    readonly orbit!:            Orbit;\n    readonly orbiting!:         number;\n\n    constructor(data: IOrbitingBody, public readonly attractor: CelestialBody, anglesToRad: boolean = false) {\n        super(data);\n        \n        this.orbit        = new Orbit(data.orbit, this.attractor, anglesToRad);\n        this.orbiting     = data.orbiting;\n    }\n\n    public get data(): IOrbitingBody {\n        return {\n            ...super.data,\n            orbit:          this.orbit.data,\n            orbiting:       this.orbiting,\n        };\n    }\n}\n\nexport function isOrbitingBody(body: ICelestialBody): body is OrbitingBody {\n    return (body as OrbitingBody).orbiting !== undefined;\n}\n\nexport default CelestialBody;","export class Color implements IColor {\n    readonly r!:    number;\n    readonly g!:    number;\n    readonly b!:    number;\n    readonly a!:    number;\n\n    constructor(c: IColor) {\n        this.r = c.r;\n        this.g = c.g;\n        this.b = c.b;\n        this.a = c.a ? c.a : 1;\n    }\n\n    public rescale(scale: number) {\n        return new Color({r: Math.max(Math.min(scale * this.r, 255), 0), \n                          g: Math.max(Math.min(scale * this.g, 255), 0), \n                          b: Math.max(Math.min(scale * this.b, 255), 0),\n                          a: this.a});\n    }\n\n    public toString() {\n        return 'rgba('.concat(this.r.toString(), \",\", this.g.toString(), \",\", this.b.toString(), \",\", this.a.toString(), \")\");\n    }\n}\n\nexport default Color;","import Kepler from \"../libs/kepler\";\nimport { degToRad } from \"../libs/math\";\n\nexport class Orbit implements IOrbit {\n    readonly semiMajorAxis!:         number;\n    readonly apoapsis!:              number;\n    readonly periapsis!:             number;\n    readonly eccentricity!:          number;\n    readonly inclination!:           number;\n    readonly argOfPeriapsis!:        number;\n    readonly ascNodeLongitude!:      number;\n    readonly meanAnomalyEpoch!:      number;\n    readonly epoch!:                 number; \n    readonly semiLatusRectum!:       number;\n    readonly siderealPeriod!:        number;\n    readonly orbiting!:              number;\n    readonly attractorSoi!:          number;\n    readonly attractorStdGravParam!: number\n\n\n    constructor (data: KeplerElements, attractor: ICelestialBody, anglesToRad: boolean = false) {\n        this.semiMajorAxis = data.semiMajorAxis;\n        this.eccentricity  = data.eccentricity;\n        this.meanAnomalyEpoch = data.meanAnomalyEpoch;\n        this.epoch = data.epoch;\n\n        if (anglesToRad) {\n            this.inclination = degToRad(data.inclination);\n            this.argOfPeriapsis = degToRad(data.argOfPeriapsis);\n            this.ascNodeLongitude = degToRad(data.ascNodeLongitude);\n        } else {\n            this.inclination = data.inclination;\n            this.argOfPeriapsis = data.argOfPeriapsis;\n            this.ascNodeLongitude = data.ascNodeLongitude;\n        }\n\n        this.periapsis = this.semiMajorAxis * (1 - this.eccentricity);\n        this.apoapsis =  this.eccentricity > 1 ? Infinity : this.semiMajorAxis * (1 + this.eccentricity);\n\n        this.semiLatusRectum = this.semiMajorAxis * (1 - this.eccentricity * this.eccentricity);\n        \n\n        this.siderealPeriod = Kepler.siderealPeriod(data.semiMajorAxis, attractor.stdGravParam);\n\n        this.orbiting = attractor.id;\n\n        this.attractorSoi = attractor.soi;\n        this.attractorStdGravParam = attractor.stdGravParam;\n    }\n\n    public get data(): IOrbit {\n        return {\n            orbiting:         this.orbiting,\n            semiMajorAxis:    this.semiMajorAxis,\n            apoapsis:         this.apoapsis,\n            periapsis:        this.periapsis,\n            eccentricity:     this.eccentricity,\n            inclination:      this.inclination,\n            argOfPeriapsis:   this.argOfPeriapsis,\n            ascNodeLongitude: this.ascNodeLongitude,\n            meanAnomalyEpoch: this.meanAnomalyEpoch,\n            epoch:            this.epoch,\n            semiLatusRectum:  this.semiLatusRectum,\n            siderealPeriod:   this.siderealPeriod,\n        };\n    }\n\n    public static fromOrbitalElements(elements: KeplerElements, attractor: ICelestialBody){\n        const data = Kepler.orbitFromElements(elements, attractor);\n        return new Orbit(data, attractor);\n    }\n}\n\nexport default Orbit","import { OrbitingBody, CelestialBody, isOrbitingBody } from \"./body\";\n\nexport class SolarSystem implements ISolarSystem {\n    readonly sun!:              CelestialBody;\n    readonly orbiters!:         OrbitingBody[];\n    readonly orbiterIds!:       Map<number, OrbitingBody>;\n\n    constructor(sun: ICelestialBody, bodies: IOrbitingBody[], anglesToRad: boolean = false) {\n        this.orbiters = [];\n        this.orbiterIds = new Map();\n        this.sun = new CelestialBody(sun);\n        \n        for(let i=0; i<bodies.length; i++){\n            const bodydata = bodies[i];\n            const attractor = bodydata.orbiting === 0 ? this.sun : (this.orbiterIds!.get(bodydata.orbiting) as OrbitingBody);\n            const body = new OrbitingBody(bodydata, attractor, anglesToRad);\n            \n            this.orbiterIds!.set(body.id, body);\n            attractor.orbiters.push(body);\n            this.orbiters.push(body);\n        }\n    }\n\n    public get orbiting() {\n        return [...this.orbiterIds!.values()];\n    }\n\n    public get bodies(){\n        return [this.sun, ...this.orbiters];\n    }\n\n    public get data() {\n        const data = [];\n        for(const body of this.bodies) {\n            data.push(body.data);\n        }\n        return data;\n    }\n\n    public get size() {\n        return (1 + this.orbiterIds.size)\n    }\n\n    public bodyFromName(name: string) {\n        for(const body of [this.sun, ...this.orbiters]) {\n            if(body.name === name)\n                return body;\n        }\n        throw new Error(`No body with name ${name}`);\n    }\n\n    public bodyFromId(id: number) {\n        if(id === 0) {\n            return this.sun;\n        } else {\n            const body = this.orbiterIds.get(id);\n            if(!body)\n                throw new Error(`No body with id ${id}`);\n            return body;\n        }\n    }\n\n    public sequenceToSun(id: number) {\n        let bd = this.bodyFromId(id);\n        let seq: number[] = [bd.id];\n        while(isOrbitingBody(bd)) {\n            bd = this.bodyFromId(bd.orbiting);\n            seq.push(bd.id);\n        }\n        return seq\n    }\n\n    public commonAttractorId(id1: number, id2: number) {\n        const sunSeq1 = this.sequenceToSun(id1);\n        const sunSeq2 = this.sequenceToSun(id2);\n        for(let i=0; i<sunSeq1.length; i++) {\n            if(sunSeq2.includes(sunSeq1[i])) {\n                return sunSeq1[i]\n            }\n        }\n        throw new Error('Bodies do not share a common attractor (error in defining this SolarSystem)')\n    }\n}\n\nexport default SolarSystem;","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport possibleConstructorReturn from \"./possibleConstructorReturn.js\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import superPropBase from \"./superPropBase.js\";\nexport default function _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get.apply(this, arguments);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import defineProperty from \"./defineProperty.js\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}","import _typeof from \"./typeof.js\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}"],"names":["householderIterations","T","x0","N","eps","lambda","maxIters","xnew","tof","delta","DT","DDT","DDDT","it","DTs","dTdx","x2tof","DT2","Math","abs","x","l2","l3","umx2","y","sqrt","y2","y3","dist","a","alfa","acos","beta","asin","sin","TWO_PI","acosh","asinh","sinh","x2tof2","K","E","rho","z","eta","Q","tol","Sj","Cj","err","Cj1","Sj1","j","hypergeometricF","PI","g","d","l","f","log","r1vec","r2vec","attractor","it1","it2","revs","retro","left","mu","stdGravParam","r1","mag3","r2","c","sub3","s","ir1","div3","ir2","ih","normalize3","cross3","lambda2","mult3","lambda3","nRevs","T00","T0","T1","Tmin","xOld","xNew","pow","tmp","gamma","sigma","vr1","vr2","vt","vt1","vt2","v1","add3","v2","dTheta","atan2","dot3","pmin","pmax","k","cos","L","m","pj","pjj","Infinity","warntol","maxit","p","pNext","df","t","dtdp","tan","sinDeltaE","cosDeltaE","deltaE","wrapAngle","angularspeed","dF","console","Lambert","GOLDEN_RATIO","brentRootFind","func","min","max","errtol","Number","EPSILON","b","fa","fb","sign","Error","temp_a","temp_fa","fc","bisected","fs","itsRemaining","currentStep","previousStep","secondStep","brentMinimize","GRsq","etol","h","w","v","fv","fw","fx","u","fu","q","e","newtonRootSolve","prevX","n","sortNMpoints","p1","p2","objx","nelderMeadMinimize","initialPoints","objective","maxIt","length","alpha","simplex","centroid","slice","reflect","contract","expand","i","push","sort","objReflect","objExpand","objContract","bodyFromId","system","id","sun","body","orbiterIds","get","startOrbit","endOrbit","transferBody","startDate","flightTime","endDate","planeChange","startPatchPosition","vec3","endPatchPosition","startState","Kepler","endState","startPos","pos","endPos","planeEndPos","transferOrbit1","date","vel","startNu","endNu","planeChangeNu","HALF_PI","planeChangeDate","planeChangePreState","n1vec","n2vec","rotationAngle","acosClamped","rotationAxis","Z_DIR","isNaN","newVel","roderigues","planeChangePostState","transferOrbit2","departState","arriveState","arriveNu","departManeuver","arriveManeuver","planeManeuver","trajectory","orbits","intersectTimes","maneuvers","transferOrbit","ejectionSequence","transferStartDate","nextOrbit","previousOrbit","nextOrbitVel","currentBodyVel","matchStartMo","eitype","soiPatchPositions","map","ejectionInfos","escapeDate","nEjections","currentBody","nextBody","previousBody","orbit","nextEjection","postState","preState","relativeVel","matchOrb","type","soi","soiSpeedSq","magSq3","apoapsis","semiMajorAxis","periapsis","FlybyCalcs","escapeEnergy","parkSpeed","obrEcc","obrSMA","obrEnergy","obrPeriapsisSpeed","escPeriapsisSpeed","obrApoapsisSpeed","directSpeed","directDeltaV","oberthDeltaV","patchPos","currentEjection","DepartArrive","patchedEjOrb","previousOrbitNu","ejEpoch","epoch","siderealPeriod","soiDate","ejPreVel","ejPreState","ejPostState","maneuver","reverse","insertionSequence","transferEndDate","previousOrbitVel","matchEndMo","insertionInfos","encounterDate","nInsertions","previousInsertion","prevInLen","prevManLen","encounterEnergy","encPeriapsisSpeed","currentInsertion","manLen","patchedInOrb","nextOrbitNu","inEpoch","inPreVel","inPostState","inPreState","Trajectories","CelestialBody","data","name","radius","maxTerrainHeight","atmosphereHeight","mass","geeASL","color","orbiters","this","Color","orbIds","maxDist","orb","orbDist","eccentricity","OrbitingBody","anglesToRad","orbiting","Orbit","isOrbitingBody","undefined","r","scale","concat","toString","inclination","argOfPeriapsis","ascNodeLongitude","meanAnomalyEpoch","semiLatusRectum","attractorSoi","attractorStdGravParam","degToRad","elements","SolarSystem","bodies","Map","bodydata","set","values","size","bd","seq","id1","id2","sunSeq1","sequenceToSun","sunSeq2","includes","_assertThisInitialized","self","ReferenceError","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_createForOfIteratorHelper","o","allowArrayLike","Symbol","iterator","Array","isArray","F","done","value","_e","normalCompletion","didErr","call","step","next","_e2","_createSuper","Derived","hasNativeReflectConstruct","result","Super","NewTarget","constructor","Reflect","construct","arguments","apply","_defineProperty","obj","_get","property","receiver","base","desc","getOwnPropertyDescriptor","_getPrototypeOf","setPrototypeOf","getPrototypeOf","__proto__","_inherits","subClass","superClass","create","_isNativeReflectConstruct","sham","Proxy","Boolean","valueOf","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","_objectSpread2","source","forEach","getOwnPropertyDescriptors","defineProperties","_possibleConstructorReturn","_setPrototypeOf","_superPropBase","hasOwnProperty","_typeof"],"sourceRoot":""}