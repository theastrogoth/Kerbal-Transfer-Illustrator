{"version":3,"file":"static/js/315.4b1ca000.chunk.js","mappings":"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","sources":["main/libs/transfer-calculator.ts","main/objects/transfer.ts"],"sourcesContent":["import Kepler from \"./kepler\";\nimport Trajectories from \"./trajectories\";\nimport Transfer from \"../objects/transfer\";\nimport { sub3, vec3, mag3, sphericalToCartesian, cartesianToSpherical, randomSign} from \"./math\";\nimport { nelderMeadMinimize } from \"./optim\";\n\nclass TransferCalculator {\n    private readonly _system:           ISolarSystem;\n    private _sequenceUp!:               number[];\n    private _sequenceDown!:             number[];\n\n    private _startOrbit:                IOrbit;\n    private _endOrbit:                  IOrbit;\n\n    private _startBody:                 ICelestialBody;\n    private _endBody:                   ICelestialBody;\n    private _transferBody:              ICelestialBody;\n\n    private _startDate:                 number;\n    private _flightTime:                number;\n    private _endDate:                   number;\n\n    private _transferTrajectory:        Trajectory;\n    private _ejections:                 Trajectory[];\n    private _insertions:                Trajectory[];\n\n    private _soiPatchPositions:         Vector3[];\n    private _soiPatchBodies:            ICelestialBody[];\n\n    private _ejectionInsertionType:     \"fastdirect\" | \"direct\" | \"fastoberth\" | \"oberth\";\n\n    private _planeChange:               boolean;\n    private _noInsertionBurn:           boolean;\n    private _matchStartMo:              boolean;\n    private _matchEndMo:                boolean;\n\n    private _maneuvers:                 Maneuver[];\n    private _maneuverContexts:          String[];\n    private _deltaV!:                   number;\n\n    constructor(inputs: TransferInputs) {\n        this._system        = inputs.system;\n        this._startOrbit    = inputs.startOrbit;\n        this._startBody     = (inputs.startBody) ? inputs.startBody : this.bodyFromId(this._startOrbit.orbiting);\n        this._endOrbit      = inputs.endOrbit;\n        this._endBody       = (inputs.endBody) ? inputs.endBody : this.bodyFromId(this._endOrbit.orbiting);\n        this._startDate     = inputs.startDate;\n        this._flightTime    = inputs.flightTime\n        this._endDate       = inputs.startDate + inputs.flightTime;\n\n        if(!inputs.transferBody) {\n            const startId = this._startBody.id;\n            const endId = this._endBody.id;\n            const transferId = this.commonAttractorId(startId, endId);\n            this._transferBody = this.bodyFromId(transferId);\n        } else {\n            this._transferBody = inputs.transferBody;\n        }\n\n        if(!inputs.sequenceUp) {\n            this.setSequenceUp();\n        } else {\n            this._sequenceUp = inputs.sequenceUp;\n        }\n\n        if(!inputs.sequenceDown) {\n            this.setSequenceDown();\n        } else {\n            this._sequenceDown = inputs.sequenceDown;\n        }\n\n        const soiPatchSequence = [...this._sequenceUp.slice(0, this._sequenceUp.length - 1), ...this._sequenceDown.slice(1, this._sequenceDown.length)];\n        this._soiPatchBodies = soiPatchSequence.map(i => this.bodyFromId(i));\n\n        this._ejectionInsertionType = inputs.ejectionInsertionType === undefined ? \"fastdirect\" : inputs.ejectionInsertionType;\n        this._planeChange     = inputs.planeChange     === undefined ? false : inputs.planeChange;    \n        this._matchStartMo    = inputs.matchStartMo    === undefined ? true  : inputs.matchStartMo;\n        this._matchEndMo      = inputs.matchEndMo      === undefined ? false : inputs.matchEndMo;     \n        this._noInsertionBurn = inputs.noInsertionBurn === undefined ? false : inputs.noInsertionBurn;\n\n        // initialize arrays of orbits and maneuvers\n        this._transferTrajectory = {orbits: [], intersectTimes: [], maneuvers: []};\n        this._ejections = [];\n        this._insertions = [];\n        this._maneuvers = [];\n        this._maneuverContexts = [];\n\n        // if not provided set all soi patch corrections to zero\n        if(!inputs.soiPatchPositions) {\n            this._soiPatchPositions = [];\n            for(let i=1; i<=this._soiPatchBodies.length; i++) {\n                this._soiPatchPositions.push(vec3(0.0, 0.0, 0.0));\n            }\n        } else {\n            this._soiPatchPositions = inputs.soiPatchPositions;\n        }\n\n        // compute the rest of the transfer information\n        this.computeTransfer();\n    }\n\n    public get deltaV() {\n        return this._deltaV;\n    }\n\n    public get ejectionDeltaV() {\n        return this._maneuvers[0].deltaV;\n    }\n\n    public get insertion() {\n        return this._maneuvers[this._maneuvers.length].deltaV;\n    }\n\n    public get data(): ITransfer {\n        return {\n            system:                 this._system,\n            startOrbit:             this._startOrbit,\n            endOrbit:               this._endOrbit,\n            startDate:              this._startDate,\n            flightTime:             this._flightTime,\n            endDate:                this._endDate,\n            transferTrajectory:     this._transferTrajectory,\n            ejections:   this._ejections,\n            insertions:  this._insertions,\n            maneuvers:              this._maneuvers,\n            maneuverContexts:       this._maneuverContexts,\n            deltaV:                 this._deltaV,\n            soiPatchPositions:      this._soiPatchPositions,\n            ejectionInsertionType:  this._ejectionInsertionType,\n            planeChange:            this._planeChange,\n            matchStartMo:           this._matchStartMo,\n            matchEndMo:             this._matchEndMo,\n            noInsertionBurn:        this._noInsertionBurn,\n            patchPositionError:     this.soiPatchPositionError(),\n            patchTimeError:         this.soiPatchTimeError(),\n        }\n    }\n\n    public get transfer() {\n        return new Transfer(this.data)\n    }\n\n    private clearOrbits() {\n        this._transferTrajectory = {orbits: [], intersectTimes: [], maneuvers: []};\n        this._ejections = [];\n        this._insertions = [];\n        this._maneuvers = [];\n        this._maneuverContexts = [];\n    }\n\n    ///// Trajectory calculation /////\n\n    public computeTransfer() {\n        this.clearOrbits();\n        this.setTransferOrbit();\n        this.setEjectionOrbits();\n        this.setInsertionOrbits();\n        this.setManeuvers();\n        this.setDeltaV();        \n    }\n\n    private bodyFromId(id: number) {\n        if(id === 0) {\n            return this._system.sun;\n        } else {\n            const body = this._system.orbiterIds.get(id);\n            if(!body)\n                throw new Error(`No body with id ${id}`);\n            return body;\n        }\n    }\n\n    private sequenceToSun(id: number) {\n        let bd = this.bodyFromId(id);\n        let seq: number[] = [bd.id];\n        while(bd.hasOwnProperty(\"orbiting\")) {\n            bd = this.bodyFromId((bd as IOrbitingBody).orbiting);\n            seq.push(bd.id);\n        }\n        return seq\n    }\n\n    private commonAttractorId(id1: number, id2: number) {\n        const sunSeq1 = this.sequenceToSun(id1);\n        const sunSeq2 = this.sequenceToSun(id2);\n        for(let i=0; i<sunSeq1.length; i++) {\n            if(sunSeq2.includes(sunSeq1[i])) {\n                return sunSeq1[i]\n            }\n        }\n        throw new Error('Bodies do not share a common attractor (error in defining this SolarSystem)')\n    }\n\n    private setSequenceUp() {\n        let bd = this._startBody;\n        let seq: number[] = [this._startBody.id];\n        while(bd.id !== this._transferBody.id) {\n            if(bd.hasOwnProperty(\"orbiting\")) {\n                bd = this.bodyFromId((bd as IOrbitingBody).orbiting)\n                seq.push(bd.id)\n            } else {\n                throw new Error('The start body does not orbit around the transfer body')\n            }\n        }\n        this._sequenceUp = seq;\n    }\n\n    private setSequenceDown() {\n        let bd = this._endBody;\n        let seq: number[] = [this._endBody.id];\n        while(bd.id !== this._transferBody.id) {\n            if(bd.hasOwnProperty(\"orbiting\")) {\n                bd = this.bodyFromId((bd as IOrbitingBody).orbiting)\n                seq.push(bd.id)\n            } else {\n                throw new Error('The end body does not orbit around the transfer body')\n            }\n        }\n        this._sequenceDown = seq.reverse();\n    }\n\n    private setTransferOrbit() {\n        // Get the orbit/position at the start of the transfer\n        const sOrb = this._sequenceUp.length === 1 ? \n            this._startOrbit : \n            (this.bodyFromId(this._sequenceUp[this._sequenceUp.length - 2]) as IOrbitingBody).orbit;\n\n        const startPatchIdx = this._sequenceUp.length - 2;\n        const startPatchPos = startPatchIdx >= 0 ? this._soiPatchPositions[startPatchIdx] : vec3(0.0, 0.0, 0.0);\n\n        // Get the orbit/position at the end of the transfer\n        const eOrb = this._sequenceDown.length ===1 ? \n            this._endOrbit : \n            (this.bodyFromId(this._sequenceDown[1]) as IOrbitingBody).orbit;\n\n        const endPatchIdx = startPatchIdx + 1;\n        const endPatchPos = endPatchIdx <= this._soiPatchPositions.length ? this._soiPatchPositions[endPatchIdx] : vec3(0.0, 0.0, 0.0);\n\n        this._transferTrajectory = Trajectories.transferTrajectory(sOrb, eOrb, this._transferBody, this._startDate, this._flightTime, this._endDate, this._planeChange, startPatchPos, endPatchPos);\n    }\n\n    private setEjectionOrbits() {\n        const nEjections = this._sequenceUp.length - 1;\n        this._ejections = Trajectories.ejectionTrajectories(this._system, this._startOrbit, this._transferTrajectory.orbits[0], this._sequenceUp, this._startDate, \n                                                            this._matchStartMo, this._ejectionInsertionType, this._soiPatchPositions.slice(0, nEjections));\n        if(nEjections > 0 && !this._matchStartMo) {\n            this._startOrbit = Kepler.stateToOrbit(this._ejections[0].maneuvers[0].preState, this._startBody)\n        }\n    }\n\n    private setInsertionOrbits() {\n        const nEjections  = this._sequenceUp.length   - 1;\n        const transferLength = this._transferTrajectory.orbits.length;\n        this._insertions = Trajectories.insertionTrajectories(this._system, this._endOrbit, this._transferTrajectory.orbits[transferLength- 1], this._sequenceDown, this._endDate, \n                                                              this._matchEndMo, this._ejectionInsertionType, this._soiPatchPositions.slice(nEjections));\n        const nInsertions = this._insertions.length;\n        if(nInsertions > 0 && !this._matchEndMo) {\n            const nManeuvers = this._insertions[nInsertions-1].maneuvers.length;\n            this._endOrbit = Kepler.stateToOrbit(this._insertions[nInsertions-1].maneuvers[nManeuvers-1].postState, this._endBody)\n        }\n    }\n\n    private setManeuvers() {\n        this._maneuvers = [];\n        this._maneuverContexts = [];\n        if(this._ejections.length > 0) {\n            for(let i=0; i<this._ejections.length; i++) {\n                if(i === 0) {\n                    const maneuvers = this._ejections[i].maneuvers;\n                    const bodyname = this.bodyFromId(this._ejections[i].orbits[0].orbiting).name;\n                    const contexts = [\"Departure Burn\"];\n                    for(let j=0; j<maneuvers.length - 1; j++) {\n                        contexts.push(\"Oberth Maneuver Burn over \" + bodyname)\n                    }\n                    this._maneuvers.push(...maneuvers);\n                    this._maneuverContexts.push(...contexts);\n                } else {\n                    const maneuvers = this._ejections[i].maneuvers.slice(1)\n                    const bodyname = this.bodyFromId(this._ejections[i].orbits[0].orbiting).name;\n                    const contexts: String[] = [];\n                    for(let j=0; j<maneuvers.length; j++) {\n                        contexts.push(\"Oberth Maneuver Burn over \" + bodyname)\n                    }\n                    this._maneuvers.push(...maneuvers);\n                    this._maneuverContexts.push(...contexts);\n                }\n            }\n        } else {\n            this._maneuvers.push(this._transferTrajectory.maneuvers[0]);\n            this._maneuverContexts.push(\"Departure Burn\")\n        }\n\n        if(this._transferTrajectory.maneuvers.length > 2) {\n            const maneuvers = this._transferTrajectory.maneuvers.slice(1,-1);\n            const contexts  = maneuvers.map(m => \"Plane Change Burn\")\n            this._maneuvers.push(...maneuvers);\n            this._maneuverContexts.push(...contexts);\n        }\n\n        if(this._insertions.length > 0) {\n            for(let i=0; i<this._insertions.length; i++) {\n                if(i === this._insertions.length - 1) {\n                    const maneuvers = this._insertions[i].maneuvers;\n                    const bodyname = this.bodyFromId(this._insertions[i].orbits[0].orbiting).name;\n                    const contexts: string[] = [];\n                    for(let j=0; j<maneuvers.length - 1; j++) {\n                        contexts.push(\"Oberth Maneuver Burn over \" + bodyname)\n                    }\n                    contexts.push(\"Arrival Burn\");\n                    this._maneuvers.push(...maneuvers);\n                    this._maneuverContexts.push(...contexts);\n                } else {\n                    const maneuvers = this._insertions[i].maneuvers.slice(0,-1);\n                    const bodyname = this.bodyFromId(this._insertions[i].orbits[0].orbiting).name;\n                    const contexts: String[] = [];\n                    for(let j=0; j<maneuvers.length; j++) {\n                        contexts.push(\"Oberth Maneuver Burn over \" + bodyname)\n                    }\n                    this._maneuvers.push(...maneuvers);\n                    this._maneuverContexts.push(...contexts)\n                }\n            }\n        } else {\n            const lastManLen = this._transferTrajectory.maneuvers.length;\n            this._maneuvers.push(this._transferTrajectory.maneuvers[lastManLen - 1]);\n            this._maneuverContexts.push(\"Arrival Burn\")\n        }\n    }\n\n    private setDeltaV() {\n        let dv = 0;\n        const lastManeuverIdx = this._noInsertionBurn ? this._maneuvers.length - 2 : this._maneuvers.length - 1;\n        for(let i=0; i<=lastManeuverIdx; i++) {\n            dv += this._maneuvers[i].deltaVMag;\n        }\n        if (isNaN(dv)) {\n            dv = Number.MAX_VALUE;\n        }\n        this._deltaV = dv;\n    }\n\n    ///// SoI patch optimization /////\n\n    private calculateSoiPatches() {\n        const soiPatchPositions: Vector3[] = [];\n        for(let i=0; i<this._ejections.length; i++) {\n            const ejLen = this._ejections[i].orbits.length;\n            const ejOrbit = this._ejections[i].orbits[ejLen - 1];\n            const ejDate = this._ejections[i].intersectTimes[ejLen];\n            soiPatchPositions.push(Kepler.orbitToPositionAtDate(ejOrbit, ejDate));\n        }\n        for(let j=0; j<this._insertions.length; j++) {\n            const inOrbit = this._insertions[j].orbits[0];\n            const inDate = this._insertions[j].intersectTimes[0];\n            soiPatchPositions.push(Kepler.orbitToPositionAtDate(inOrbit, inDate));\n        }\n        return soiPatchPositions\n    }\n\n    private setSoiPatchPositions() {\n        this._soiPatchPositions = this.calculateSoiPatches();\n    }\n\n    private soiPatchPositionError() {\n        const soiPatchPositions = this.calculateSoiPatches();\n        let err = 0.0;\n        for(let i=0; i<this._soiPatchPositions.length; i++) {\n            err += mag3(sub3(this._soiPatchPositions[i], soiPatchPositions[i]));\n        }\n        return err;\n    }\n\n    private soiPatchUpTimeErrors() {\n        let errs: number[] = [];\n        const lastEjIdx = this._ejections.length - 1;\n        for(let i=0; i<=lastEjIdx; i++) {\n            const ejLen = this._ejections[i].orbits.length;\n            if(i === lastEjIdx) {\n                errs.push(this._ejections[i].intersectTimes[ejLen] - this._startDate);\n            } else{\n                errs.push(this._ejections[i].intersectTimes[ejLen] - this._ejections[i+1].orbits[0].epoch);\n            }\n        }\n        return errs;\n    }\n\n    private soiPatchDownTimeErrors() {\n        let errs: number[] = [];\n        for(let i=0; i<this._insertions.length; i++) {\n            if(i === 0 ) {\n                errs.push(this._insertions[i].intersectTimes[0] - this._endDate);\n            } else {\n                const prevInLen = this._insertions[i-1].orbits.length;\n                errs.push(this._insertions[i].intersectTimes[0] - this._insertions[i-1].intersectTimes[prevInLen]);\n            }\n        }\n        return errs;\n    }\n\n    private soiPatchTimeError() {\n        let err = 0.0;\n        const upErrs = this.soiPatchUpTimeErrors();\n        for(let i=0; i<upErrs.length; i++) {\n            err += Math.abs(upErrs[i]);\n        }\n        const downErrs = this.soiPatchDownTimeErrors();\n        for(let i=0; i<downErrs.length; i++) {\n            err += Math.abs(downErrs[i])\n        }\n        return err;\n    }\n\n    private patchPositionsToAngles(positions: Vector3[] = this._soiPatchPositions): number[] {\n        // angles are returned in a single vector, [theta_1, phi_1, theta_2, phi_2, ...]\n        const angles: number[] = [];\n        for(let i = 0; i<positions.length; i++) {\n            const sphericalPos = cartesianToSpherical(positions[i]);\n            angles.push(sphericalPos.theta, sphericalPos.phi);\n        }\n        return angles;\n    }\n\n    private setPatchPositionsFromAngles(angles: number[]) {\n        // angles should be arranged: [theta_1, phi_1, theta_2, phi_2, ...]\n        for(let i = 0; i < this._soiPatchBodies.length; i++) {\n            this._soiPatchPositions[i] = sphericalToCartesian({r: this._soiPatchBodies[i].soi, theta: angles[2*i], phi: angles[2*i + 1]});\n        }\n    }\n\n    public optimizeSoiPatchPositions(tol: number = 0.001, maxit: number = this._soiPatchPositions.length * 100) {\n        console.log(\"\\tOptimizing transfer SoI patch positions only.\")\n        if(this._soiPatchPositions.length === 0) {\n            return\n        }\n        if(mag3(this._soiPatchPositions[0]) === 0) {\n            this.setSoiPatchPositions();\n        }\n        const objective = (x: number[]): number => {\n            // x contains alternating theta and phi positions for each patch position\n            this.setPatchPositionsFromAngles(x);\n            this.computeTransfer();\n            return this.soiPatchPositionError() + 1000 * this._deltaV;\n        }\n        const initialPoints: number[][] = [this.patchPositionsToAngles()];\n        for(let i = 0; i < this._soiPatchBodies.length; i++) {\n            const newPoint1 = initialPoints[0].slice();\n            const newPoint2 = initialPoints[0].slice();\n            newPoint1[2 * i]     += randomSign() * (Math.random() * Math.PI / 24);\n            newPoint2[2 * i + 1] += randomSign() * (Math.random() * Math.PI / 12);\n            initialPoints.push(newPoint1);\n            initialPoints.push(newPoint2);\n        }\n        const optimizedPoint = nelderMeadMinimize(initialPoints, objective, tol, maxit);\n        this.setPatchPositionsFromAngles(optimizedPoint);\n        this.computeTransfer();\n    }\n\n    private initialPositionAndAnglePoints() {\n        const initialPoints: number[][] = [[this._startDate, this._flightTime, ...this.patchPositionsToAngles()],                                                                                           // current start and end dates\n                                           [this._startDate + randomSign() * Math.random() * this._transferTrajectory.orbits[0].siderealPeriod / 4, this._flightTime, ...this.patchPositionsToAngles()],    // perturb start date\n                                           [this._startDate, this._flightTime + randomSign() * Math.random() * this._transferTrajectory.orbits[0].siderealPeriod / 4, ...this.patchPositionsToAngles()]];   // perturb end date\n        for(let i = 1; i <= this._soiPatchBodies.length; i++) {                                                                                                                                             // perturb each SoI angle                  \n            const newPoint1 = initialPoints[0].slice();\n            const newPoint2 = initialPoints[0].slice();\n            newPoint1[2 * i]     += randomSign() * (Math.random() * Math.PI / 24);\n            newPoint2[2 * i + 1] += randomSign() * (Math.random() * Math.PI / 12);\n            initialPoints.push(newPoint1);\n            initialPoints.push(newPoint2);\n        }\n        return initialPoints;\n    }\n\n    public optimizeSoiPatchPositionsAndTimes(tol: number = 0.001, maxit = (this._soiPatchPositions.length + 2) * 100) {\n        console.log(\"\\tOptimizing transfer SoI patch positions and times.\")\n        if(this._soiPatchPositions.length === 0) {\n            return\n        }\n        if(mag3(this._soiPatchPositions[0]) === 0) {\n            this.setSoiPatchPositions();\n        }\n        const objective = (x: number[]): number => {\n            // the first two elements of x are the transfer start date and transfer end date\n            // the remaining elements of x contain alternating theta and phi positions for each patch position\n            this._startDate = x[0];\n            this._flightTime = x[1];\n            this._endDate = x[0] + x[1];\n            this.setPatchPositionsFromAngles(x.slice(2,x.length));\n            this.computeTransfer();\n            return this.soiPatchPositionError() + 10 * this.soiPatchTimeError() + 1000 * this._deltaV;   // mixed units, so the coefficients here are arbitrary\n        }\n\n        const initialPoints = this.initialPositionAndAnglePoints();\n        const optimizedPoint = nelderMeadMinimize(initialPoints, objective, tol, maxit);\n        objective(optimizedPoint);\n        // const optimizedPointObj = objective(optimizedPoint);\n        // console.log(this._soiPatchPositions)\n        // console.log(this.calculateSoiPatches())\n        // console.log(optimizedPointObj)\n    }\n\n    public optimizeSoiPatches() {\n        if(this._soiPatchPositions.length === 0) {\n            console.log(\"\\tThere are no SoI patches to optimize.\")\n        } else if((this._ejections.length === 0 || (this._ejections.length === 1 && !this._matchStartMo)) &&\n                  (this._insertions.length === 0 || (this._insertions.length === 1 && !this._matchEndMo))) {\n            this.optimizeSoiPatchPositions();\n        } else {\n            this.optimizeSoiPatchPositionsAndTimes();\n        }\n    }\n}\n\nexport default TransferCalculator","import SolarSystem from \"./system\";\nimport { OrbitingBody } from \"./body\";\nimport Orbit from \"./orbit\";\nimport TransferCalculator from \"../libs/transfer-calculator\";\nimport Kepler from \"../libs/kepler\";\nimport { wrapAngle } from \"../libs/math\";\n\n\nexport class Transfer implements ITransfer {\n    readonly system:                    SolarSystem;\n    readonly startOrbit:                Orbit;\n    readonly endOrbit:                  Orbit;\n    readonly startDate:                 number;\n    readonly flightTime:                number;\n    readonly endDate:                   number;\n    readonly transferTrajectory:        Trajectory;\n    readonly ejections:                 Trajectory[];\n    readonly insertions:                Trajectory[];\n    readonly maneuvers:                 Maneuver[];\n    readonly maneuverContexts:          String[];\n    readonly deltaV:                    number;\n    readonly soiPatchPositions:         Vector3[];\n    readonly ejectionInsertionType:     \"fastdirect\" | \"direct\" | \"fastoberth\" | \"oberth\";\n    readonly planeChange:               boolean;\n    readonly noInsertionBurn:           boolean;\n    readonly matchStartMo:              boolean;\n    readonly matchEndMo:                boolean;\n\n    readonly patchPositionError:        number;\n    readonly patchTimeError:            number;\n\n    constructor(inputs: ITransfer) {\n        this.system = new SolarSystem(inputs.system.sun, inputs.system.orbiters);\n        this.startOrbit = new Orbit(inputs.startOrbit, this.system.bodyFromId(inputs.startOrbit.orbiting));\n        this.endOrbit = new Orbit(inputs.endOrbit, this.system.bodyFromId(inputs.endOrbit.orbiting));\n        this.startDate = inputs.startDate;\n        this.flightTime = inputs.flightTime;\n        if(inputs.endDate) {\n            this.endDate = inputs.endDate;\n        } else {\n            this.endDate = inputs.startDate + inputs.flightTime\n        };\n        this.transferTrajectory = inputs.transferTrajectory;\n        this.ejections          = inputs.ejections;\n        this.insertions         = inputs.insertions;\n        this.maneuvers          = inputs.maneuvers;\n        this.maneuverContexts   = inputs.maneuverContexts;\n        this.deltaV             = inputs.deltaV;\n\n        this.ejectionInsertionType  = inputs.ejectionInsertionType;\n        this.planeChange            = inputs.planeChange;    \n        this.matchStartMo           = inputs.matchStartMo;\n        this.matchEndMo             = inputs.matchEndMo;       \n        this.noInsertionBurn        = inputs.noInsertionBurn;\n\n        this.soiPatchPositions  = inputs.soiPatchPositions;\n\n        this.patchPositionError = inputs.patchPositionError;\n        this.patchTimeError     = inputs.patchTimeError;\n    }\n\n    public get data(): ITransfer {\n        return {\n            system:                 this.system,\n            startOrbit:             this.startOrbit,\n            endOrbit:               this.endOrbit,\n            startDate:              this.startDate,\n            flightTime:             this.flightTime,\n            endDate:                this.endDate,\n            transferTrajectory:     this.transferTrajectory,\n            ejections:              this.ejections,\n            insertions:             this.insertions,\n            maneuvers:              this.maneuvers,\n            maneuverContexts:       this.maneuverContexts,\n            deltaV:                 this.deltaV,\n            soiPatchPositions:      this.soiPatchPositions,\n            ejectionInsertionType:  this.ejectionInsertionType,\n            planeChange:            this.planeChange,\n            matchStartMo:           this.matchStartMo,\n            matchEndMo:             this.matchEndMo,\n            noInsertionBurn:        this.noInsertionBurn,\n            patchPositionError:     this.patchPositionError,\n            patchTimeError:         this.patchTimeError,\n        }\n    }\n\n    public optimizeSoiPatches() {\n        const inputs: TransferInputs = {\n            system:             this.system,\n            startOrbit:         this.startOrbit,\n            endOrbit:           this.endOrbit,\n            startDate:          this.startDate,\n            flightTime:         this.flightTime,\n            soiPatchPositions:  this.soiPatchPositions,\n            planeChange:        this.planeChange,\n            matchStartMo:       this.matchStartMo, \n            matchEndMo:         this.matchEndMo,\n            noInsertionBurn:    this.noInsertionBurn,\n        }\n        const transferCalculator = new TransferCalculator(inputs);\n        transferCalculator.optimizeSoiPatches();\n        return transferCalculator.transfer;\n    }\n\n    public get transferBody() {\n        return this.system.bodyFromId(this.system.commonAttractorId(this.startOrbit.orbiting, this.endOrbit.orbiting));\n    }\n\n    public get startBody() {\n        return this.system.bodyFromId(this.startOrbit.orbiting);\n    }\n\n    public get endBody() {\n        return this.system.bodyFromId(this.endOrbit.orbiting);\n    }\n\n    public get phaseAngle() {\n        const sOrb = this.ejections.length === 0  ? this.startOrbit : (this.system.bodyFromId(this.ejections[this.ejections.length - 1].orbits[0].orbiting) as OrbitingBody).orbit;\n        const eOrb = this.insertions.length === 0 ? this.endOrbit   : (this.system.bodyFromId(this.insertions[0].orbits[0].orbiting) as OrbitingBody).orbit;\n        const sPos = Kepler.orbitToPositionAtDate(sOrb, this.startDate);    // start orbit position at start\n        const ePos = Kepler.orbitToPositionAtDate(eOrb, this.startDate);    // target position at start\n        const sAngle = Kepler.angleInOrbitPlane(sPos, sOrb);\n        const eAngle = Kepler.angleInOrbitPlane(ePos, sOrb);\n        return wrapAngle(eAngle - sAngle);\n    }\n}\n\nexport default Transfer;"],"names":["TransferCalculator","inputs","_system","_sequenceUp","_sequenceDown","_startOrbit","_endOrbit","_startBody","_endBody","_transferBody","_startDate","_flightTime","_endDate","_transferTrajectory","_ejections","_insertions","_soiPatchPositions","_soiPatchBodies","_ejectionInsertionType","_planeChange","_noInsertionBurn","_matchStartMo","_matchEndMo","_maneuvers","_maneuverContexts","_deltaV","this","system","startOrbit","startBody","bodyFromId","orbiting","endOrbit","endBody","startDate","flightTime","transferBody","startId","id","endId","transferId","commonAttractorId","sequenceUp","setSequenceUp","sequenceDown","setSequenceDown","soiPatchSequence","slice","length","map","i","undefined","ejectionInsertionType","planeChange","matchStartMo","matchEndMo","noInsertionBurn","orbits","intersectTimes","maneuvers","soiPatchPositions","push","vec3","computeTransfer","deltaV","endDate","transferTrajectory","ejections","insertions","maneuverContexts","patchPositionError","soiPatchPositionError","patchTimeError","soiPatchTimeError","Transfer","data","clearOrbits","setTransferOrbit","setEjectionOrbits","setInsertionOrbits","setManeuvers","setDeltaV","sun","body","orbiterIds","get","Error","bd","seq","hasOwnProperty","id1","id2","sunSeq1","sequenceToSun","sunSeq2","includes","reverse","sOrb","orbit","startPatchIdx","startPatchPos","eOrb","endPatchIdx","endPatchPos","Trajectories","nEjections","Kepler","preState","transferLength","nInsertions","nManeuvers","postState","bodyname","name","contexts","j","m","lastManLen","dv","lastManeuverIdx","deltaVMag","isNaN","Number","MAX_VALUE","ejLen","ejOrbit","ejDate","inOrbit","inDate","calculateSoiPatches","err","mag3","sub3","errs","lastEjIdx","epoch","prevInLen","upErrs","soiPatchUpTimeErrors","Math","abs","downErrs","soiPatchDownTimeErrors","positions","angles","sphericalPos","cartesianToSpherical","theta","phi","sphericalToCartesian","r","soi","tol","maxit","console","log","setSoiPatchPositions","objective","x","setPatchPositionsFromAngles","initialPoints","patchPositionsToAngles","newPoint1","newPoint2","randomSign","random","PI","optimizedPoint","nelderMeadMinimize","siderealPeriod","initialPositionAndAnglePoints","optimizeSoiPatchPositionsAndTimes","optimizeSoiPatchPositions","SolarSystem","orbiters","Orbit","transferCalculator","optimizeSoiPatches","transfer","sPos","ePos","sAngle","eAngle","wrapAngle"],"sourceRoot":""}