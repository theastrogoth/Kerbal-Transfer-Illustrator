{"version":3,"file":"static/js/774.b0e42f61.chunk.js","mappings":"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","sources":["main/libs/departarrive.ts","main/libs/flybycalcs.ts","main/libs/kepler.ts","main/libs/lambert.ts","main/libs/optim.ts","main/libs/trajectories.ts","main/objects/body.ts","main/objects/color.ts","main/objects/orbit.ts","main/objects/system.ts","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/createClass.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/createSuper.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/get.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/inherits.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/superPropBase.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/typeof.js","../javascript/esm|/home/tom/Projects/TypeScript/Kerbal-Transfer-Illustrator/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"],"sourcesContent":["import FlybyCalcs from \"./flybycalcs\";\nimport Kepler from \"./kepler\";\nimport { TWO_PI, X_DIR, Y_DIR, Z_DIR, copysign, acosClamped, wrapAngle, vec3, magSq3, mag3, normalize3, add3, sub3, div3, mult3, dot3, cross3, roderigues, counterClockwiseAngleInPlane, alignVectorsAngleAxis, clamp } from \"./math\"\nimport { brentRootFind, brentMinimize } from \"./optim\"\n\n// const blankOrbit: IOrbit = {\n//     orbiting:   -1,\n//     semiMajorAxis: 0,\n//     eccentricity: 0,\n//     inclination: 0,\n//     argOfPeriapsis: 0,\n//     ascNodeLongitude: 0,\n//     meanAnomalyEpoch: 0,\n//     epoch: 0,\n//     siderealPeriod: 0,\n//     semiLatusRectum: 0,\n// }\n\nnamespace DepartArrive {\n    // \"Direct\" ejection/insertion\n    export function fastDeparture(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, matchParkMo: boolean = true): Trajectory {\n        return fastDepartureArrival(parkOrbit, parkBody, relativeVel, soiDate, true, matchParkMo)\n    }\n\n    export function fastArrival(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, matchParkMo: boolean = true): Trajectory {\n        return fastDepartureArrival(parkOrbit, parkBody, relativeVel, soiDate, false, matchParkMo)\n    }\n\n    export function fastDepartureArrival(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, ejection: boolean, matchParkMo: boolean = true): Trajectory {     \n        const c = ejection ? 1 : -1;\n        const mu = parkBody.stdGravParam;\n        const soi = parkBody.soi;\n        const soiSpeedSq = magSq3(relativeVel);\n\n        const a = 1 / (2 / soi - soiSpeedSq / mu);\n        const etol = 1e-8;\n\n        // Rotate the relative velocity to the perifocal frame of the parking orbit\n        const relativeVelPlane = Kepler.rotateToPerifocalFromInertial(relativeVel, parkOrbit);\n\n        // If the orbit is circular, there is no need to search for a periapsis height\n        let periapsis = parkOrbit.semiMajorAxis;\n\n        // use Brent's method to find when the difference between the departure/arrival hyperbola and parking orbit radius is 0\n        if(parkOrbit.eccentricity > etol) {\n            const periapsisErr = (periapsis: number) => {\n                const res = fastDepartureArrivalForPeriapsis(periapsis, parkOrbit, mu, soi, relativeVelPlane, soiSpeedSq, a, c);\n                return res.err\n            }\n            const min = parkOrbit.semiMajorAxis * (1 - parkOrbit.eccentricity);\n            const max = parkOrbit.eccentricity > 1 ? soi : parkOrbit.semiMajorAxis * (1 + parkOrbit.eccentricity);\n            periapsis = brentRootFind(periapsisErr, min, max);\n        }\n        const {parkNu, e, soiNu, pPos, pVel} = fastDepartureArrivalForPeriapsis(periapsis, parkOrbit, mu, soi, relativeVelPlane, soiSpeedSq, a, c);\n\n        const deltaT = Kepler.trueAnomalyToDate(soiNu, e, Kepler.siderealPeriod(a, mu), 0, 0);\n\n        const periapsisDate = matchParkMo ? Kepler.trueAnomalyToOrbitDate(parkNu, parkOrbit, soiDate - deltaT - parkOrbit.siderealPeriod / 2) \n                                          : soiDate - deltaT;\n        const periapsisState = {\n            date:   periapsisDate,\n            pos:    pPos,\n            vel:    pVel,\n        };\n        \n        const parkState = {\n            date:   periapsisDate,\n            pos:    pPos,\n            vel:    Kepler.velocityAtTrueAnomaly(parkOrbit, mu, parkNu),\n        };\n        const orbit = Kepler.stateToOrbit(periapsisState, parkBody);\n\n        if(c === 1) {\n            const maneuver = Kepler.maneuverFromOrbitalStates(parkState, periapsisState);\n            return {\n                orbits:             [orbit], \n                intersectTimes:     [orbit.epoch, orbit.epoch + deltaT],\n                maneuvers:          [maneuver],\n            }\n        } else {\n            const maneuver = Kepler.maneuverFromOrbitalStates(periapsisState, parkState);\n            return {\n                orbits:             [orbit], \n                intersectTimes:     [orbit.epoch + deltaT, orbit.epoch],\n                maneuvers:          [maneuver],\n            }\n        }\n    }\n\n    function fastDepartureArrivalForPeriapsis(periapsis: number, parkOrbit: IOrbit, mu: number, soi: number, relativeVelPlane: Vector3, soiSpeedSq: number, a: number, c: 1 | -1) {\n\n        const pSpeedSq = soiSpeedSq + 2 * mu * (1 / periapsis - 1 / soi);\n        const pSpeed = Math.sqrt(pSpeedSq);\n\n        const e = Math.sqrt(1 + 2 * (0.5 * pSpeedSq - mu / periapsis) * periapsis * periapsis * pSpeedSq / mu  / mu);\n        const p = a * (1 - e*e);\n\n        // Start in perifocal coordinates of the ejection/insertion orbit\n        // The assumption is made that the periapsis of the ejection/insertion orbit intersects with the parking orbit (which is not necessarily optimal, but is good for near-circular cases)\n        const soiNu = c * Kepler.trueAnomalyAtDistance(soi, e, p);\n        let soiVel = mult3(Kepler.motionDirectionAtTrueAnomaly(soiNu, e), Math.sqrt(soiSpeedSq));\n        let pPos = mult3(X_DIR, periapsis);\n        let pVel = mult3(Y_DIR, pSpeed);\n\n        // Rotate about the x-axis to match the inclination of the relative velocity (in the plane of the parking orbit)\n        const rotAngle1 = Math.atan2(relativeVelPlane.z, Math.sqrt(Math.abs(soiVel.y*soiVel.y - relativeVelPlane.z*relativeVelPlane.z)));\n        soiVel = roderigues(soiVel, X_DIR, rotAngle1);\n        pPos = roderigues(pPos, X_DIR, rotAngle1);\n        pVel = roderigues(pVel, X_DIR, rotAngle1);\n\n        // Rotate about the z-axs to match the direction of the relative velocity (in the plane of the parking orbit)\n        const rotAngle2 = Math.atan2(relativeVelPlane.y, relativeVelPlane.x) - Math.atan2(soiVel.y, soiVel.x);\n        soiVel = roderigues(soiVel, Z_DIR, rotAngle2);\n        pPos = roderigues(pPos, Z_DIR, rotAngle2);\n        pVel = roderigues(pVel, Z_DIR, rotAngle2);\n\n        // Rotate back into the reference plane\n        soiVel = Kepler.rotateToInertialFromPerifocal(soiVel, parkOrbit);\n        pPos = Kepler.rotateToInertialFromPerifocal(pPos, parkOrbit);\n        pVel = Kepler.rotateToInertialFromPerifocal(pVel, parkOrbit);\n\n        // check error in periapsis height against parking orbit\n        const parkNu = Kepler.angleInOrbitPlane(pPos, parkOrbit);\n        const parkRadius = Kepler.distanceAtOrbitTrueAnomaly(parkNu, parkOrbit);\n        const err = periapsis - parkRadius;\n        return {err,  parkNu, e, soiNu, pPos, pVel}\n    }\n\n    // \"Oberth\" ejection/insertion\n    export function fastOberthDeparture(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, matchParkMo: boolean = true, soiPatchPosition: Vector3 = vec3(0,0,0)): Trajectory {\n        return fastOberthDepartureArrival(parkOrbit, parkBody, relativeVel, soiDate, true, matchParkMo, soiPatchPosition);\n    }\n\n    export function fastOberthArrival(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, matchParkMo: boolean = true, soiPatchPosition: Vector3 = vec3(0,0,0)): Trajectory {\n        return fastOberthDepartureArrival(parkOrbit, parkBody, relativeVel, soiDate, false, matchParkMo, soiPatchPosition);\n    }\n    \n    function fastOberthDepartureArrival(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, ejection: boolean, matchParkMo: boolean = true, soiPatchPosition: Vector3 = vec3(0,0,0)): Trajectory {\n        const c = ejection ? 1 : -1;\n        const mu = parkBody.stdGravParam;\n        const soi = parkBody.soi;\n        const soiSpeedSq = magSq3(relativeVel);\n\n        // set the slingshot radius\n        const periapsis = FlybyCalcs.minFlybyRadius(parkBody);\n\n        // incoming/outgoing orbit details (should be completely defined)\n        const hypSMA = 1 / (2 / soi - soiSpeedSq / mu);\n        const hypEcc    = 1 - periapsis / hypSMA;\n        const hypSLR    = hypSMA  * (1 - hypEcc  * hypEcc); \n        const hypNu     = c * Kepler.trueAnomalyAtDistance(soi, hypEcc,  hypSLR);   // true anomaly at SoI\n        const obrNu     = -c * Math.PI\n\n        const hypDelta  = Kepler.motionAngleAtTrueAnomaly(hypNu, hypEcc);           // angle of motion direction at SoI\n\n        const delta     = c * (hypDelta - obrNu);\n\n        // Find the true anomaly for the parking orbit that makes the Oberth orbit a half-ellipse\n        let parkNu = wrapAngle(Kepler.angleInOrbitPlane(relativeVel, parkOrbit) - c * delta);\n\n        const parkNuObj = (parkNu: number) => {\n            const parkPos = Kepler.positionAtTrueAnomaly(parkOrbit, parkNu);\n            const startPos = add3(parkPos, soiPatchPosition);\n            let nDir = normalize3(cross3(startPos, relativeVel));    // direction normal to the trajectory plane\n            if(nDir.z < 0) {\n                nDir = mult3(nDir, -1);\n            }\n            const deltaForNu = c === 1 ? counterClockwiseAngleInPlane(startPos, relativeVel, nDir) : // angle between incoming and outgoing velocity vectors (flyby angle)\n                                         counterClockwiseAngleInPlane(relativeVel, startPos, nDir) \n            return Math.abs(deltaForNu - delta);\n        }\n        parkNu = parkOrbit.eccentricity < 1 ? brentMinimize(parkNuObj, parkNu - Math.PI, parkNu + Math.PI) \n                                            : brentMinimize(parkNuObj, insertionTrueAnomaly(parkOrbit, parkBody), ejectionTrueAnomaly(parkOrbit, parkBody));\n\n        // set positions and speeds\n        const parkPos  = Kepler.positionAtTrueAnomaly(parkOrbit, parkNu);\n        const startPos = add3(parkPos, soiPatchPosition);\n        let nDir = normalize3(cross3(startPos, relativeVel));    // direction normal to the trajectory plane\n        if(nDir.z < 0) {\n            nDir = mult3(nDir, -1);\n        }\n\n        const apoapsis  = mag3(startPos);\n\n        const soiVelSq = magSq3(relativeVel);\n        const hypEnergy  = soiVelSq  / 2 - mu / soi;\n\n        const obrEcc    = (apoapsis - periapsis) / (periapsis + apoapsis);\n        const obrSMA    = periapsis / (1 - obrEcc);\n        const obrEnergy = -mu  / (2 * obrSMA) ;\n\n        const obrPeriapsisSpeed = Math.sqrt((obrEnergy + mu / periapsis) * 2); \n        const hypPeriapsisSpeed = Math.sqrt((hypEnergy + mu / periapsis) * 2); \n\n\n        // align the perifocal fram with the inertial frame\n        const rotInc = alignVectorsAngleAxis(Z_DIR, nDir);\n        const perifocalSoiDir = vec3(Math.cos(hypDelta), Math.sin(hypDelta), 0);\n        const tiltSoiDir = roderigues(perifocalSoiDir, rotInc.axis, rotInc.angle)\n        const rotArg = alignVectorsAngleAxis(tiltSoiDir, normalize3(relativeVel));\n\n        // results\n        const periapsisPos = roderigues(roderigues(mult3(X_DIR,periapsis), rotInc.axis, rotInc.angle), rotArg.axis, rotArg.angle);\n        const periapsisVelDir = roderigues(roderigues(Y_DIR, rotInc.axis, rotInc.angle), rotArg.axis, rotArg.angle);\n        const hypPeriapsisVel = mult3(periapsisVelDir, hypPeriapsisSpeed);\n        const obrPeriapsisVel = mult3(periapsisVelDir, obrPeriapsisSpeed);\n        const hypDuration = Math.abs(Kepler.trueAnomalyToDate(hypNu, hypEcc, Kepler.siderealPeriod(hypSMA, mu), 0, 0));     \n        const obrDuration = Math.abs(Kepler.trueAnomalyToDate(obrNu, obrEcc, Kepler.siderealPeriod(obrSMA, mu), 0, 0));\n\n        const periapsisDate = soiDate - c * hypDuration;\n        const obrDate = periapsisDate - c * obrDuration;\n\n        const hypPreState:  OrbitalState = {date: periapsisDate, pos: periapsisPos, vel: obrPeriapsisVel};\n        const hypPostState: OrbitalState = {date: periapsisDate, pos: periapsisPos, vel: hypPeriapsisVel};\n\n        const obrEpoch = matchParkMo ? Kepler.trueAnomalyToOrbitDate(parkNu, parkOrbit, obrDate - parkOrbit.siderealPeriod/2) : obrDate;\n        const adjustedSoiDate = soiDate + obrEpoch - obrDate;\n        hypPreState.date  = hypPreState.date + obrEpoch - obrDate;\n        hypPostState.date = hypPreState.date;\n\n        // orbits\n        const obrOrbit = Kepler.stateToOrbit(hypPreState, parkBody);\n        obrOrbit.meanAnomalyEpoch = Kepler.dateToMeanAnomaly(obrEpoch, obrOrbit.siderealPeriod, obrOrbit.meanAnomalyEpoch, obrOrbit.epoch);\n        obrOrbit.epoch = obrEpoch;\n        const hypOrbit = Kepler.stateToOrbit(hypPostState, parkBody);\n\n        // oberth maneuver states\n        const parkVel   = Kepler.velocityAtTrueAnomaly(parkOrbit, parkBody.stdGravParam, parkNu);\n        const obrVel    = Kepler.velocityAtTrueAnomaly(obrOrbit, parkBody.stdGravParam, obrNu);\n        const obrPreState: OrbitalState = {\n            date: obrDate,\n            pos:  startPos,\n            vel:  parkVel,\n        };\n        const obrPostState: OrbitalState = {\n            date: obrDate,\n            pos:  startPos,\n            vel:  obrVel,\n        }\n\n        // trajectory\n        if(c === 1) {\n            const obrManeuver = Kepler.maneuverFromOrbitalStates(obrPreState, obrPostState);\n            const hypManeuver = Kepler.maneuverFromOrbitalStates(hypPreState, hypPostState);\n            return {\n                orbits:             [obrOrbit, hypOrbit],\n                intersectTimes:     [obrOrbit.epoch, hypOrbit.epoch, adjustedSoiDate],\n                maneuvers:          [obrManeuver, hypManeuver],\n            }\n        } else {\n            const obrManeuver = Kepler.maneuverFromOrbitalStates(obrPostState, obrPreState);\n            const hypManeuver = Kepler.maneuverFromOrbitalStates(hypPostState, hypPreState);\n            return {\n                orbits:             [hypOrbit, obrOrbit],\n                intersectTimes:     [adjustedSoiDate, hypOrbit.epoch, obrOrbit.epoch],\n                maneuvers:          [hypManeuver, obrManeuver],\n            }\n        }\n    }\n\n    // Optimal ejection/insertion orbits similar to KSPTOT\n    // An important difference is that vSoI, velocity at SOI encounter/exit, is used instead of vInf\n\n    export function optimalDeparture(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, \n                                     matchParkMo: boolean = true, type: \"direct\" | \"oberth\" = \"direct\", soiPatchPosition: Vector3 = vec3(0,0,0)): Trajectory {\n        return optimalDepartureArrival(parkOrbit, parkBody, relativeVel, soiDate, true, matchParkMo, type ,soiPatchPosition);\n    }\n\n    export function optimalArrival(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number,  \n                                   matchParkMo: boolean = true, type: \"direct\" | \"oberth\" = \"direct\", soiPatchPosition: Vector3 = vec3(0,0,0)): Trajectory {\n        return optimalDepartureArrival(parkOrbit, parkBody, relativeVel, soiDate, false, matchParkMo, type, soiPatchPosition);\n    }\n\n    export function optimalDepartureArrival(parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, ejection: boolean,\n                                            matchParkMo: boolean = true, type: \"direct\" | \"oberth\" = \"direct\", soiPatchPosition: Vector3 = vec3(0, 0, 0)): Trajectory {\n        const c = ejection ? 1 : -1;\n        \n        // optimize the true anomaly of the parking orbit at the maneuver\n        // bounds for elliptical starting orbit\n        let minNu = -TWO_PI;\n        let maxNu = TWO_PI - Number.EPSILON;\n        if(type === \"direct\") {\n            const mu = parkBody.stdGravParam;\n            const soi = parkBody.soi;\n            const soiSpeedSq = magSq3(relativeVel);\n    \n            const a = 1 / (2 / soi - soiSpeedSq / mu);\n            const periapsis = parkOrbit.semiMajorAxis;\n            const relativeVelPlane = Kepler.rotateToPerifocalFromInertial(relativeVel, parkOrbit);\n\n            const {parkNu} = fastDepartureArrivalForPeriapsis(periapsis, parkOrbit, mu, soi, relativeVelPlane, soiSpeedSq, a, c);\n            minNu = parkNu - Math.PI;\n            maxNu = parkNu + Math.PI;\n        }else if(type === \"oberth\") {\n            const mu = parkBody.stdGravParam;\n            const soi = parkBody.soi;\n    \n            const periapsis = FlybyCalcs.minFlybyRadius(parkBody);\n    \n            const soiVelSq = magSq3(relativeVel);\n            const hypEnergy  = soiVelSq  / 2 - mu / soi;\n            const hypSMA = -mu / (2 * hypEnergy);  \n            const hypEcc    = 1 - periapsis / hypSMA;\n            const hypSLR    = hypSMA  * (1 - hypEcc  * hypEcc); \n            const hypNu     = Kepler.trueAnomalyAtDistance(soi, hypEcc,  hypSLR);       // true anomaly at SoI\n            const hypDelta  = Kepler.motionAngleAtTrueAnomaly(hypNu, hypEcc);           // angle of motion direction at SoI\n            const delta     = hypDelta + Math.PI;\n\n            const parkNu = wrapAngle(Kepler.angleInOrbitPlane(relativeVel, parkOrbit) - c * delta);\n            minNu = parkNu - Math.PI;\n            maxNu = parkNu + Math.PI;\n        }\n        // bounds for hyperbolic starting orbit\n        if(parkOrbit.eccentricity > 1) {\n            maxNu = ejectionTrueAnomaly(parkOrbit, parkBody) - 2 * Number.EPSILON;\n            minNu = -maxNu;\n        }\n\n        // console.log(minNu, maxNu)\n\n        const nuFun = type === \"direct\" ? directDepartArriveForTrueAnomaly : \n                      type === \"oberth\" ? oberthDepartArriveForTrueAnomaly :\n                      directDepartArriveForTrueAnomaly;\n\n        // objective export function for true anomaly optimization\n        function nuObjFun(nu: number) {\n            if(isNaN(nu) || nu === Infinity) {\n                console.log(nu)\n                throw Error(\"nu cannot be NaN\")\n            }\n            const {deltaV, err} = nuFun(nu, parkOrbit, parkBody, relativeVel, soiDate, c, matchParkMo, soiPatchPosition, false);\n            const obj = (deltaV * Math.exp(Math.min(100 * err, 10)))  // minimize delta v, and penalize direction mismatch from the intended excess velocity vector\n            return obj;\n        }\n\n        const nu = brentMinimize(nuObjFun, minNu, maxNu, 1e-4);\n        const res = nuFun(nu, parkOrbit, parkBody, relativeVel, soiDate, c, matchParkMo, soiPatchPosition, true);\n        \n        return res.trajectoryInfo\n    }\n\n    function directDepartArriveForTrueAnomaly(nu: number, parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, c: 1 | -1, \n                                              matchParkMo: boolean = true, soiPatchPosition: Vector3 = vec3(0,0,0), fullResult: boolean = true) {\n        const parkPos = add3(Kepler.positionAtTrueAnomaly(parkOrbit, nu), soiPatchPosition);\n        if(isNaN(parkPos.x)) {\n            throw Error(\"nu cannot be NaN\")\n        }\n        const {err, orbit} =  departArriveForPosition(parkPos, parkBody, relativeVel, soiDate, c, fullResult);\n\n        const epoch = matchParkMo ? Kepler.trueAnomalyToOrbitDate(nu, parkOrbit, orbit.epoch - parkOrbit.siderealPeriod/2) : orbit.epoch;\n        const adjustedSoiDate = soiDate + epoch - orbit.epoch;\n        orbit.epoch = epoch;\n\n        const preState = {\n            date: orbit.epoch,\n            pos:  Kepler.positionAtTrueAnomaly(parkOrbit, nu),\n            vel:  Kepler.velocityAtTrueAnomaly(parkOrbit, parkBody.stdGravParam, nu),\n        }\n        const postState = Kepler.orbitToStateAtDate(orbit, parkBody, orbit.epoch);\n\n        // console.log(mag3(sub3(preState.pos, postState.pos)))\n\n        let trajectoryInfo: Trajectory;\n        if(c === 1) {\n            const maneuver = Kepler.maneuverFromOrbitalStates(preState, postState);\n            trajectoryInfo = {\n                orbits:         [orbit],\n                intersectTimes: [orbit.epoch, adjustedSoiDate], \n                maneuvers:      [maneuver],\n            }\n        } else {\n            const maneuver = Kepler.maneuverFromOrbitalStates(postState, preState);\n            trajectoryInfo = {\n                orbits:         [orbit],\n                intersectTimes: [adjustedSoiDate, orbit.epoch],\n                maneuvers:      [maneuver],\n            }\n        }\n        const deltaV = trajectoryInfo.maneuvers[0].deltaVMag;\n\n        \n        return {deltaV, err, trajectoryInfo}\n    }\n\n    export function departArriveForPosition(parkPos: Vector3, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, c: 1 | -1, fullResult: boolean = true) {\n        // from a known position and a known velocity (at another position), we can calculate a, i, and lan\n        const mu = parkBody.stdGravParam;\n        const mr = mag3(parkPos);\n        const soi = parkBody.soi;\n\n        const hHat = normalize3(cross3(parkPos, relativeVel));\n        const n = cross3(Z_DIR, hHat);\n        const nMag = mag3(n);\n        const nHat = (nMag === 0) ? X_DIR : div3(n, nMag);\n\n        const a = 1 / (2 / soi - magSq3(relativeVel) / mu);\n        const i = acosClamped(hHat.z);\n        const lan = wrapAngle(copysign(1, nHat.y) * acosClamped(nHat.x));\n\n        // set bounds for eccentricity\n        // elliptical case\n        let eMax = 1 - 2 * Number.EPSILON;\n        let eMin = clamp(soi / a - 1 + Number.EPSILON, 0, eMax);\n        // hyperbolic case\n        if(a < 0) {\n            eMin = 1 + 2 * Number.EPSILON;\n            eMax = Math.max(1 - mr / a, mr / a - 1);\n            eMax = eMax === 1 ? 1 + 4 * Number.EPSILON : eMax;\n        }\n\n        // objective export function for eccentricity optimization\n        function eObjFun(e: number) {\n            if(isNaN(e)) {\n                return 2;\n            }\n            const {err} =  departArriveForEccentricity(e, a, lan, i, parkPos, mr, soi, mu, relativeVel, parkBody.id, c);\n            return err;\n        }\n\n        // Determine eccentricity (and argument of the periapsis, which depends on eccentricity) that ensure the correct excess velocity\n        const e = brentMinimize(eObjFun, eMin, eMax, 1e-6);\n        let {err, orbit} = departArriveForEccentricity(e, a, lan, i, parkPos, mr, soi, mu, relativeVel, parkBody.id, c);\n\n        if(fullResult) {\n            // Calculate the maneuver time, and consider it the orbit's epoch\n            const p = orbit.semiLatusRectum;\n            const mNu = c * Kepler.trueAnomalyAtDistance(mr, e, p);\n            const soiNu = c * Kepler.trueAnomalyAtDistance(soi, e, p);\n            const T = Kepler.siderealPeriod(a, mu);\n            const mM = Kepler.trueToMeanAnomaly(mNu, e);\n            const deltat = Kepler.trueAnomalyToDate(soiNu, e, T, mM, 0);\n            const mt = soiDate - deltat;\n\n            // Construct orbital objects and state vectors\n            orbit.meanAnomalyEpoch = mM;\n            orbit.epoch = mt;\n        }\n        return {err, orbit}\n    }\n\n    function departArriveForEccentricity(e: number, a: number, lan: number, i: number, parkPos: Vector3, mr: number, soi: number, mu: number, relativeVel: Vector3, orbiting: number, c: 1 | -1) {\n        const p = a * (1 - e * e);\n        const mNu = c * Kepler.trueAnomalyAtDistance(mr, e, p);\n        const soiNu = c * Kepler.trueAnomalyAtDistance(soi, e, p);\n\n        // determine arg that ensures that the optimized orbit intersects with the parking orbit at the provided point, parkPos \n        const arg = wrapAngle(Kepler.angleInPlane(parkPos, lan, i, 0.) - mNu);\n\n        const orbit: IOrbit = {\n            orbiting:           orbiting,\n            semiMajorAxis:      a,\n            eccentricity:       e,\n            inclination:        i,\n            ascNodeLongitude:   lan,\n            argOfPeriapsis:     arg,\n            meanAnomalyEpoch:   0.,     // does not affect the error or deltaV, and can be filled in later\n            epoch:              0.,     // does not affect the error or deltaV, and can be filled in later\n            semiLatusRectum:    p,\n            siderealPeriod:     Kepler.siderealPeriod(a, mu),\n        };\n\n        const soiVel = Kepler.velocityAtTrueAnomaly(orbit, mu, soiNu);\n\n        // calculate direction mismatch between the optimized orbit and the intended excess velocity\n        let err = 1 - dot3(normalize3(relativeVel), normalize3(soiVel))\n        if(isNaN(err)) {\n            err = 2;\n        }\n        console.log()\n        return {err, orbit}\n    }\n\n\n    // Oberth ejection/insertion (slingshot style)\n    export function oberthDepartArriveForTrueAnomaly(nu: number, parkOrbit: IOrbit, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, c: -1 | 1,\n                                                     matchParkMo: boolean = true, soiPatchPosition: Vector3 = vec3(0,0,0), fullResult: boolean = true) {\n        const parkPos = add3(Kepler.positionAtTrueAnomaly(parkOrbit, nu), soiPatchPosition);\n        const parkVel = Kepler.velocityAtTrueAnomaly(parkOrbit, parkBody.stdGravParam, nu);\n        \n        const {deltaV, obrPreState, obrPostState, hypPreState, hypPostState} = oberthDepartArriveForPosition(parkPos, parkVel, parkBody, relativeVel, soiDate, c, fullResult);\n\n        let trajectoryInfo: Trajectory = {orbits: [], intersectTimes: [], maneuvers: []};\n        if(fullResult) {\n            const obrEpoch = matchParkMo ? Kepler.trueAnomalyToOrbitDate(nu, parkOrbit, obrPreState.date - parkOrbit.siderealPeriod/2) : obrPreState.date;\n            const adjustedSoiDate = soiDate + obrEpoch - obrPreState.date;\n            hypPreState.date  = hypPreState.date + obrEpoch - obrPreState.date;\n            hypPostState.date = hypPreState.date;\n            obrPreState.date  = obrEpoch;\n            obrPostState.date = obrEpoch;\n\n            const obrOrbit = Kepler.stateToOrbit(hypPreState,  parkBody);\n            obrOrbit.meanAnomalyEpoch = Kepler.dateToMeanAnomaly(obrEpoch, obrOrbit.siderealPeriod, obrOrbit.meanAnomalyEpoch, obrOrbit.epoch);\n            obrOrbit.epoch = obrEpoch;\n            // const obrOrbit = Kepler.stateToOrbit(obrPostState, parkBody);\n            const hypOrbit = Kepler.stateToOrbit(hypPostState, parkBody);\n\n            if(c === 1) {\n                const obrManeuver = Kepler.maneuverFromOrbitalStates(obrPreState, obrPostState);\n                const hypManeuver = Kepler.maneuverFromOrbitalStates(hypPreState, hypPostState);\n                trajectoryInfo = {\n                    orbits:             [obrOrbit, hypOrbit],\n                    intersectTimes:     [obrOrbit.epoch, hypOrbit.epoch, adjustedSoiDate],\n                    maneuvers:          [obrManeuver, hypManeuver],\n                }\n            } else {\n                const obrManeuver = Kepler.maneuverFromOrbitalStates(obrPostState, obrPreState);\n                const hypManeuver = Kepler.maneuverFromOrbitalStates(hypPostState, hypPreState);\n                trajectoryInfo = {\n                    orbits:             [hypOrbit, obrOrbit],\n                    intersectTimes:     [adjustedSoiDate, hypOrbit.epoch, obrOrbit.epoch],\n                    maneuvers:          [hypManeuver, obrManeuver],\n                }\n            }\n        }\n\n        return {deltaV, err: 0, trajectoryInfo}\n    }\n\n\n    export function oberthDepartArriveForPosition(parkPos: Vector3, parkVel: Vector3, parkBody: IOrbitingBody, relativeVel: Vector3, soiDate: number, c: 1 | -1, fullResult: boolean = true) {\n        const mu = parkBody.stdGravParam;\n        const soi = parkBody.soi;\n\n        const mr = mag3(parkPos);\n        const parkPosDir = div3(parkPos, mr);\n\n        const soiVelSq = magSq3(relativeVel);\n        const soiDir = div3(relativeVel, Math.sqrt(soiVelSq));\n        const hypEnergy  = soiVelSq  / 2 - mu / soi;\n        const hypSMA = -mu / (2 * hypEnergy);  \n\n        let nDir = normalize3(cross3(parkPosDir, soiDir));                              // direction normal to the trajectory plane\n        if(nDir.z < 0) {\n            nDir = mult3(nDir, -1);\n        }\n        const delta = c === 1 ? counterClockwiseAngleInPlane(parkPosDir, soiDir, nDir) : // angle between incoming and outgoing velocity vectors (flyby angle)\n                                counterClockwiseAngleInPlane(soiDir, parkPosDir, nDir)  \n        \n        if(isNaN(delta)) {\n            console.log(parkPosDir, soiDir, nDir)\n        }\n\n        const denominator = (periapsis: number) => {\n            const hypEcc    = 1 - periapsis / hypSMA;\n            const hypSLR    = hypSMA  * (1 - hypEcc  * hypEcc); \n            const hypNu     = c * Kepler.trueAnomalyAtDistance(soi, hypEcc,  hypSLR);   // true anomaly at SoI\n            const hypDelta  = Kepler.motionAngleAtTrueAnomaly(hypNu, hypEcc);           // angle of motion direction at SoI\n            const obrNu     = wrapAngle(hypDelta - c * delta, -Math.PI * (c + 1));      // true anomaly at Oberth maneuver start\n            const denom    = (periapsis - mr * Math.cos(obrNu));\n            return denom;\n        }\n\n        // define the search space by eliminating periapses that result in negative eccentricity\n        let minPeriapsis = FlybyCalcs.minFlybyRadius(parkBody);\n        const minDenomPeriapsis = brentMinimize(denominator, minPeriapsis, mr);\n        const minDenom = denominator(minDenomPeriapsis)\n        if(minDenom < 0) {\n            minPeriapsis = brentRootFind(denominator, minDenomPeriapsis, mr) + 1;\n        }\n\n        // require that the incoming and outgoing orbits intersect at their periapses.\n        // find the periapsis height that gives the correct flyby angle at the lowest deltaV\n        const objective = (periapsis: number, fullResult: boolean = false) => {\n            const hypEcc    = 1 - periapsis / hypSMA;\n            const hypSLR    = hypSMA  * (1 - hypEcc  * hypEcc); \n            const hypNu     = c * Kepler.trueAnomalyAtDistance(soi, hypEcc,  hypSLR);   // true anomaly at SoI\n            const hypDelta  = Kepler.motionAngleAtTrueAnomaly(hypNu, hypEcc);           // angle of motion direction at SoI\n            const obrNu     = wrapAngle(hypDelta - c * delta, -Math.PI * (c + 1));      // true anomaly at Oberth maneuver start\n            const obrEcc    = (mr - periapsis) / (periapsis - mr * Math.cos(obrNu));\n            const obrSMA    = periapsis / (1 - obrEcc);\n            const obrEnergy = -mu  / (2 * obrSMA) ;\n\n            const obrPeriapsisSpeed = Math.sqrt((obrEnergy + mu / periapsis) * 2); \n            const hypPeriapsisSpeed = Math.sqrt((hypEnergy + mu / periapsis) * 2); \n\n\n            // align the perifocal fram with the inertial frame\n            const rotInc = alignVectorsAngleAxis(Z_DIR, nDir);\n            const perifocalSoiDir = vec3(Math.cos(hypDelta), Math.sin(hypDelta), 0);\n            const tiltSoiDir = roderigues(perifocalSoiDir, rotInc.axis, rotInc.angle)\n            const rotArg = alignVectorsAngleAxis(tiltSoiDir, soiDir);\n\n            // const diff = dot3(roderigues(perifocalParkDir, axis, angle), parkPosDir);\n            // if(diff < 0.95) {\n            //     console.log(axis, angle)\n            // }\n\n            // velocity of the Oberth maneuver at the intersect with the parking orbit\n            const obrSpeed = Math.sqrt((obrEnergy + mu / mr) * 2);\n            const perifocalObrDir = Kepler.motionDirectionAtTrueAnomaly(obrNu, obrEcc);\n            const obrDir = roderigues(roderigues(perifocalObrDir, rotInc.axis, rotInc.angle), rotArg.axis, rotInc.angle);\n            const obrVel = mult3(obrDir, obrSpeed);\n\n            // results\n            const deltaV = Math.abs(obrPeriapsisSpeed - hypPeriapsisSpeed) + mag3(sub3(obrVel, parkVel));\n            let periapsisPos:    Vector3 = vec3(0,0,0);     // store useless values during optimization\n            let hypPeriapsisVel: Vector3 = vec3(0,0,0);     \n            let obrPeriapsisVel: Vector3 = vec3(0,0,0);\n            let hypDuration: number = 0;\n            let obrDuration: number = 0;\n            if(fullResult) {    // only prepare the full info outisde of the optimization loop, since only deltaV is optimized\n                periapsisPos = roderigues(roderigues(mult3(vec3(1,0,0),periapsis), rotInc.axis, rotInc.angle), rotArg.axis, rotArg.angle);\n                const periapsisVelDir = roderigues(roderigues(vec3(0,1,0), rotInc.axis, rotInc.angle), rotArg.axis, rotArg.angle);\n                hypPeriapsisVel = mult3(periapsisVelDir, hypPeriapsisSpeed);\n                obrPeriapsisVel = mult3(periapsisVelDir, obrPeriapsisSpeed);\n                hypDuration = Math.abs(Kepler.trueAnomalyToDate(hypNu, hypEcc, Kepler.siderealPeriod(hypSMA, mu), 0, 0));     \n                obrDuration = Math.abs(Kepler.trueAnomalyToDate(obrNu, obrEcc, Kepler.siderealPeriod(obrSMA, mu), 0, 0));\n            }\n\n            if(isNaN(deltaV)) {\n                console.log(parkBody.name, mr, minPeriapsis, denominator(mr), denominator(minPeriapsis));\n                console.log(periapsis, (mr - periapsis), (periapsis - mr * Math.cos(obrNu)), delta, hypDelta);\n                // console.log(mu, mr, periapsis, obrNu, obrEcc, obrSMA, obrEnergy, obrPeriapsisSpeed, obrSpeed);\n            }\n\n            return {\n                deltaV,\n                obrVel,\n                periapsisPos,\n                hypPeriapsisVel,\n                obrPeriapsisVel,\n                hypDuration,\n                obrDuration,\n            };\n        }\n        const periapsis = brentMinimize((p: number) => objective(p).deltaV, minPeriapsis, mr, 1e-8)\n        const {deltaV, obrVel, periapsisPos, hypPeriapsisVel, obrPeriapsisVel, hypDuration, obrDuration} = objective(periapsis, fullResult);\n\n        const periapsisDate = soiDate - c * hypDuration;\n        const obrDate = periapsisDate - c * obrDuration;\n\n        const obrPreState:  OrbitalState = {date: obrDate,       pos: parkPos,      vel: parkVel};\n        const obrPostState: OrbitalState = {date: obrDate,       pos: parkPos,      vel: obrVel};\n        const hypPreState:  OrbitalState = {date: periapsisDate, pos: periapsisPos, vel: obrPeriapsisVel};\n        const hypPostState: OrbitalState = {date: periapsisDate, pos: periapsisPos, vel: hypPeriapsisVel};\n\n        return {deltaV, obrPreState, obrPostState, hypPreState, hypPostState};\n    }\n\n\n    // At the SoI boundary...\n\n    function patchTrueAnomaly(orb: IOrbit, attractor: IOrbitingBody, c: 1 | -1) {\n        return c * Kepler.trueAnomalyAtDistance(attractor.soi, orb.eccentricity, orb.semiLatusRectum)\n    }\n\n    export function ejectionTrueAnomaly(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchTrueAnomaly(orb, attractor, 1)\n    }\n\n    export function insertionTrueAnomaly(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchTrueAnomaly(orb, attractor, -1)\n    }\n\n\n    function patchDate(orb: IOrbit, attractor: IOrbitingBody, c: 1 | -1) {\n        let tMin: number | undefined = undefined;\n        // take care to get correct time for elliptical (periodic) orbits\n        if(orb.eccentricity < 1) {\n            tMin = c === 1 ? orb.epoch : orb.epoch - orb.siderealPeriod;\n        }\n        return Kepler.trueAnomalyToDate(patchTrueAnomaly(orb, attractor, c), orb.eccentricity, orb.siderealPeriod, orb.meanAnomalyEpoch, orb.epoch, tMin)\n    }\n\n    export function ejectionDate(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchDate(orb, attractor, 1)\n    }\n\n    export function insertionDate(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchDate(orb, attractor, -1)\n    }\n\n\n    function patchPosition(orb: IOrbit, attractor: IOrbitingBody, c: 1 | -1) {\n        return Kepler.positionAtTrueAnomaly(orb, patchTrueAnomaly(orb, attractor, c))\n    }\n\n    export function ejectionPosition(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchPosition(orb, attractor, 1)\n    }\n\n    export function insertionPosition(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchPosition(orb, attractor, -1)\n    }\n\n\n    function patchVelocity(orb: IOrbit, attractor: IOrbitingBody, c: 1 | -1) {\n        return Kepler.velocityAtTrueAnomaly(orb, attractor.stdGravParam, patchTrueAnomaly(orb, attractor, c))\n    }\n\n    export function ejectionVelocity(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchVelocity(orb, attractor, 1)\n    }\n\n    export function insertionVelocity(orb: IOrbit, attractor: IOrbitingBody) {\n        return patchPosition(orb, attractor, -1)\n    }\n}\n\nexport default DepartArrive","import Kepler from \"./kepler\";\nimport DepartArrive from \"./departarrive\";\nimport { lerp, vec3, magSq3, div3, normalize3, cross3, dot3, acosClamped, roderigues, alignVectorsAngleAxis, wrapAngle } from \"./math\";\nimport { brentMinimize } from \"./optim\";\n\nnamespace FlybyCalcs {\n    export function minFlybyRadius(body: IOrbitingBody) {\n        return body.radius +body.atmosphereHeight;\n    }\n\n    export function maxFlybyRadius(body: IOrbitingBody) {\n        return body.soi;\n    }\n\n    export function legDurationBounds(orb1: IOrbit, orb2: IOrbit, attractor: ICelestialBody) {\n        const meanSMA = 0.5 * (orb1.semiMajorAxis + orb2.semiMajorAxis);\n        const midPeriod = Kepler.siderealPeriod(meanSMA, attractor.stdGravParam);\n        return {lb: midPeriod / 25, ub: midPeriod * 2}\n    }\n\n    export function flybyParameters({velIn, velOut, body, time}: FlybyInputs): FlybyParams {\n        const mu = body.stdGravParam;\n        const soi = body.soi;\n\n        const inVelSq = magSq3(velIn);\n        const outVelSq = magSq3(velOut);\n        const inDir = div3(velIn, Math.sqrt(inVelSq));\n        const outDir = div3(velOut, Math.sqrt(outVelSq));\n\n        const inEnergy  = inVelSq  / 2 - mu / soi; // account for gravitational potential energy as well as\n        const outEnergy = outVelSq / 2 - mu / soi; // kinetic energy.\n        const inSMA  = -mu / (2 * inEnergy);  \n        const outSMA = -mu / (2 * outEnergy);  \n\n        const hDir = normalize3(cross3(inDir, outDir));     // direction of angular moment vector, normal to the flyby plane\n        const delta = acosClamped(dot3(inDir, outDir));     // angle between incoming and outgoing velocity vectors (flyby angle)\n\n        // require that the incoming and outgoing orbits intersect at their periapses.\n        // find the periapsis height that gives the correct flyby angle\n        const objective = (periapsis: number) => {\n            const inEcc  = 1 - periapsis / inSMA;\n            const outEcc = 1 - periapsis / outSMA;\n            const inSLR  = inSMA  * (1 - inEcc  * inEcc); \n            const outSLR = outSMA * (1 - outEcc * outEcc);\n            const inNu   = -Kepler.trueAnomalyAtDistance(soi, inEcc,  inSLR);     // true anomaly at encounter\n            const outNu  =  Kepler.trueAnomalyAtDistance(soi, outEcc, outSLR);    // true anomaly at escape\n\n            const deltaIn  = Kepler.motionAngleAtTrueAnomaly(inNu,  inEcc);\n            const deltaOut = Kepler.motionAngleAtTrueAnomaly(outNu, outEcc);\n            const obj = Math.abs(delta - wrapAngle(deltaOut - deltaIn))\n            return isNaN(obj) ? Math.PI : obj;\n        }\n        const periapsis = brentMinimize(objective, minFlybyRadius(body), maxFlybyRadius(body), 1e-8)\n        const error = objective(periapsis);\n\n        const inEcc  = 1 - periapsis / inSMA;\n        const outEcc = 1 - periapsis / outSMA;\n        \n        const periapsisSpeedIn  = Math.sqrt((inEnergy  + mu / periapsis) * 2); \n        const periapsisSpeedOut = Math.sqrt((outEnergy + mu / periapsis) * 2);\n        const deltaV = Math.abs(periapsisSpeedOut - periapsisSpeedIn);    \n        // console.log(deltaV)\n\n        return {\n            inSemiMajorAxis:    inSMA,\n            inEccentricity:     inEcc,\n            inDirection:        inDir,\n            outSemiMajorAxis:   outSMA,\n            outEccentricity:    outEcc,\n            outDirection:       outDir,\n            normalDirection:    hDir,\n            deltaV,\n            error,\n            time,\n        }\n    }\n\n    export function flybyFromParameters(params: FlybyParams, body: IOrbitingBody): Trajectory {\n        const soi = body.soi;\n        const mu = body.stdGravParam;\n        \n        const inSMA  = params.inSemiMajorAxis;\n        const outSMA = params.outSemiMajorAxis;\n        const inEcc  = params.inEccentricity;\n        // const outEcc = params.outEccentricity;\n\n        const periapsis = inSMA * (1 - inEcc);\n\n        const inSLR  = inSMA  * (1 - inEcc  * inEcc); \n        const inNu = -Kepler.trueAnomalyAtDistance(soi, inEcc,  inSLR);\n        const inPerifocalDirection  = Kepler.motionDirectionAtTrueAnomaly(inNu,  inEcc);\n\n        const {axis, angle} = alignVectorsAngleAxis(inPerifocalDirection, params.inDirection);\n\n        const periapsisPos = roderigues(vec3(periapsis, 0, 0), axis, angle);\n\n        const inPeriapsisSpeed  = Math.sqrt(mu * (2 / periapsis - 1 / inSMA));\n        const outPeriapsisSpeed = Math.sqrt(mu * (2 / periapsis - 1 / outSMA));\n\n        const inPeriapsisVel  = roderigues(vec3(0, inPeriapsisSpeed,  0), axis, angle);\n        const outPeriapsisVel = roderigues(vec3(0, outPeriapsisSpeed, 0), axis, angle);\n\n        const inPeriapsisState  = {date: params.time, pos: periapsisPos, vel: inPeriapsisVel};\n        const outPeriapsisState = {date: params.time, pos: periapsisPos, vel: outPeriapsisVel};\n\n        const inOrbit  = Kepler.stateToOrbit(inPeriapsisState,  body);\n        const outOrbit = Kepler.stateToOrbit(outPeriapsisState, body);\n        const maneuver = Kepler.maneuverFromOrbitalStates(inPeriapsisState, outPeriapsisState);\n        \n        const inDate  = DepartArrive.insertionDate(inOrbit, body);\n        const outDate = DepartArrive.ejectionDate(outOrbit, body);\n\n        const trajectory: Trajectory = {\n            orbits:         [inOrbit, outOrbit],\n            intersectTimes: [inDate, params.time, outDate],\n            maneuvers:      [maneuver],\n        };\n\n        return trajectory;\n    }\n\n    export function multiFlybyInputsFromAgent(agent: Agent, inputs: MultiFlybySearchInputs): MultiFlybyInputs {\n        const startDate = lerp(inputs.startDateMin, inputs.startDateMax, agent[0]);\n        const flightTimes: number[] = [];\n        for(let j=0; j<agent.length-1; j++) {\n            let ft = lerp(inputs.flightTimesMax[j], inputs.flightTimesMin[j], agent[j+1]);\n            flightTimes.push(ft);\n        }\n        return  {\n            system:                 inputs.system,\n            startOrbit:             inputs.startOrbit,\n            endOrbit:               inputs.endOrbit,\n            flybyIdSequence:        inputs.flybyIdSequence,\n            startDate,\n            flightTimes,\n            ejectionInsertionType:  inputs.ejectionInsertionType,\n            planeChange:            inputs.planeChange,\n            matchStartMo:           inputs.matchStartMo,\n            matchEndMo:             inputs.matchEndMo,\n            noInsertionBurn:        inputs.noInsertionBurn,\n        };\n    }\n}\n\nexport default FlybyCalcs;","import { TWO_PI, HALF_PI, X_DIR, Z_DIR, copysign, acosClamped, wrapAngle, vec3, magSq3, mag3, sub3, div3, mult3, dot3, cross3, zxz, normalize3 } from \"./math\"\nimport { newtonRootSolve } from \"./optim\"\n\nnamespace Kepler {\n    // export function orbitElementsFromOrbitData(orbit: IOrbit): OrbitalElements {  \n    //     const p = (orbit.semiLatusRectum) ? orbit.semiLatusRectum : orbit.semiMajorAxis * (1 - orbit.eccentricity * orbit.eccentricity)\n    //     return {\n    //         orbiting:           orbit.orbiting,\n    //         semiMajorAxis:      orbit.semiMajorAxis,\n    //         eccentricity:       orbit.eccentricity,\n    //         inclination:        orbit.inclination,\n    //         argOfPeriapsis:     orbit.argOfPeriapsis,\n    //         ascNodeLongitude:   orbit.ascNodeLongitude,\n    //         meanAnomalyEpoch:   orbit.meanAnomalyEpoch,\n    //         epoch:              orbit.epoch,\n    //         semiLatusRectum:    p,\n    //     };\n    // }\n\n    export function orbitFromElements(elements: OrbitalElements, attractor: ICelestialBody): IOrbit {\n        const p = (elements.semiLatusRectum) ? elements.semiLatusRectum : elements.semiMajorAxis * (1 - elements.eccentricity * elements.eccentricity)\n        const T = (elements.siderealPeriod) ? elements.siderealPeriod : siderealPeriod(elements.semiMajorAxis, attractor.stdGravParam)\n        return {\n            orbiting:           attractor.id,\n            semiMajorAxis:      elements.semiMajorAxis,\n            eccentricity:       elements.eccentricity,\n            inclination:        elements.inclination,\n            argOfPeriapsis:     elements.argOfPeriapsis,\n            ascNodeLongitude:   elements.ascNodeLongitude,\n            meanAnomalyEpoch:   elements.meanAnomalyEpoch,\n            epoch:              elements.epoch,\n            semiLatusRectum:    p,\n            siderealPeriod:     T,\n        }\n    }\n\n    export function maneuverFromOrbitalStates(preState: OrbitalState, postState: OrbitalState): Maneuver {\n        const deltaV = sub3(postState.vel, preState.vel);\n        const deltaVMag = mag3(deltaV)\n        return {\n            preState:   preState,\n            postState:  postState,\n            deltaV:     deltaV,\n            deltaVMag:  deltaVMag,\n        }\n    }\n\n    export function maneuverToComponents(maneuver: Maneuver) {\n        const progradeDir = normalize3(maneuver.preState.vel);\n        const normalDir   = normalize3(cross3(maneuver.preState.pos, progradeDir));\n        const radialDir   = cross3(normalDir, progradeDir);\n\n        return {\n            prograde: dot3(maneuver.deltaV, progradeDir),\n            normal:   dot3(maneuver.deltaV, normalDir),\n            radial:   dot3(maneuver.deltaV, radialDir),\n        }\n    }\n\n    export function rotateToInertialFromPerifocal(x: Vector3, orbit: OrbitalElements): Vector3 {\n        const lan = orbit.ascNodeLongitude;\n        const i = orbit.inclination;\n        const arg = orbit.argOfPeriapsis;\n        return zxz(x, lan, i, arg)\n    }\n\n    export function rotateToPerifocalFromInertial(x: Vector3, orbit: OrbitalElements): Vector3 {\n        const lan = orbit.ascNodeLongitude;\n        const i = orbit.inclination;\n        const arg = orbit.argOfPeriapsis;\n        return zxz(x, -arg, -i, -lan)\n    }\n\n    export function siderealPeriod(a: number, mu: number) {\n        return TWO_PI * Math.sqrt(Math.abs(a*a*a) / mu)\n    }\n\n    export function flightPathAngleAtTrueAnomaly(nu: number, e: number) {\n        return Math.atan(e*Math.sin(nu) / (1 + e*Math.cos(nu)))\n    }\n\n    export function motionAngleAtTrueAnomaly(nu: number, e: number): number {\n        return nu + HALF_PI - flightPathAngleAtTrueAnomaly(nu, e);\n    }\n\n    export function motionDirectionAtTrueAnomaly(nu: number, e: number): Vector3 {\n        const angle = motionAngleAtTrueAnomaly(nu, e);\n        return vec3(Math.cos(angle), Math.sin(angle), 0);\n    }\n\n    export function distanceAtTrueAnomaly(nu: number, e: number, p: number) {\n        return p / (1 + e*Math.cos(nu))\n    }\n\n    export function distanceAtOrbitTrueAnomaly(nu: number, orbit: IOrbit) {\n        return distanceAtTrueAnomaly(nu, orbit.eccentricity, orbit.semiLatusRectum)\n    }\n\n    export function trueAnomalyAtDistance(r: number, e:number, p: number) {\n        return acosClamped((p/r - 1) / e)\n    }\n\n    export function dateToMeanAnomaly(date: number, T: number, M0: number, epoch: number) {\n        return M0 + TWO_PI * (date - epoch) / T;\n    }\n\n    export function meanAnomalyToDate(M: number, T: number, M0: number, epoch: number, tMin: number | undefined = undefined) {\n        let t = epoch + (M - M0) * T / TWO_PI;\n        if(tMin) {\n            const nPeriods = Math.ceil((tMin - t)/T);\n            t += T * nPeriods;\n        }\n        return t        \n    }\n\n    export function trueToMeanAnomaly(nu: number, e: number) {\n        // The parabolic case (e = 1) is note implemented\n        if(e < 1) {\n            const E = 2 * Math.atan2(Math.sin(nu/2)*Math.sqrt(1-e), Math.cos(nu/2)*Math.sqrt(1+e));\n            return E - e * Math.sin(E);\n        } else {\n            const H = 2 * Math.atanh(Math.tan(nu/2)*Math.sqrt((e-1)/(e+1)));\n            return e * Math.sinh(H) - H;\n        }\n    }\n\n    export function meanToTrueAnomaly(M: number, e: number){\n        // Solving Kepler's equation for eccentric anomaly with Newton's method.\n        if(e < 1) {\n            const E = newtonRootSolve(\n                E => E - e * Math.sin(E) - M,\n                E => 1 - e * Math.cos(E),\n                M,\n                1e-12\n            );\n            return 2 * Math.atan(Math.sqrt((1 + e)/(1 - e)) * Math.tan(E * 0.5));\n        } else {\n            const H0 = Math.abs(M) > 4*Math.PI ? Math.sign(M) * 4*Math.PI : M;\n            const H = newtonRootSolve(\n                H => e * Math.sinh(H) - H - M,\n                H => e * Math.cosh(H) - 1,\n                H0,\n                1e-12\n            );\n            return 2 * Math.atan(Math.sqrt((e + 1)/(e - 1)) * Math.tanh(H * 0.5));\n        }\n    }\n\n    export function dateToTrueAnomaly(date: number, e: number, T: number, M0: number, epoch: number) {\n        const M = dateToMeanAnomaly(date, T, M0, epoch);\n        return meanToTrueAnomaly(M, e)\n    }\n\n    export function trueAnomalyToDate(nu: number, e: number, T: number, M0: number, epoch: number, tMin: number = 0) {\n        const M = trueToMeanAnomaly(nu, e)\n        return meanAnomalyToDate(M, T, M0, epoch, tMin)\n    }\n\n    export function dateToOrbitTrueAnomaly(date: number, orbit: IOrbit) {\n        return dateToTrueAnomaly(date, orbit.eccentricity, orbit.siderealPeriod, orbit.meanAnomalyEpoch, orbit.epoch)\n    }\n\n    export function trueAnomalyToOrbitDate(nu: number, orbit: IOrbit, tMin: number = orbit.epoch) {\n        return trueAnomalyToDate(nu, orbit.eccentricity, orbit.siderealPeriod, orbit.meanAnomalyEpoch, orbit.epoch, tMin)\n    }\n\n    export function angleInPlane(pos: Vector3, lan: number, i: number, arg: number) {\n        const perifocalPos = zxz(pos, -arg, -i, -lan);\n        return Math.atan2(perifocalPos.y, perifocalPos.x);\n    }\n\n    export function angleInOrbitPlane(pos: Vector3, orbit: OrbitalElements) {\n        return angleInPlane(pos, orbit.ascNodeLongitude, orbit.inclination, orbit.argOfPeriapsis)\n    }\n\n    export function positionAtTrueAnomaly(orbit: IOrbit, nu: number): Vector3 {\n        const e = orbit.eccentricity;\n        const i = orbit.inclination;\n        const lan = orbit.ascNodeLongitude;\n        const arg = orbit.argOfPeriapsis;\n        const p = orbit.semiLatusRectum;\n\n        const r = distanceAtTrueAnomaly(nu, e, p);\n        const perifocalPos = vec3(r*Math.cos(nu), r*Math.sin(nu), 0);\n        const pos = zxz(perifocalPos, lan, i, arg);\n        return pos\n    }\n\n    export function velocityAtTrueAnomaly(orbit: IOrbit, mu: number, nu: number): Vector3 {\n        const a = orbit.semiMajorAxis;\n        const e = orbit.eccentricity;\n        const i = orbit.inclination;\n        const lan = orbit.ascNodeLongitude;\n        const arg = orbit.argOfPeriapsis;\n        const p = orbit.semiLatusRectum;\n\n        const r = distanceAtTrueAnomaly(nu, e, p);\n        const v = Math.sqrt(mu * (2/r - 1/a));\n\n        const perifocalVel = mult3(motionDirectionAtTrueAnomaly(nu, e), v);\n        const vel = zxz(perifocalVel, lan, i, arg);\n        return vel\n    }\n\n    export function orbitToPositionAtDate(orbit: IOrbit, date: number): Vector3 {\n        const e = orbit.eccentricity;\n        const M0 = orbit.meanAnomalyEpoch;\n        const epoch = orbit.epoch;\n        const T = orbit.siderealPeriod;\n\n        const nu = dateToTrueAnomaly(date, e, T, M0, epoch);\n        return positionAtTrueAnomaly(orbit, nu)\n    }\n\n    export function orbitToVelocityAtDate(orbit: IOrbit, attractor: ICelestialBody, date: number): Vector3 {\n        const e = orbit.eccentricity;\n        const M0 = orbit.meanAnomalyEpoch;\n        const epoch = orbit.epoch;\n        const T = orbit.siderealPeriod;\n\n        const mu = attractor.stdGravParam;\n\n        const nu = dateToTrueAnomaly(date, e, T, M0, epoch);\n        return velocityAtTrueAnomaly(orbit, mu, nu)\n    }\n\n    export function orbitToStateAtDate(orbit: IOrbit, attractor: ICelestialBody, date: number): OrbitalState {\n        const e = orbit.eccentricity;\n        const M0 = orbit.meanAnomalyEpoch;\n        const epoch = orbit.epoch;\n        const T = orbit.siderealPeriod;\n        \n        const mu = attractor.stdGravParam;\n\n        const nu = dateToTrueAnomaly(date, e, T, M0, epoch);\n        const pos = positionAtTrueAnomaly(orbit, nu);\n        const vel = velocityAtTrueAnomaly(orbit, mu, nu);\n\n        return {date, pos, vel}\n    }\n\n    export function stateToOrbit(state: OrbitalState, attractor: ICelestialBody) : IOrbit {\n        const nullEps = 1e-12;\n        \n        const mu = attractor.stdGravParam;\n        \n        const pos = state.pos;\n        const vel = state.vel;\n        const r = mag3(pos);\n        const v2 = magSq3(vel);\n\n        const t = state.date\n\n        // Semi-major Axis\n        const a = 1 / (2/r - v2/mu);\n\n        // Momentum\n        const h = cross3(pos, vel);\n        \n        // Inclination\n        const i = acosClamped(h.z / mag3(h));\n\n        // Eccentricity vector (points toward periapsis)\n        const eVec = sub3(div3(cross3(vel, h), mu), div3(pos, r));\n        let e = mag3(eVec);\n        let eHat = div3(eVec, e);\n        if(e <=nullEps) {\n            eHat = X_DIR;\n            e = 0;\n        }\n\n        // Vector pointing to the ascending node\n        const nVec = cross3(Z_DIR, h);\n        let n = mag3(nVec);\n        let nHat = div3(nVec, n);\n        if(n <= nullEps) {\n            nHat = eHat;\n            n = 0;\n        }\n\n        // Longitude of the ascending node\n        const lan = wrapAngle(copysign(acosClamped(nHat.x), nHat.y), 0)\n        \n        // Argument of the periapsis\n        const arg = wrapAngle(copysign(acosClamped(dot3(nHat, eHat)), eHat.z), 0)\n\n        // True anomaly\n        const nu = wrapAngle(angleInPlane(pos, lan, i, arg), 0);\n\n        // Mean anomaly\n        const M = trueToMeanAnomaly(nu, e);\n\n        // Semi-latus rectum\n        const p = a * (1 - e*e);\n\n        // Orbital period\n        const T = siderealPeriod(a, mu)\n\n        return {\n            orbiting:               attractor.id,\n            semiMajorAxis:          a,\n            eccentricity:           e,\n            inclination:            i,\n            ascNodeLongitude:       lan,\n            argOfPeriapsis:         arg,\n            meanAnomalyEpoch:       M,\n            epoch:                  t,\n            semiLatusRectum:        p,\n            siderealPeriod:         T,\n        }\n    }\n}\n\nexport default Kepler","// Includes a direct port to TypeScript of ESA's Lambert problem solver\n// from : https://github.com/esa/pykep/blob/master/src/lambert_problem.cpp\n// extended from original port by krafpy to cover multiple revolutions\n// from : \n\n/*****************************************************************************\n *   Copyright (C) 2004-2018 The pykep development team,                     *\n *   Advanced Concepts Team (ACT), European Space Agency (ESA)               *\n *                                                                           *\n *   https://gitter.im/esa/pykep                                             *\n *   https://github.com/esa/pykep                                            *\n *                                                                           *\n *   act@esa.int                                                             *\n *                                                                           *\n *   This program is free software; you can redistribute it and/or modify    *\n *   it under the terms of the GNU General Public License as published by    *\n *   the Free Software Foundation; either version 2 of the License, or       *\n *   (at your option) any later version.                                     *\n *                                                                           *\n *   This program is distributed in the hope that it will be useful,         *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *   GNU General Public License for more details.                            *\n *                                                                           *\n *   You should have received a copy of the GNU General Public License       *\n *   along with this program; if not, write to the                           *\n *   Free Software Foundation, Inc.,                                         *\n *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.               *\n *****************************************************************************/\n\nimport { TWO_PI, mag3, normalize3, add3, sub3, div3, mult3, cross3, dot3, wrapAngle} from \"./math\"\n\nnamespace Lambert\n{\n    /**\n     * Solves the Lambert's problem considering 0 revolutions and prograde direction only.\n     * @param r1vec The start position in space\n     * @param r2vec The end position in space\n     * @param tof The time of flight between the two positions\n     * @param attractor The attractor body\n     * @param retro Designates the orbit as retrograde if true.\n     * @param left Uses the left branch for the multiple revolutions problem if true\n     * @returns The velocities at each point\n     */\n    export function solve(r1vec: Vector3, r2vec: Vector3, tof: number, attractor: ICelestialBody, revs: number = 0, retro: boolean = false, left: boolean = false) {\n        const mu = attractor.stdGravParam;\n\n        // Calculating lambda and T\n        const r1 = mag3(r1vec);\n        const r2 = mag3(r2vec);\n        const c = mag3(sub3(r2vec, r1vec));\n\n        const s = 0.5 * (r1 + r2 + c);\n\n        const ir1 = div3(r1vec, r1);\n        const ir2 = div3(r2vec, r2);\n\n        const ih = normalize3(cross3(ir1, ir2));\n\n        const lambda2 = 1 - c / s;\n        let lambda = Math.sqrt(lambda2);\n         let it1: Vector3, it2: Vector3;\n\n        if(ih.z < 0) { // transfer angle is larger than 180 (viewed from upper y axis)\n            lambda = -lambda;\n            it1 = cross3(ir1, ih);\n            it2 = cross3(ir2, ih);\n        } else {\n            it1 = cross3(ih, ir1);\n            it2 = cross3(ih, ir2);\n        }\n        it1 = normalize3(it1);\n        it2 = normalize3(it2);\n\n        if(retro) {\n            lambda = -lambda;\n            it1 = mult3(it1, -1);\n            it2 = mult3(it2, -1);\n        }\n\n        const lambda3 = lambda * lambda2;\n        const T = Math.sqrt(2 * mu / (s*s*s)) * tof;\n \n        // Detect maximum number of revolutions for which there exists a solution\n        let nRevs = T / Math.PI;\n        const T00 = Math.acos(lambda) + lambda * Math.sqrt(1.0 - lambda2);\n        const T0 = (T00 + nRevs * Math.PI);\n        const T1 = 2 / 3 * (1 - lambda3);\n        let DT = 0.0, DDT = 0.0, DDDT = 0.0;\n        let DTs = {DT, DDT, DDDT};\n        if(nRevs > 0) {\n            if(T > T0) { // Use Halley iterations\n                let it = 0;\n                let err = 1.0;\n                let Tmin = T0;\n                let xOld = 0.0, xNew = 0.0;\n                while(1) {\n                    DTs = dTdx(DT, DDT, DDDT, xOld, Tmin, lambda);\n                    DT = DTs.DT;\n                    DDT = DTs.DDT;\n                    DDDT = DTs.DDDT;\n                    if(DT !== 0) {\n                        xNew = xOld - DT * DDT / (DDT * DDT - DT * DDDT / 2.0);\n                    }\n                    err = Math.abs(xOld - xNew);\n                    if ((err < 1e-13) || (it > 12)) {\n                        break;\n                    }\n                    Tmin = x2tof(Tmin, xNew, nRevs);\n                    xOld = xNew;\n                    it++;\n                }\n                if(Tmin > T) {\n                    nRevs -= 1;\n                }\n            }\n        }\n\n        // Crop maximum revolutions to the input value, revs\n        nRevs = revs < nRevs ? revs : nRevs;\n\n        //  // Initialize arrays to store output\n        //  const solslen = 2 * nRevs + 1;\n        //  const x: number[] = new Array<number>(solslen);\n        //  const v1: Vector3[] = new Array<Vector3>(solslen);\n        //  const v2: Vector3[] = new Array<Vector3>(solslen);\n        \n        let x: number;\n\n        // Single revolution case\n        if(nRevs === 0) {\n            // Initial guess\n            let x0: number;\n            if(T >= T00) {\n                x0 = -(T - T00) / (T - T00 + 4);\n            } else if(T <= T1) {\n                x0 = T1 * (T1 - T) / (2 / 5 * (1 - lambda2 * lambda3) * T) + 1;\n            } else {\n                x0 = Math.pow(T / T00, 0.69314718055994529 / Math.log(T1 / T00)) - 1;\n            } \n            // Householder iterations for 0 rev case\n            x = householderIterations(T, x0, 0, 1e-15, lambda, 15);\n\n        // Multi-rev case\n        } else {\n            let tmp = 0.0;\n            if(left) {  // left Household iterations\n                tmp = Math.pow((nRevs * Math.PI + Math.PI) / (8 * T), 2 / 3);\n            } else {    // right Householder iterations \n                tmp = Math.pow((8 * T) / (nRevs * Math.PI), 2 / 3);\n            }\n            x = (tmp - 1) / (tmp + 1);\n            x = householderIterations(T, x, nRevs, 1e-8, lambda, 15);\n        }\n\n        // Reconstruct the terminal velocities from x\n        const gamma = Math.sqrt(mu * s / 2.0);\n        const rho = (r1 - r2) / c;\n        const sigma = Math.sqrt(1 - rho * rho);\n        const y = Math.sqrt(1.0 - lambda2 + lambda2 * x * x);\n        const vr1 = gamma * ((lambda * y - x) - rho * (lambda * y + x)) / r1;\n        const vr2 = -gamma * ((lambda * y - x) + rho * (lambda * y + x)) / r2;\n        const vt = gamma * sigma * (y + lambda * x);\n        const vt1 = vt / r1;\n        const vt2 = vt / r2;\n\n        const v1 = add3(mult3(ir1, vr1), mult3(it1, vt1));\n        const v2 = add3(mult3(ir2, vr2), mult3(it2, vt2));\n        return {v1, v2};\n    }\n \n    function householderIterations(T: number, x0: number, N: number, eps: number, lambda: number, maxIters: number) {\n        let xnew = 0;\n        let tof = 0;\n        let delta = 0;\n        let DT = 0, DDT = 0, DDDT = 0;\n        \n        for(let it = 0; it < maxIters; it++) {\n            tof = x2tof(x0, lambda, N);\n            const DTs = dTdx(DT, DDT, DDDT, x0, tof, lambda);\n            DT = DTs.DT;\n            DDT = DTs.DDT;\n            DDDT = DTs.DDDT;\n\n            delta = tof - T;\n            const DT2 = DT * DT;\n            xnew = x0 - delta * (DT2 - delta * DDT / 2) / (DT * (DT2 - delta * DDT) + DDDT * delta * delta / 6);\n            x0 = xnew;\n            if(Math.abs(x0 - xnew) < eps) {\n                break\n            }\n        }\n \n        return x0;\n    }\n \n    function dTdx(DT: number, DDT: number, DDDT: number, x: number, T: number, lambda: number) {\n        const l2 = lambda * lambda;\n        const  l3 = l2 * lambda;\n        const  umx2 = 1.0 - x * x;\n        const  y = Math.sqrt(1.0 - l2 * umx2);\n        const y2 = y * y;\n        const y3 = y2 * y;\n        DT = 1.0 / umx2 * (3.0 * T * x - 2.0 + 2.0 * l3 * x / y);\n        DDT = 1.0 / umx2 * (3.0 * T + 5.0 * x * DT + 2.0 * (1.0 - l2) * l3 / y3);\n        DDDT = 1.0 / umx2 * (7.0 * x * DDT + 8.0 * DT - 6.0 * (1.0 - l2) * l2 * l3 * x / y3 / y2);\n        return {DT, DDT, DDDT};\n    }\n \n    function x2tof2(x: number, lambda: number, N: number)\n    {\n        const a = 1.0 / (1.0 - x * x);\n        if (a > 0) // ellipse\n        {\n            let alfa = 2.0 * Math.acos(x);\n            let beta = 2.0 * Math.asin(Math.sqrt(lambda * lambda / a));\n            if (lambda < 0.0) beta = -beta;\n            return ((a * Math.sqrt(a) * ((alfa - Math.sin(alfa)) - (beta - Math.sin(beta) * TWO_PI * N))) / 2.0);\n        } else {\n            let alfa = 2.0 * Math.acosh(x);\n            let beta = 2.0 * Math.asinh(Math.sqrt(-lambda * lambda / a));\n            if (lambda < 0.0) beta = -beta;\n            return (-a * Math.sqrt(-a) * ((beta - Math.sinh(beta)) - (alfa - Math.sinh(alfa))) / 2.0);\n        }\n    }\n \n    function x2tof(x: number, lambda: number, N: number)\n    {\n        const battin = 0.01;\n        const lagrange = 0.2;\n        const dist = Math.abs(x - 1);\n        if (dist < lagrange && dist > battin) { // We use Lagrange tof expression\n            return x2tof2(x, lambda, N);\n        }\n        const K = lambda * lambda;\n        const E = x * x - 1.0;\n        const rho = Math.abs(E);\n        const z = Math.sqrt(1 + K * E);\n        if (dist < battin) { // We use Battin series tof expression\n            const eta = z - lambda * x;\n            const S1 = 0.5 * (1.0 - lambda - x * eta);\n            let Q = hypergeometricF(S1, 1e-11);\n            Q = 4.0 / 3.0 * Q;\n            return (eta * eta * eta * Q + 4.0 * lambda * eta) / 2.0 + Math.PI * N / (rho**1.5);\n        } else { // We use Lancaster tof expresion\n            const y = Math.sqrt(rho);\n            const g = x * z - lambda * E;\n            let d = 0.0;\n            if (E < 0) {\n                const l = Math.acos(g);\n                d = Math.PI * N + l;\n            } else {\n                const f = y * (z - lambda * x);\n                d = Math.log(f + g);\n            }\n            return (x - lambda * z - d / y) / E;\n        }\n    }\n \n    function hypergeometricF(z: number, tol: number)\n    {\n        let Sj = 1.0;\n        let Cj = 1.0;\n        let err = 1.0;\n        let Cj1 = 0.0;\n        let Sj1 = 0.0;\n        let j = 0;\n        while (err > tol) {\n            Cj1 = Cj * (3.0 + j) * (1.0 + j) / (2.5 + j) * z / (j + 1);\n            Sj1 = Sj + Cj1;\n            err = Math.abs(Cj1);\n            Sj = Sj1;\n            Cj = Cj1;\n            j++;\n        }\n        return Sj;\n    }\n \n    // p-iteration\n    export function psolve(r1vec: Vector3, r2vec: Vector3, tof: number, attractor: ICelestialBody, revs: number = 0, retro: boolean = false) {\n        const mu = attractor.stdGravParam;\n\n        const r1 = mag3(r1vec);\n        const r2 = mag3(r2vec);\n\n        let dTheta = Math.atan2(mag3(cross3(r1vec, r2vec)), dot3(r1vec, r2vec))\n        dTheta = retro ? -dTheta : dTheta;\n        const ih = normalize3(cross3(r1vec, r2vec));\n        if (ih.z < 0) { // transfer angle is larger than 180 (viewed from upper y axis)\n            dTheta = TWO_PI - dTheta;\n        }\n\n        // p-iteration constants\n        const k = r1 * r2 * (1 - Math.cos(dTheta));\n        const L = r1 + r2;\n        const m = r1 * r2 * (1 + Math.cos(dTheta));\n\n        // bounds\n        const pj  = k / (L + Math.sqrt(2 * m));\n        const pjj = k / (L - Math.sqrt(2 * m));\n        let pmin: number;\n        let pmax: number;\n        if (dTheta > Math.PI) {\n            pmin = 0.0;\n            pmax = pjj;\n        } else {\n            pmin = pj;\n            pmax = Infinity;\n        }\n\n        // Newton p-iteration\n        const tol = 1e-12;\n        const warntol = tol*1000;\n        const maxit = 200;\n        let it = 0;\n        let err = tol + 1;\n        let p = (pj + pjj) / 2;\n        let pNext = p;\n        let a = 0.0;\n        let f = 0.0;\n        let g = 0.0;\n        let df = 0.0;\n        while (err > tol && it < maxit) {\n            it++;\n            p = pNext;\n            a = m * k * p / ((2*m - L * L) * (p * p) + 2 * k * L * p - k * k);\n            a = a === 0 ? 1e-100 : a;    // Guarantee that parabolic case does not occur\n            f = 1 - r2 / p * (1 - Math.cos(dTheta));\n            g = r1 * r2 * Math.sin(dTheta) / Math.sqrt(mu * p);\n\n            let t: number;\n            let dtdp: number;\n            df = Math.sqrt(mu / p) * Math.tan(dTheta / 2) * ((1 - Math.cos(dTheta)) / p - 1 / r1 - 1 / r2);\n            if (a>0) { // elliptical case\n                const sinDeltaE = -r1 * r2 * df / Math.sqrt(mu * a);\n                const cosDeltaE = 1 - r1 / a * (1 - f);\n                const deltaE = wrapAngle(Math.atan2(sinDeltaE, cosDeltaE));\n                const angularspeed = Math.sqrt(a * a * a / mu);\n                t = g + angularspeed * (deltaE - sinDeltaE);\n                dtdp = -g / 2 / p - 1.5 * a * (t - g) * (k * k + (2 * m - L * L) * p * p) / (m * k * p * p) + angularspeed * (2 * k * sinDeltaE) / (p * (k - L * p));\n            } else { // hyperbolic case\n                const dF = Math.acosh(1 - r1 / a * (1 - f));\n                const angularspeed = Math.sqrt(-a * a * a / mu);\n                t = g + angularspeed * (Math.sinh(dF) - dF);\n                dtdp = -g / 2 / p - 1.5 * a * (t - g) * (k * k + (2 * m - L * L) * p * p) / (m * k * p * p) - angularspeed * (2 * k * Math.sinh(dF)) / (p * (k - L * p));\n            }\n            err = Math.abs(tof - t) / tof;\n            pNext = p + (tof - t) / dtdp;\n\n            // if the next guess is outside the allowed bounds, use bisection\n            if (pNext < pmin) {\n                pNext = (p + pmin) / 2;\n            } else if (pNext > pmax) {\n                pNext = (p + pmax) / 2;\n            }\n        }\n\n        if (err > warntol) {\n            console.log('Lambert p-iteration failed to converge. error: %f', err);\n        }\n\n        const v1 = div3(sub3(r2vec, mult3(r1vec,f)), g);\n        const v2 = add3(mult3(r1vec, df), mult3(v1, g));\n        return {v1, v2}\n    }\n\n }\n \n export default Lambert","const GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;\n\n// https://en.wikipedia.org/wiki/Golden-section_search\nexport function goldenSectionSearch(func: Function, min: number, max: number, tol: number = 1e-5) {\n    const GR = GOLDEN_RATIO - 1;\n    const GRsq = 2 - GOLDEN_RATIO;\n    let a = min, b = max;\n    let h = b - a;\n    if(h < tol) {\n        return (b + a) / 2;\n    }\n    let c = a + GRsq * h;\n    let d = a + GR * h;\n    let fc = func(c);\n    let fd = func(d);\n\n    while(h > tol) {\n        if(fc < fd) {\n            b = d;\n            d = c;\n            fd = fc;\n            h = GR * h;\n            c = a + GRsq * h;\n            fc = func(c);\n        } else {\n            a = c;\n            c = d;\n            fc = fd;\n            h = GR * h;\n            d = a + GR * h;\n            fd = func(d);\n        }\n    }\n\n    if(fc < fd) {\n        return (a + d) / 2;\n    } else {\n        return (c + b) / 2;\n    }\n}\n\n// https://en.wikipedia.org/wiki/Brent%27s_method\nexport function brentRootFind(func: Function, min: number, max: number, tol: number = 1e-12, maxIters: number = 100, warntol: number = 1.0) {\n    const errtol = 2*Number.EPSILON;\n\n    let a = min, b = max;\n    let fa = func(a);\n    let fb = func(b);\n\n    // Make sure the bounds bracket a root\n    if(Math.sign(fa) === Math.sign(fb)) {\n        throw new Error(\"The provided bounds do not bracket a root.\")\n    }\n\n    // Swap a and b to ensure that func(b) is closer to 0 than func(a) \n    if(Math.abs(fa) < Math.abs(fb)) {\n        const temp_a = a;\n        a = b;\n        b = temp_a;\n\n        const temp_fa = fa;\n        fa = fb;\n        fb = temp_fa;\n    }\n\n    let c = a;\n    let fc = fa;\n\n    let d = c;\n    let bisected = true;\n\n    let s = 0.0;\n    let fs = 1.0;\n\n    let itsRemaining = maxIters;\n    while (itsRemaining) {\n        itsRemaining--;\n\n        if(Math.abs(b - a) < tol) {\n            return b\n        }\n        if(Math.abs(fb) < errtol) {\n            return b\n        }\n\n        s = 0.0;\n\n        // Inverse quadratice interpolation\n        if((Math.abs(fa - fc) > errtol) && (Math.abs(fb - fc) > errtol)) {\n            s = ((a * fb * fc) / ((fa - fb) * (fa - fc))) + \n                ((b * fa * fc) / ((fb - fa) * (fb - fc))) +\n                ((c * fa * fb) / ((fc - fa) * (fc - fb)));\n        // Otherwise, use the secant method\n        } else {\n            s = b - (fc * ((b - a) / (fb - fa)))\n        }\n        const delta = Math.abs(errtol * b);\n        const currentStep = Math.abs(s - b);\n        const previousStep = Math.abs(b - c);\n        const secondStep = Math.abs(c - d);\n\n        // bisection conditions\n        if(\n            // s is not between (((3 * a) + b) / 4)) and b\n            ((s - (((3 * a) + b) / 4)) * (s - b) >= 0) ||\n            // the interpolation step is very small\n            (bisected && (currentStep >= previousStep / 2)) ||\n            (!bisected && (currentStep >= secondStep / 2)) ||\n            // the prvious steps were close to b\n            (bisected && previousStep < delta) ||\n            (!bisected && secondStep < delta)\n        ) {\n            s = (a + b) / 2;\n            bisected = true;\n        } else {\n            bisected = false;\n        }\n\n        // return s if func(s) is sufficiently close to 0\n        fs = func(s);\n        if(Math.abs(fs) < errtol) {\n            return s;\n        }\n\n        // reset positions and bracket\n        d = c;\n        c = b;\n\n        if(Math.sign(fa) !== Math.sign(fs)) {\n            b = s;\n            fb = fs;\n        } else {\n            a = s;\n            fa = fs;\n        }\n\n        // Swap a and b to ensure that func(b) is closer to 0 than func(a) \n        if(Math.abs(fa) < Math.abs(fb)) {\n            const temp_a = a;\n            a = b;\n            b = temp_a;\n\n            const temp_fa = fa;\n            fa = fb;\n            fb = temp_fa;\n        }\n    }\n\n    // no root found, print warning message\n    // if (Math.abs(fs) > warntol) {\n    //     console.log(\"Brent's method failed to find a root. Function value of %f at %f\", fs, s)\n    // }\n    return s;\n}\n\n// https://courses.seas.harvard.edu/courses/am205/g_act/am205_workshop_optimization.pdf\nexport function brentMinimize(func: Function, min: number, max: number, tol: number = 1e-8, maxIters: number = 50) {\n    // const GR = GOLDEN_RATIO - 1;\n    const GRsq = 2 - GOLDEN_RATIO;\n    const etol = tol; // 1e-3;\n    \n    let a = min, b = max;\n    let h = (b - a);\n    let x = a + GRsq * h;\n    let w = x;\n    let v = w;\n\n    let fv = func(v);\n    let fw = func(w);\n    let fx = func(x);\n\n    let u = 0.0;\n    let fu = 0.0;\n\n    let m = (a + b) / 2\n\n    let p = 0.0;\n    let q = 0.0;\n    let delta = 0.0;\n    let d = 0.0;\n    let e = 0.0;\n\n    let itsRemaining = maxIters;\n\n    while(itsRemaining) {\n        itsRemaining--;\n\n        if (h < tol) {\n            return m;\n        }\n\n        p = (w - x) * (w - x) * (fx - fv) + (v - x) * (v - x) * (fw - fx);\n        q = (w - x) * (fx -fv) + (v - x) * (fw - fx);\n\n        delta = 0.5 * p / q;\n\n        // If SPI is not well behaved, perform a Golden Section search\n        if(\n            // q is zero\n            (q === 0) ||\n            // u is not in between a and b\n            (a > u || u > b) ||\n            // p/q is not shrinking fast enough\n            (Math.abs(p/q) > 0.5 * Math.abs(e))  ||\n            // e is too small\n            (Math.abs(e) < etol) \n        ) {\n            e = (x < m) ? b-x : a-x;\n            d = GRsq * e;\n        // Otherwise, carry on with SPI\n        } else {\n            e = d;\n            d = delta;\n        }\n\n        u = x + d;\n\n        // newest function evaluation\n        fu = func(u);\n\n        // update bracket and previous guesses\n        // u is the best guess so far\n        if(fu <= fx) {\n            a = (u < x) ? a : x;\n            b = (u < x) ? x : b;\n            v = w;\n            w = x;\n            x = u;\n            fv = fw;\n            fw = fx;\n            fx = fu;\n        // fu is worse than fx\n        } else {\n            a = (u < x) ? u : a;\n            b = (u < x) ? b : u;\n            // fu is the second-best guess\n            if((fu <= fw) || (w === x)) {\n                v = w;\n                w = u;\n                fv = fw;\n                fw = fu;\n            // fu is the third-best guess\n            } else if((fu <= fv) || (v === x) || (v === w)) {\n                v = u;\n                fv = fu;\n            // fu is the worst guess\n            } else {\n                // Don't keep u, only the bracket is updated\n            }\n        }\n\n        // update interval size and midpoint\n        h = b - a;\n        m = (a + b) / 2;\n    }\n    // if(h > tol) {\n    //     console.log(\"Brent's minimization method failed to converge. Interval size: \", h)\n    // }\n    return m\n}\n\nexport function newtonRootSolve(\n    f: (x: number) => number,\n    df: (x: number) => number,\n    x0: number,\n    eps: number,\n    maxIters: number = 1000\n){\n    let n = 0;\n    let prevX: number;\n    let x = x0;\n    let err = eps + 1;\n    let errp = err + 1;\n    while(err > eps && n < maxIters){\n        prevX = x;\n        x -= f(x) / df(x);\n        errp = err;\n        err = Math.abs(x - prevX);\n        if(errp < err) {            // Modification to Newton's method, using bisection in case the error gets worse with an iteration\n            x = (x + prevX) / 2;    // This helps in case of poor initializations that lead to large overshoot, where the algorithm would not otherwise converge\n        }\n        n++;\n    }\n    if (n >= maxIters) {\n        console.log(\"Newton's method failed to find a root. Error of %f. \", err)\n    }\n    return x;\n}\n\ninterface NMpoint\n{\n    x:       number[],\n    objx:    number,\n}\n\nfunction sortNMpoints(p1: NMpoint, p2: NMpoint) : number {\n    return p1.objx - p2.objx;\n}\n\n\n// https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method#One_possible_variation_of_the_NM_algorithm\nexport function nelderMeadMinimize(\n    initialPoints:  number[][],\n    objective:      (x: number[]) => number,\n    tol:            number = 1.0,   // Non-standard approach to termination, since my objective functions have an assumed minimum (0.0)\n    maxIt:          number = initialPoints[0].length * 250,\n    alpha:          number = 1.0,\n    gamma:          number = 2.0,\n    rho:            number = 0.5,\n    sigma:          number = 0.5,\n    \n): number[] {\n\n    const n: number = initialPoints[0].length;\n    const simplex: NMpoint[]    = [];\n    const centroid: number[]    = initialPoints[0].slice()\n    const reflect: number[]     = centroid.slice();\n    const contract: number[]    = centroid.slice();\n    const expand: number[]      = centroid.slice();\n\n    // create simplex from initial points\n    for(let i = 0; i <= n; i++) {\n        simplex.push({x: initialPoints[i], objx: objective(initialPoints[i])})\n    }\n\n    // iterate until termination\n    let err = tol + 1;\n    for(let it = 0; it < maxIt; it++) {\n        // sort the simplex by objective function value\n        simplex.sort(sortNMpoints);\n        err = simplex[0].objx;\n        if(err < tol) {\n            break\n        }\n\n        // TODO: add convergence test for general case\n\n        // calculate the centroid of the simplex\n        for(let i = 0; i <= n; i++) {\n            centroid[i] = 0.0;\n            for(let j = 0; j < n; j++) {\n                centroid[i] = centroid[i] + simplex[j].x[i];\n            }\n            centroid[i] = centroid[i] / n;\n        }\n\n        // reflect worst point across the centroid\n        for(let i = 0; i < n; i++) {\n            reflect[i] = centroid[i] + alpha * (centroid[i] - simplex[n].x[i]);\n        }\n        const objReflect = objective(reflect);\n\n        // if the point is better than second worse, but not the best,\n        // replace the worst point with the reflected point and iterate\n            if(objReflect < simplex[n - 1].objx && objReflect >= simplex[0].objx) {\n                simplex[n].x = reflect.slice();\n                simplex[n].objx = objReflect;\n                continue\n            }\n\n        // if the relfected point is the best so far, expand the reflected point\n        if(objReflect < simplex[0].objx) {\n            for(let i = 0; i < n; i++) {\n                expand[i] = centroid[i] + gamma * (reflect[i] - centroid[i]);\n            }\n            const objExpand = objective(expand);\n\n            // use the better of the expanded and reflected points to replace the worst point\n            // then, iterate\n            if(objExpand < objReflect) {\n                simplex[n].x = expand.slice();\n                simplex[n].objx = objExpand;\n            } else {\n                simplex[n].x = reflect.slice();\n                simplex[n].objx = objReflect;\n            }\n            continue\n        }\n\n        // Here, the reflected point is at least as bad as the second worst point\n        // If it is the worst point, compute the contracted point on the inside\n        if(objReflect > simplex[n].objx) {\n            for(let i = 0; i < n; i++) {\n                contract[i] = centroid[i] + rho * (simplex[n].x[i] - centroid[i]);\n            }        \n            const objContract = objective(contract);\n            // replace worst point if this one is any better, then iterate\n            if(objContract < simplex[n].objx) {\n                simplex[n].x = contract.slice();\n                simplex[n].objx = objContract;\n                continue\n            }\n        // otherwise, compute the contracted point on the outside\n        } else {\n            for(let i = 0; i < n; i++) {\n                contract[i] = centroid[i] + rho * (reflect[i] - centroid[i]);\n            }    \n            const objContract = objective(contract);\n            // replace worst point if this one is an improvement on the reflection, then iterate\n            if(objContract < objReflect) {\n                simplex[n].x = contract.slice();\n                simplex[n].objx = objContract;\n                continue\n            }\n        }\n\n        // At this step, all points will be shrunk toward the best point\n        for(let i = 1; i <= n; i++) {\n            for(let j = 1; j < n; j++) {\n                simplex[i].x[j] = simplex[0].x[j] + sigma * (simplex[i].x[j] - simplex[0].x[j]);\n            }\n            simplex[i].objx = objective(simplex[i].x);\n        }\n    }\n    return simplex[0].x\n}\n\n","import Kepler from './kepler';\nimport Lambert from './lambert';\nimport DepartArrive from './departarrive';\nimport { vec3, add3, sub3, mag3, normalize3, cross3, dot3, roderigues, wrapAngle, acosClamped, HALF_PI, Z_DIR, magSq3 } from './math';\nimport FlybyCalcs from './flybycalcs';\n\nnamespace Trajectories {\n    export function transferTrajectory(startOrbit: IOrbit, endOrbit: IOrbit, transferBody: ICelestialBody, startDate: number, flightTime: number, endDate: number, \n                                       planeChange: boolean, startPatchPosition: Vector3 = vec3(0,0,0), endPatchPosition: Vector3 = vec3(0,0,0)): Trajectory {\n        \n        const startState = Kepler.orbitToStateAtDate(startOrbit, transferBody, startDate);\n        const endState   = Kepler.orbitToStateAtDate(endOrbit,   transferBody, endDate); \n        const startPos = add3(startState.pos, startPatchPosition);\n        const endPos   = add3(endState.pos,   endPatchPosition);\n\n        if(planeChange) { // for plane-change-style transfer...\n            // project the end position to the perifocal plane of the pre-transfer orbit, and compute a transfer\n            let planeEndPos = Kepler.rotateToPerifocalFromInertial(endPos, startOrbit);\n            planeEndPos = Kepler.rotateToInertialFromPerifocal(vec3(planeEndPos.x, planeEndPos.y, 0.0), startOrbit);\n\n            const {v1} = Lambert.solve(startPos, planeEndPos, flightTime, transferBody);\n            const transferOrbit1 = Kepler.stateToOrbit(\n                {\n                    date: startDate,\n                    pos:  startPos,\n                    vel:  v1\n                },\n                transferBody\n            );\n            \n            // identify the true anomaly and date at the plane change (use PI/2 prior to target encounter)\n            const startNu = Kepler.angleInOrbitPlane(startPos, transferOrbit1);\n            // let startNu = Kepler.dateToOrbitTrueAnomaly(startDate, transferOrbit1);\n            // if(isNaN(startNu)) {    // in case Newton root solving fails for the inverse Kepler equation (near parabolic orbits?)\n            //     startNu = Kepler.angleInOrbitPlane(startPos, transferOrbit1);\n            // }\n            const endNu = Kepler.angleInOrbitPlane(planeEndPos, transferOrbit1);\n            // let endNu = Kepler.dateToOrbitTrueAnomaly(endDate, transferOrbit1);\n            // if(isNaN(endNu)) {      // in case Newton root solving fails for the inverse Kepler equation (near parabolic orbits?)\n            //     endNu = Kepler.angleInOrbitPlane(planeEndPos, transferOrbit1);\n            // }\n            const planeChangeNu = startNu + Math.max(0.0, (wrapAngle(endNu - startNu) - HALF_PI));\n            const planeChangeDate = Kepler.trueAnomalyToOrbitDate(planeChangeNu, transferOrbit1, startDate);\n\n            // rotate the velocity vector at the plane change location to hit the target at encounter\n            const planeChangePreState = {\n                date: planeChangeDate,\n                pos:  Kepler.positionAtTrueAnomaly(transferOrbit1, planeChangeNu),\n                vel:  Kepler.velocityAtTrueAnomaly(transferOrbit1, transferBody.stdGravParam, planeChangeNu),\n            };\n            const n1vec = normalize3(cross3(planeChangePreState.pos, planeChangePreState.vel));\n            const n2vec = normalize3(cross3(planeChangePreState.pos, endPos));\n            const rotationAngle = acosClamped(dot3(n1vec, n2vec));\n            let rotationAxis = rotationAngle === 0 ? Z_DIR : normalize3(cross3(n1vec, n2vec));\n            rotationAxis = isNaN(rotationAxis.x) ? Z_DIR : rotationAxis;\n            const newVel = roderigues(planeChangePreState.vel, rotationAxis, rotationAngle);\n\n            // compute the transfer orbit from the plane change position and post-maneuver velocity;\n            const planeChangePostState = {\n                date: planeChangeDate, \n                pos: planeChangePreState.pos, \n                vel: newVel,\n            };\n            const transferOrbit2 = Kepler.stateToOrbit(planeChangePostState,transferBody);\n\n            // prepare maneuvers at beginning and end of transfer\n            const departState: OrbitalState = {\n                date: startDate,\n                pos:  startPos,\n                vel:  v1,\n            }\n            let arriveState = Kepler.orbitToStateAtDate(transferOrbit2, transferBody, endDate);\n            if(isNaN(arriveState.pos.x)) {  // in case Newton root solving fails for the inverse Kepler equation (near parabolic orbits?)\n                const arriveNu = Kepler.angleInOrbitPlane(endPos, transferOrbit2);\n                arriveState = {\n                    date: endDate,\n                    pos:  endPos,\n                    vel:  Kepler.velocityAtTrueAnomaly(transferOrbit2, transferBody.stdGravParam, arriveNu),\n                };\n            }\n\n            const departManeuver = Kepler.maneuverFromOrbitalStates(startState, departState);\n            const arriveManeuver = Kepler.maneuverFromOrbitalStates(arriveState, endState);\n            const planeManeuver  = Kepler.maneuverFromOrbitalStates(planeChangePreState, planeChangePostState)\n\n            const trajectory = {orbits:         [transferOrbit1, transferOrbit2],\n                                intersectTimes: [startDate, planeChangeDate, endDate],\n                                maneuvers:      [departManeuver, planeManeuver, arriveManeuver]};\n                   \n            return trajectory;    \n        } else {\n            const {v1, v2} = Lambert.solve(startPos, endPos, flightTime, transferBody)\n\n            // prepare maneuvers at beginning and end of transfer\n            const departState: OrbitalState = {\n                date: startDate,\n                pos:  startPos,\n                vel:  v1,\n            }\n            const arriveState: OrbitalState = {\n                date: endDate,\n                pos:  endPos,\n                vel:  v2,\n            }\n\n            const departManeuver = Kepler.maneuverFromOrbitalStates(startState, departState);\n            const arriveManeuver = Kepler.maneuverFromOrbitalStates(arriveState, endState);\n\n            const trajectory = {orbits:         [Kepler.stateToOrbit({ date: startDate, pos: startPos, vel: v1}, transferBody)],\n                                intersectTimes: [startDate, endDate],\n                                maneuvers:      [departManeuver, arriveManeuver]};\n            return trajectory;\n        }\n    }\n\n    function bodyFromId(system: ISolarSystem, id: number) {\n        if(id === 0) {\n            return system.sun;\n        } else {\n            const body = system.orbiterIds.get(id);\n            if(!body)\n                throw new Error(`No body with id ${id}`);\n            return body;\n        }\n    }\n\n    export function ejectionTrajectories(system: ISolarSystem, startOrbit: IOrbit, transferOrbit: IOrbit, ejectionSequence: number[], transferStartDate: number, \n                                         matchStartMo: boolean = true, eitype: \"fastdirect\" | \"direct\" | \"fastoberth\" | \"oberth\" = \"fastdirect\", soiPatchPositions: Vector3[] = ejectionSequence.slice(-1).map((i) => vec3(0,0,0))): Trajectory[] {\n        let ejectionInfos: Trajectory[] = [];\n        \n        let nextOrbit: IOrbit;\n        let previousOrbit: IOrbit;\n\n        let nextOrbitVel: Vector3;\n        let currentBodyVel: Vector3;\n\n        let escapeDate = transferStartDate;\n        const nEjections = ejectionSequence.length - 1;\n        for(let i=nEjections - 1; i>=0; i--) {\n            // body around which the ejection orbit takes place\n            const currentBody = (bodyFromId(system, ejectionSequence[i]) as IOrbitingBody);\n            // body after escape\n            const nextBody = bodyFromId(system, ejectionSequence[i+1]);\n            // if this is the first ejection, use the starting orbit\n            if(i === 0) {\n                previousOrbit = startOrbit;\n            // otherwise, use the orbit of the body that has just been escaped\n            } else {\n                const previousBody = (bodyFromId(system, ejectionSequence[i-1]) as IOrbitingBody);\n                previousOrbit = previousBody.orbit;\n            }\n            // if this is the last ejection, use the transfer orbit as the next orbit\n            if(i === nEjections - 1) {\n                nextOrbit = transferOrbit;\n                nextOrbitVel = Kepler.orbitToVelocityAtDate(nextOrbit, nextBody, escapeDate);\n                currentBodyVel = Kepler.orbitToVelocityAtDate(currentBody.orbit, nextBody, escapeDate);\n            // otherwise, use the next ejection orbit\n            } else {\n                const nextEjection = ejectionInfos[ejectionInfos.length-1];\n                nextOrbit      = nextEjection.orbits[0];\n                nextOrbitVel   = nextEjection.maneuvers[0].postState.vel;\n                escapeDate     = nextEjection.maneuvers[0].postState.date;\n                currentBodyVel = nextEjection.maneuvers[0].preState.vel;\n            }\n                        \n            // get relative velocity to the current body at escape\n            const relativeVel = sub3(nextOrbitVel, currentBodyVel);\n\n            // always match the mean anomaly of a body's orbit\n            const matchOrb = i > 0 ? true : matchStartMo;\n\n            // type check\n            let type = eitype;\n            if(type === \"fastoberth\") {\n                // try to perform a quick check to see if a direct transfer would be better\n                const soi = currentBody.soi;\n                const mu = currentBody.stdGravParam;\n                const soiSpeedSq = magSq3(relativeVel);\n                const apoapsis = previousOrbit.semiMajorAxis;\n                const periapsis = FlybyCalcs.minFlybyRadius(currentBody);\n\n                const escapeEnergy = soiSpeedSq  / 2 - mu / soi;\n                const parkSpeed = Math.sqrt(mu / apoapsis);\n\n                const obrEcc    = (apoapsis - periapsis) / (periapsis + apoapsis);\n                const obrSMA    = periapsis / (1 - obrEcc);\n                const obrEnergy = -mu  / (2 * obrSMA) ;\n        \n                const obrPeriapsisSpeed = Math.sqrt((obrEnergy + mu / periapsis) * 2); \n                const escPeriapsisSpeed = Math.sqrt((escapeEnergy + mu / periapsis) * 2); \n                const obrApoapsisSpeed  = Math.sqrt((obrEnergy + mu / apoapsis) * 2);\n                const directSpeed = Math.sqrt((escapeEnergy + mu / apoapsis) * 2);\n        \n                const directDeltaV = Math.abs(parkSpeed - directSpeed);\n                const oberthDeltaV = Math.abs(escPeriapsisSpeed - obrPeriapsisSpeed) + Math.abs(obrApoapsisSpeed - parkSpeed);\n\n                if(directDeltaV < oberthDeltaV) {\n                    type = \"fastdirect\";\n                }\n            }\n\n            // patch position\n            const patchPos = i === 0 ? vec3(0,0,0) : soiPatchPositions[i - 1];\n\n            // calculate the ejection trajectory\n            let currentEjection: Trajectory = type === \"fastdirect\" ? DepartArrive.fastDeparture(previousOrbit,       currentBody, relativeVel, escapeDate, matchOrb) :\n                                              type === \"direct\"     ? DepartArrive.optimalDeparture(previousOrbit,    currentBody, relativeVel, escapeDate, matchOrb, \"direct\", patchPos) :\n                                              type === \"fastoberth\" ? DepartArrive.fastOberthDeparture(previousOrbit, currentBody, relativeVel, escapeDate, matchOrb, patchPos) :\n                                              type === \"oberth\"     ? DepartArrive.optimalDeparture(previousOrbit,    currentBody, relativeVel, escapeDate, matchOrb, \"oberth\", patchPos) :\n                                              DepartArrive.fastDeparture(previousOrbit,  currentBody, relativeVel, escapeDate, matchOrb);\n\n            // if there is a nonzero SoI patch position for this ejection, and the \"fastdirect\" type was used, recalculate the ejection with the modified start position\n            if(i > 0 && type === \"fastdirect\" && mag3(patchPos) > 0) {\n                // optimize ejection eccentricity based on starting position\n                const patchedEjOrb = DepartArrive.departArriveForPosition(add3(currentEjection.maneuvers[0].preState.pos, patchPos),\n                                                                            currentBody,\n                                                                            relativeVel,\n                                                                            escapeDate,\n                                                                            1).orbit;\n                // calculate the date when the exited body is at the right place\n                const previousOrbitNu = Kepler.angleInOrbitPlane(currentEjection.maneuvers[0].preState.pos, previousOrbit);\n                const ejEpoch = Kepler.trueAnomalyToOrbitDate(previousOrbitNu, previousOrbit, patchedEjOrb.epoch - previousOrbit.siderealPeriod / 2)\n                const soiDate = escapeDate + ejEpoch - patchedEjOrb.epoch;\n                patchedEjOrb.epoch = ejEpoch;\n\n                // prepare orbital states for exited body and ejection orbit at time of ejection\n                const ejPreVel = Kepler.velocityAtTrueAnomaly(previousOrbit, currentBody.stdGravParam, previousOrbitNu);\n                const ejPreState: OrbitalState = {date: ejEpoch, pos: currentEjection.maneuvers[0].preState.pos, vel: ejPreVel};\n                const ejPostState = Kepler.orbitToStateAtDate(patchedEjOrb, currentBody, patchedEjOrb.epoch);\n                const maneuver = Kepler.maneuverFromOrbitalStates(ejPreState, ejPostState);\n                currentEjection = {\n                    orbits:             [patchedEjOrb],\n                    intersectTimes:     [ejEpoch, soiDate],\n                    maneuvers:          [maneuver],\n                }\n            }\n\n            // add the calculated ejection to the list\n            ejectionInfos.push(currentEjection);\n        }\n\n        return ejectionInfos.reverse();\n    }\n\n    export function insertionTrajectories(system: ISolarSystem, endOrbit: IOrbit, transferOrbit: IOrbit, insertionSequence: number[], transferEndDate: number, \n                                          matchEndMo: boolean = true, eitype: \"fastdirect\" | \"direct\" | \"fastoberth\" | \"oberth\" = \"fastdirect\", soiPatchPositions: Vector3[] = insertionSequence.slice(0,-1).map((i) => vec3(0,0,0))): Trajectory[] {\n        let insertionInfos: Trajectory[] = [];\n\n        let previousOrbit: IOrbit;\n        let nextOrbit: IOrbit;\n\n        let previousOrbitVel: Vector3;\n        let currentBodyVel: Vector3;\n\n        let encounterDate = transferEndDate;\n        const nInsertions = insertionSequence.length - 1;\n        for(let i=0; i<nInsertions; i++) {\n            // body around which the insertion orbit takes place\n            const currentBody = (bodyFromId(system, insertionSequence[i+1]) as IOrbitingBody);\n            // body prior to encounter\n            const previousBody = bodyFromId(system, insertionSequence[i]);\n            // if this is the last insertion, use the ending orbit\n            if(i === nInsertions - 1) {\n                nextOrbit = endOrbit;\n            // otherwise, use the orbit of the body about to be encountered\n            } else {\n                const nextBody = (bodyFromId(system, insertionSequence[i+2]) as IOrbitingBody);\n                nextOrbit = nextBody.orbit;\n            }\n            // if this is the first insertion, use the transfer orbit as the next orbit\n            if(i === 0) {\n                previousOrbit = transferOrbit;\n                previousOrbitVel = Kepler.orbitToVelocityAtDate(previousOrbit, previousBody, encounterDate);\n                currentBodyVel = Kepler.orbitToVelocityAtDate(currentBody.orbit, previousBody, encounterDate);\n            // otherwise, use the previous insertion orbit\n            } else {\n                const previousInsertion = insertionInfos[insertionInfos.length-1];\n                const prevInLen  = previousInsertion.orbits.length;\n                const prevManLen = previousInsertion.maneuvers.length;\n                previousOrbit    = previousInsertion.orbits[prevInLen - 1];\n                previousOrbitVel = previousInsertion.maneuvers[prevManLen - 1].preState.vel;\n                encounterDate    = previousInsertion.maneuvers[prevManLen - 1].preState.date;\n                currentBodyVel   = previousInsertion.maneuvers[prevManLen - 1].postState.vel;\n            }\n\n            // get relative velocity to the current body at encounter\n            const relativeVel = sub3(previousOrbitVel, currentBodyVel);\n\n            // always match the mean anomaly of a body's orbit\n            const matchOrb = i < nInsertions - 1 ? true : matchEndMo;\n\n            // type check\n            let type = eitype;\n            if(type === \"fastoberth\") {\n                // try to perform a quick check to see if a direct transfer would be better\n                const soi = currentBody.soi;\n                const mu = currentBody.stdGravParam;\n                const soiSpeedSq = magSq3(relativeVel);\n                const apoapsis = nextOrbit.semiMajorAxis;\n                const periapsis = FlybyCalcs.minFlybyRadius(currentBody);\n\n                const encounterEnergy = soiSpeedSq  / 2 - mu / soi;\n                const parkSpeed = Math.sqrt(mu / apoapsis);\n\n                const obrSMA    = (apoapsis + periapsis) / 2;\n                const obrEnergy = -mu  / (2 * obrSMA) ;\n        \n                const obrPeriapsisSpeed = Math.sqrt((obrEnergy + mu / periapsis) * 2); \n                const encPeriapsisSpeed = Math.sqrt((encounterEnergy + mu / periapsis) * 2); \n                const obrApoapsisSpeed  = Math.sqrt((obrEnergy + mu / apoapsis) * 2);\n                const directSpeed = Math.sqrt((encounterEnergy + mu / apoapsis) * 2);\n        \n                const directDeltaV = Math.abs(parkSpeed - directSpeed);\n                const oberthDeltaV = Math.abs(encPeriapsisSpeed - obrPeriapsisSpeed) + Math.abs(obrApoapsisSpeed - parkSpeed);\n\n                if(directDeltaV < oberthDeltaV) {\n                    type = \"fastdirect\";\n                }\n            }\n\n            // patch position\n            const patchPos = i === nInsertions - 1 ? vec3(0,0,0) : soiPatchPositions[i+1];\n\n            // calculate the insertion trajectory\n            let currentInsertion = type === \"fastdirect\"   ? DepartArrive.fastArrival(nextOrbit,     currentBody, relativeVel, encounterDate, matchOrb) :\n                                   type === \"direct\" ? DepartArrive.optimalArrival(nextOrbit,        currentBody, relativeVel, encounterDate, matchOrb, \"direct\", patchPos) :\n                                   type === \"fastoberth\" ? DepartArrive.fastOberthArrival(nextOrbit, currentBody, relativeVel, encounterDate, matchOrb, patchPos) :\n                                   type === \"oberth\" ? DepartArrive.optimalArrival(nextOrbit,        currentBody, relativeVel, encounterDate, matchOrb, \"oberth\", patchPos) :\n                                   DepartArrive.fastArrival(nextOrbit, currentBody, relativeVel, encounterDate, matchOrb);\n            \n            // if there is a nonzero SoI patch position for this insertion, and it's not the last one,  recalculate the ejection with the modified start position\n            if(i < nInsertions && type === \"fastdirect\" && mag3(patchPos) > 0) {\n                const manLen = currentInsertion.maneuvers.length;\n                const patchedInOrb = DepartArrive.departArriveForPosition(add3(currentInsertion.maneuvers[manLen - 1].postState.pos, patchPos),\n                                                                            currentBody,\n                                                                            relativeVel,\n                                                                            encounterDate,\n                                                                            -1).orbit;\n                // calculate the date when the encountered body is at the right place\n                const nextOrbitNu = Kepler.angleInOrbitPlane(currentInsertion.maneuvers[manLen - 1].postState.pos, nextOrbit);\n                const inEpoch = Kepler.trueAnomalyToOrbitDate(nextOrbitNu, nextOrbit, patchedInOrb.epoch - nextOrbit.siderealPeriod / 2);\n                const soiDate = encounterDate + inEpoch - patchedInOrb.epoch;\n                patchedInOrb.epoch = inEpoch;\n\n                // prepare orbital states for encountered body and insertion orbit at time of encounter\n                const inPreVel = Kepler.velocityAtTrueAnomaly(nextOrbit, currentBody.stdGravParam, nextOrbitNu);\n                const inPostState: OrbitalState = {date: inEpoch, pos: currentInsertion.maneuvers[manLen - 1].postState.pos, vel: inPreVel};\n                const inPreState = Kepler.orbitToStateAtDate(patchedInOrb, currentBody, patchedInOrb.epoch);\n                const maneuver = Kepler.maneuverFromOrbitalStates(inPreState, inPostState);\n\n                currentInsertion = {\n                    orbits:         [patchedInOrb],\n                    intersectTimes: [soiDate, inEpoch],\n                    maneuvers:      [maneuver],\n                }\n            }\n            insertionInfos.push(currentInsertion);\n        }\n        return insertionInfos;\n    }\n\n}\n\nexport default Trajectories;","import Orbit from \"./orbit\"\nimport Color from \"./color\";\n\nexport class CelestialBody implements ICelestialBody {\n    readonly id!:               number;\n    readonly name!:             string;\n    readonly radius!:           number;\n    readonly atmosphereHeight!: number;\n    readonly mass!:             number;\n    readonly stdGravParam!:     number;\n    readonly soi!:              number;\n    readonly color!:            Color;\n    readonly orbiters:          OrbitingBody[] = [];\n\n    constructor(data: ICelestialBody) {\n        this.id                 = data.id;\n        this.name               = data.name;\n        this.radius             = data.radius;\n        this.atmosphereHeight   = data.atmosphereHeight;\n        this.mass               = data.mass;\n        this.stdGravParam       = data.stdGravParam;\n        this.soi                = data.soi;\n        this.color              = new Color(data.color);\n    }\n\n    public get data() : ICelestialBody {\n        return {\n            id:                 this.id,\n            name:               this.name,\n            radius:             this.radius,\n            atmosphereHeight:   this.atmosphereHeight,\n            mass:               this.mass,\n            stdGravParam:       this.stdGravParam,\n            soi:                this.soi,\n            color:              this.color\n        }\n    }\n\n    public get orbiterIds() : number[] {\n        let orbIds: number[] = [];\n        for(let i=0; i<this.orbiters.length; i++) {\n            orbIds.push(this.orbiters[i].id)\n        }\n        return orbIds\n    }\n\n    public get furtherstOrbiterDistance() : number {\n        let maxDist = 0.0;\n        for(let i=0; i<this.orbiters.length; i++) {\n            const orb = this.orbiters[i].orbit;\n            const orbDist = orb.semiMajorAxis * (1 + orb.eccentricity);\n            maxDist = Math.max(orbDist, maxDist)\n        }\n        return maxDist;\n    }\n}\n\nexport class OrbitingBody extends CelestialBody implements IOrbitingBody {\n    readonly orbit!:            Orbit;\n    readonly orbiting!:         number;\n\n    constructor(data: IOrbitingBody, public readonly attractor: CelestialBody, anglesToRad: boolean = false) {\n        super(data);\n        \n        this.orbit        = new Orbit(data.orbit, this.attractor, anglesToRad);\n        this.orbiting     = data.orbiting;\n    }\n\n    public get data(): IOrbitingBody {\n        return {\n            ...super.data,\n            orbit:          this.orbit.data,\n            orbiting:       this.orbiting,\n        };\n    }\n}\n\nexport function isOrbitingBody(body: ICelestialBody): body is OrbitingBody {\n    return (body as OrbitingBody).orbiting !== undefined;\n}\n\nexport default CelestialBody;","export class Color implements IColor {\n    readonly r!:    number;\n    readonly g!:    number;\n    readonly b!:    number;\n\n    constructor(c: IColor) {\n        this.r = c.r;\n        this.g = c.g;\n        this.b = c.b;\n    }\n\n    public rescale(scale: number) {\n        return new Color({r: Math.max(Math.min(scale * this.r, 255), 0), \n                          g: Math.max(Math.min(scale * this.g, 255), 0), \n                          b: Math.max(Math.min(scale * this.b, 255), 0)});\n    }\n\n    public toString() {\n        return 'rgb('.concat(this.r.toString(), \",\", this.g.toString(), \",\", this.b.toString(), \")\");\n    }\n}\n\nexport default Color;","import Kepler from \"../libs/kepler\";\nimport { degToRad } from \"../libs/math\";\n\nexport class Orbit implements IOrbit {\n    readonly semiMajorAxis!:         number;\n    readonly apoapsis!:              number;\n    readonly periapsis!:             number;\n    readonly eccentricity!:          number;\n    readonly inclination!:           number;\n    readonly argOfPeriapsis!:        number;\n    readonly ascNodeLongitude!:      number;\n    readonly meanAnomalyEpoch!:      number;\n    readonly epoch!:                 number; \n    readonly semiLatusRectum!:       number;\n    readonly siderealPeriod!:        number;\n    readonly orbiting!:              number;\n    readonly attractorSoi!:          number;\n    readonly attractorStdGravParam!: number\n\n\n    constructor (data: IOrbit, attractor: ICelestialBody, anglesToRad: boolean = false) {\n        this.semiMajorAxis = data.semiMajorAxis;\n        this.eccentricity  = data.eccentricity;\n        this.meanAnomalyEpoch = data.meanAnomalyEpoch;\n        this.epoch = data.epoch;\n\n        if (anglesToRad) {\n            this.inclination = degToRad(data.inclination);\n            this.argOfPeriapsis = degToRad(data.argOfPeriapsis);\n            this.ascNodeLongitude = degToRad(data.ascNodeLongitude);\n        } else {\n            this.inclination = data.inclination;\n            this.argOfPeriapsis = data.argOfPeriapsis;\n            this.ascNodeLongitude = data.ascNodeLongitude;\n        }\n\n        if(this.eccentricity < 1){\n            this.periapsis = this.semiMajorAxis * (1 - this.eccentricity);\n            this.apoapsis =  this.semiMajorAxis * (1 + this.eccentricity);\n        }\n        else {\n            this.periapsis = this.semiMajorAxis * (this.eccentricity - 1);\n        }\n\n        if(data.semiLatusRectum) {\n            this.semiLatusRectum = data.semiLatusRectum;\n        } else {\n            this.semiLatusRectum = this.semiMajorAxis * (1 - this.eccentricity * this.eccentricity);\n        }\n\n        if(data.siderealPeriod) {\n            this.siderealPeriod = data.siderealPeriod;\n        } else {\n            this.siderealPeriod = Kepler.siderealPeriod(data.semiMajorAxis, attractor.stdGravParam);\n        }\n\n        if(\"orbiting\" in data) {\n            this.orbiting = data.orbiting;\n        } else {\n            this.orbiting = attractor.id;\n        }\n\n        this.attractorSoi = attractor.soi;\n        this.attractorStdGravParam = attractor.stdGravParam;\n    }\n\n    public get data(): IOrbit {\n        return {\n            orbiting:         this.orbiting,\n            semiMajorAxis:    this.semiMajorAxis,\n            apoapsis:         this.apoapsis,\n            periapsis:        this.periapsis,\n            eccentricity:     this.eccentricity,\n            inclination:      this.inclination,\n            argOfPeriapsis:   this.argOfPeriapsis,\n            ascNodeLongitude: this.ascNodeLongitude,\n            meanAnomalyEpoch: this.meanAnomalyEpoch,\n            epoch:            this.epoch,\n            semiLatusRectum:  this.semiLatusRectum,\n            siderealPeriod:   this.siderealPeriod,\n        };\n    }\n\n    public static fromOrbitalElements(elements: OrbitalElements, attractor: ICelestialBody){\n        const data = Kepler.orbitFromElements(elements, attractor);\n        return new Orbit(data, attractor);\n    }\n}\n\nexport default Orbit","import { OrbitingBody, CelestialBody, isOrbitingBody } from \"./body\";\n\nexport class SolarSystem implements ISolarSystem {\n    readonly sun!:              CelestialBody;\n    readonly orbiters!:         OrbitingBody[];\n    readonly orbiterIds!:       Map<number, OrbitingBody>;\n\n    constructor(sun: ICelestialBody, bodies: IOrbitingBody[], anglesToRad: boolean = false) {\n        this.orbiters = [];\n        this.orbiterIds = new Map();\n        this.sun = new CelestialBody(sun);\n        \n        for(let i=0; i<bodies.length; i++){\n            const bodydata = bodies[i];\n            const attractor = bodydata.orbiting === 0 ? this.sun : (this.orbiterIds!.get(bodydata.orbiting) as OrbitingBody);\n            const body = new OrbitingBody(bodydata, attractor, anglesToRad);\n            \n            this.orbiterIds!.set(body.id, body);\n            attractor.orbiters.push(body);\n            this.orbiters.push(body);\n        }\n    }\n\n    public get orbiting() {\n        return [...this.orbiterIds!.values()];\n    }\n\n    public get bodies(){\n        return [this.sun, ...this.orbiters];\n    }\n\n    public get data() {\n        const data = [];\n        for(const body of this.bodies) {\n            data.push(body.data);\n        }\n        return data;\n    }\n\n    public get size() {\n        return (1 + this.orbiterIds.size)\n    }\n\n    public bodyFromName(name: string) {\n        for(const body of [this.sun, ...this.orbiters]) {\n            if(body.name === name)\n                return body;\n        }\n        throw new Error(`No body with name ${name}`);\n    }\n\n    public bodyFromId(id: number) {\n        if(id === 0) {\n            return this.sun;\n        } else {\n            const body = this.orbiterIds.get(id);\n            if(!body)\n                throw new Error(`No body with id ${id}`);\n            return body;\n        }\n    }\n\n    public sequenceToSun(id: number) {\n        let bd = this.bodyFromId(id);\n        let seq: number[] = [bd.id];\n        while(isOrbitingBody(bd)) {\n            bd = this.bodyFromId(bd.orbiting);\n            seq.push(bd.id);\n        }\n        return seq\n    }\n\n    public commonAttractorId(id1: number, id2: number) {\n        const sunSeq1 = this.sequenceToSun(id1);\n        const sunSeq2 = this.sequenceToSun(id2);\n        for(let i=0; i<sunSeq1.length; i++) {\n            if(sunSeq2.includes(sunSeq1[i])) {\n                return sunSeq1[i]\n            }\n        }\n        throw new Error('Bodies do not share a common attractor (error in defining this SolarSystem)')\n    }\n}\n\nexport default SolarSystem;","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport possibleConstructorReturn from \"./possibleConstructorReturn.js\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import superPropBase from \"./superPropBase.js\";\nexport default function _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get.apply(this, arguments);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import defineProperty from \"./defineProperty.js\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}","import _typeof from \"./typeof.js\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}"],"names":["fastDepartureArrival","parkOrbit","parkBody","relativeVel","soiDate","ejection","matchParkMo","c","mu","stdGravParam","soi","soiSpeedSq","magSq3","a","etol","relativeVelPlane","Kepler","periapsis","semiMajorAxis","eccentricity","periapsisErr","fastDepartureArrivalForPeriapsis","err","min","max","brentRootFind","parkNu","e","soiNu","pPos","pVel","deltaT","periapsisDate","siderealPeriod","periapsisState","date","pos","vel","parkState","orbit","maneuver","orbits","intersectTimes","epoch","maneuvers","pSpeedSq","pSpeed","Math","sqrt","p","soiVel","mult3","X_DIR","Y_DIR","rotAngle1","atan2","z","abs","y","roderigues","rotAngle2","x","Z_DIR","fastOberthDepartureArrival","soiPatchPosition","vec3","FlybyCalcs","hypSMA","hypEcc","hypSLR","hypNu","obrNu","PI","hypDelta","delta","wrapAngle","parkNuObj","parkPos","startPos","add3","nDir","normalize3","cross3","deltaForNu","counterClockwiseAngleInPlane","brentMinimize","insertionTrueAnomaly","ejectionTrueAnomaly","apoapsis","mag3","soiVelSq","hypEnergy","obrEcc","obrSMA","obrEnergy","obrPeriapsisSpeed","hypPeriapsisSpeed","rotInc","alignVectorsAngleAxis","perifocalSoiDir","cos","sin","tiltSoiDir","axis","angle","rotArg","periapsisPos","periapsisVelDir","hypPeriapsisVel","obrPeriapsisVel","hypDuration","obrDuration","obrDate","hypPreState","hypPostState","obrEpoch","adjustedSoiDate","obrOrbit","meanAnomalyEpoch","hypOrbit","parkVel","obrVel","obrPreState","obrPostState","obrManeuver","hypManeuver","optimalDepartureArrival","type","minNu","TWO_PI","maxNu","Number","EPSILON","nuFun","directDepartArriveForTrueAnomaly","oberthDepartArriveForTrueAnomaly","nuObjFun","nu","isNaN","Infinity","console","log","Error","deltaV","exp","res","trajectoryInfo","fullResult","departArriveForPosition","preState","postState","deltaVMag","mr","hHat","n","nMag","nHat","div3","i","acosClamped","lan","copysign","eMax","eMin","clamp","eObjFun","departArriveForEccentricity","id","semiLatusRectum","mNu","T","mM","deltat","mt","orbiting","inclination","ascNodeLongitude","argOfPeriapsis","dot3","oberthDepartArriveForPosition","parkPosDir","soiDir","denominator","minPeriapsis","minDenomPeriapsis","minDenom","objective","obrSpeed","perifocalObrDir","obrDir","sub3","name","patchTrueAnomaly","orb","attractor","patchDate","tMin","undefined","patchPosition","patchVelocity","DepartArrive","minFlybyRadius","body","radius","atmosphereHeight","maxFlybyRadius","orb1","orb2","meanSMA","midPeriod","lb","ub","velIn","velOut","time","inVelSq","outVelSq","inDir","outDir","inEnergy","outEnergy","inSMA","outSMA","hDir","inEcc","outEcc","inSLR","outSLR","inNu","outNu","deltaIn","deltaOut","obj","error","periapsisSpeedIn","periapsisSpeedOut","inSemiMajorAxis","inEccentricity","inDirection","outSemiMajorAxis","outEccentricity","outDirection","normalDirection","params","inPerifocalDirection","inPeriapsisSpeed","outPeriapsisSpeed","inPeriapsisVel","outPeriapsisVel","inPeriapsisState","outPeriapsisState","inOrbit","outOrbit","inDate","outDate","agent","inputs","startDate","lerp","startDateMin","startDateMax","flightTimes","j","length","ft","flightTimesMax","flightTimesMin","push","system","startOrbit","endOrbit","flybyIdSequence","ejectionInsertionType","planeChange","matchStartMo","matchEndMo","noInsertionBurn","flightPathAngleAtTrueAnomaly","atan","motionAngleAtTrueAnomaly","HALF_PI","motionDirectionAtTrueAnomaly","distanceAtTrueAnomaly","dateToMeanAnomaly","M0","meanAnomalyToDate","M","t","nPeriods","ceil","trueToMeanAnomaly","E","H","atanh","tan","sinh","meanToTrueAnomaly","newtonRootSolve","H0","sign","cosh","tanh","dateToTrueAnomaly","trueAnomalyToDate","angleInPlane","arg","perifocalPos","zxz","positionAtTrueAnomaly","r","velocityAtTrueAnomaly","v","perifocalVel","elements","progradeDir","normalDir","radialDir","prograde","normal","radial","state","v2","h","eVec","eHat","nVec","householderIterations","x0","N","eps","lambda","maxIters","xnew","tof","DT","DDT","DDDT","it","DTs","dTdx","x2tof","DT2","l2","l3","umx2","y2","y3","dist","alfa","acos","beta","asin","acosh","asinh","x2tof2","K","rho","eta","Q","tol","Sj","Cj","Cj1","Sj1","hypergeometricF","g","d","l","f","r1vec","r2vec","it1","it2","revs","retro","left","r1","r2","s","ir1","ir2","ih","lambda2","lambda3","nRevs","T00","T0","T1","Tmin","xOld","xNew","pow","tmp","gamma","sigma","vr1","vr2","vt","vt1","vt2","v1","dTheta","pmin","pmax","k","L","m","pj","pjj","warntol","maxit","pNext","df","dtdp","sinDeltaE","cosDeltaE","deltaE","angularspeed","dF","Lambert","GOLDEN_RATIO","func","errtol","b","fa","fb","temp_a","temp_fa","fc","bisected","fs","itsRemaining","currentStep","previousStep","secondStep","GRsq","w","fv","fw","fx","u","fu","q","prevX","sortNMpoints","p1","p2","objx","nelderMeadMinimize","initialPoints","maxIt","alpha","simplex","centroid","slice","reflect","contract","expand","sort","objReflect","objExpand","objContract","bodyFromId","sun","orbiterIds","get","transferBody","flightTime","endDate","startPatchPosition","endPatchPosition","startState","endState","endPos","planeEndPos","transferOrbit1","startNu","endNu","planeChangeNu","planeChangeDate","planeChangePreState","n1vec","n2vec","rotationAngle","rotationAxis","newVel","planeChangePostState","transferOrbit2","departState","arriveState","arriveNu","departManeuver","arriveManeuver","planeManeuver","trajectory","transferOrbit","ejectionSequence","transferStartDate","nextOrbit","previousOrbit","nextOrbitVel","currentBodyVel","eitype","soiPatchPositions","map","ejectionInfos","escapeDate","nEjections","currentBody","nextBody","previousBody","nextEjection","matchOrb","escapeEnergy","parkSpeed","escPeriapsisSpeed","obrApoapsisSpeed","directSpeed","directDeltaV","oberthDeltaV","patchPos","currentEjection","patchedEjOrb","previousOrbitNu","ejEpoch","ejPreVel","ejPreState","ejPostState","reverse","insertionSequence","transferEndDate","previousOrbitVel","insertionInfos","encounterDate","nInsertions","previousInsertion","prevInLen","prevManLen","encounterEnergy","encPeriapsisSpeed","currentInsertion","manLen","patchedInOrb","nextOrbitNu","inEpoch","inPreVel","inPostState","inPreState","Trajectories","CelestialBody","data","mass","color","orbiters","this","Color","orbIds","maxDist","orbDist","OrbitingBody","anglesToRad","Orbit","isOrbitingBody","scale","concat","toString","attractorSoi","attractorStdGravParam","degToRad","SolarSystem","bodies","Map","bodydata","set","values","size","bd","seq","id1","id2","sunSeq1","sequenceToSun","sunSeq2","includes","_arrayLikeToArray","arr","len","arr2","Array","_assertThisInitialized","self","ReferenceError","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_createForOfIteratorHelper","o","allowArrayLike","Symbol","iterator","isArray","F","done","value","_e","normalCompletion","didErr","call","step","next","_e2","_createSuper","Derived","hasNativeReflectConstruct","result","Super","NewTarget","constructor","Reflect","construct","arguments","apply","_defineProperty","_get","property","receiver","base","desc","getOwnPropertyDescriptor","_getPrototypeOf","setPrototypeOf","getPrototypeOf","__proto__","_inherits","subClass","superClass","create","_isNativeReflectConstruct","sham","Proxy","Boolean","valueOf","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","_objectSpread2","source","forEach","getOwnPropertyDescriptors","defineProperties","_possibleConstructorReturn","_setPrototypeOf","_superPropBase","hasOwnProperty","_toConsumableArray","arrayLikeToArray","iter","from","unsupportedIterableToArray","_typeof","_unsupportedIterableToArray","minLen","test"],"sourceRoot":""}