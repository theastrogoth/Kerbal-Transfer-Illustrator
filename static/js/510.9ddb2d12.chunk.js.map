{"version":3,"file":"static/js/510.9ddb2d12.chunk.js","mappings":"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","sources":["main/libs/math.ts","main/libs/optim.ts","main/libs/propagate.ts","workers/propagate.worker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["/* Miscellaneous useful functions */\nexport const X_DIR = vec3(1, 0, 0);\nexport const Y_DIR = vec3(0, 1, 0);\nexport const Z_DIR = vec3(0, 0, 1);\n\nexport const TWO_PI = 2 * Math.PI;\nexport const HALF_PI = 0.5 * Math.PI;\n\nexport function linspace(start: number, stop: number, n: number): number[] {\n    n = Math.floor(n);\n\n    if(n === 1) {\n        return [stop]\n    }\n\n    const interval = (stop - start) / (n - 1);\n    const vals: number[] = new Array<number>(n);\n    vals[0] = start;\n    for(let i = 1; i < n; i++) {\n        vals[i] = vals[i-1] + interval;\n    }\n    return vals;\n}\n\nexport function clamp(x: number, min: number, max: number) {\n    return x > max ? max : x < min ? min : x;\n}\n\nexport function degToRad(deg: number) {\n    return deg * Math.PI / 180.0;\n}\n\nexport function radToDeg(rad: number) {\n    return rad * 180.0 / Math.PI;\n}\n\nexport function wrapAngle(angle: number, min: number = 0) {\n    const max = min + TWO_PI;\n    if(min <= angle && angle < max) {\n        return angle;\n    }\n    const circles = Math.floor((angle - min) / TWO_PI);\n    return angle - TWO_PI * circles;\n}\n\nexport function acosClamped(x: number) {\n    return Math.acos(clamp(x, -1, 1));\n}\n\nexport function isnegative(x: number) {\n    return x < 0\n}\n\nexport function copysign(x: number, y: number) {\n    return isnegative(y) ? -x : x;\n}\n\nexport function randomSign(): -1 | 1 {\n    // @ts-ignore\n    return (Math.round(Math.random()) * 2 - 1);\n}\n\nexport function randint(a: number, b: number){\n    return Math.floor(a + Math.random() * (b - a + 1));\n}\n\nexport function lerp(x: number, y: number, t: number) {\n    return x + t * (y - x);\n}\n\n\n/* Functions for manipulating 3D vectors */\n\nexport function vec3(x: number, y: number, z: number) : Vector3 {\n    return {x: x, y: y, z: z};\n}\n\nexport function clone3(v: Vector3): Vector3 {\n    return {x: v.x, y: v.y, z: v.z};\n}\n\nexport function mult3(v: Vector3, f: number) : Vector3 {\n    return {\n        x: v.x * f,\n        y: v.y * f,\n        z: v.z * f\n    };\n}\n\nexport function div3(v: Vector3, f: number) : Vector3 {\n    return {\n        x: v.x / f,\n        y: v.y / f,\n        z: v.z / f\n    };\n}\n\nexport function add3(u: Vector3, v: Vector3) : Vector3 {\n    return {\n        x: u.x + v.x,\n        y: u.y + v.y,\n        z: u.z + v.z\n    };\n}\n\nexport function sub3(u: Vector3, v: Vector3) : Vector3 {\n    return {\n        x: u.x - v.x,\n        y: u.y - v.y,\n        z: u.z - v.z\n    };\n}\n\nexport function dot3(u: Vector3, v: Vector3) {\n    return u.x*v.x + u.y*v.y + u.z*v.z;\n}\n\nexport function cross3(u: Vector3, v:Vector3) : Vector3 {\n    return {\n        x: u.y * v.z - u.z * v.y,\n        y: u.z * v.x - u.x * v.z,\n        z: u.x * v.y - u.y * v.x,\n    };\n}\n\nexport function magSq3(v: Vector3) {\n    return dot3(v, v);\n}\n\nexport function mag3(v: Vector3) {\n    return Math.sqrt(magSq3(v))\n}\n\nexport function normalize3(v: Vector3) : Vector3 {\n    const len = mag3(v);\n    return div3(v, len);\n}\n\n/* https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula */\nexport function roderigues(v: Vector3, axis: Vector3, angle: number) : Vector3 {\n    const c = Math.cos(angle);\n    const s = Math.sin(angle);\n\n    const v1 = mult3(v, c);\n    const v2 = mult3(cross3(axis, v), s);\n    const v3 = mult3(axis, dot3(axis, v) * (1 - c));\n\n    return add3(add3(v1, v2), v3)\n}\n\nexport function alignVectorsAngleAxis(x: Vector3, y: Vector3) {\n    const xHat = normalize3(x);\n    const yHat = normalize3(y);\n    const axis  = normalize3(cross3(x,y));\n    const angle = acosClamped(dot3(xHat, yHat));\n    return {axis, angle}\n}\n\nexport function counterClockwiseAngleInPlane(x: Vector3, y: Vector3, normalDirection: Vector3) {\n    let {axis, angle} = alignVectorsAngleAxis(normalDirection, vec3(0, 0, 1));\n    if(isNaN(axis.x)) {\n        axis = X_DIR;\n    }\n    const xPlane = roderigues(x, axis, angle);\n    const yPlane = roderigues(y, axis, angle);\n    const xAngle = Math.atan2(xPlane.y, xPlane.x);\n    const yAngle = Math.atan2(yPlane.y, yPlane.x);\n    // if(Math.abs(xPlane.z) > 1e-8 || Math.abs(yPlane.z) > 1e-8) {\n    //     console.log(x, y, normalDirection)\n    // }\n    return wrapAngle(yAngle - xAngle);\n}\n\n/* https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix */\nexport function zxz(v: Vector3, a1: number, a2: number, a3: number) : Vector3 {\n    const c1 = Math.cos(a1);\n    const c2 = Math.cos(a2);\n    const c3 = Math.cos(a3);\n\n    const s1 = Math.sin(a1);\n    const s2 = Math.sin(a2);\n    const s3 = Math.sin(a3);\n\n    const x = (c1*c3 - s1*c2*s3)*v.x + (-c1*s3 - s1*c2*c3)*v.y + (s1*s2)*v.z;\n    const y = (s1*c3 + c1*c2*s3)*v.x + (c1*c2*c3 - s1*s3)*v.y + (-c1*s2)*v.z;\n    const z = (s2*s3)*v.x + (s2*c3)*v.y + c2*v.z;\n\n    return {\n        x: x,\n        y: y,\n        z: z,\n    };\n}\n\n/* Coordinate Systems */\n\nexport function cartesianToSpherical(p: Vector3): Spherical {\n    const r = mag3(p);\n    const theta = Math.atan2(Math.sqrt(p.x * p.x + p.y * p.y), p.z);\n    const phi = Math.atan2(p.y, p.x);\n    return {r, theta, phi};\n}\n\nexport function sphericalToCartesian(p: Spherical) {\n    const x = p.r * Math.cos(p.phi) * Math.sin(p.theta);\n    const y = p.r * Math.sin(p.phi) * Math.sin(p.theta);\n    const z = p.r * Math.cos(p.theta);\n    return {x, y, z};\n}\n\n/* Dates & Times */\n\nexport function timeToCalendarDate(time: number, timeSettings: TimeSettings, yearOffset: number = 1, dayOffset: number = 1): CalendarDate {  \n    const m = 60;\n    const h = 3600;\n    const d = timeSettings.hoursPerDay * h;\n    const y = timeSettings.daysPerYear * d;\n\n    let secondsRemaining = time;\n    const year = Math.floor(secondsRemaining / y) + yearOffset;\n    secondsRemaining = secondsRemaining - y * (year - yearOffset);\n    const day = Math.floor(secondsRemaining / d ) + dayOffset;    \n    secondsRemaining = secondsRemaining - d * (day - dayOffset);\n    const hour = Math.floor(secondsRemaining / h);\n    secondsRemaining = secondsRemaining - h * hour;\n    const minute = Math.floor(secondsRemaining / m);\n    secondsRemaining = secondsRemaining - m * minute;\n    const second = secondsRemaining;\n    return {\n        year,\n        day, \n        hour,\n        minute,\n        second\n    }\n}\n\nexport function calendarDateToTime(calendarDate: CalendarDate, timeSettings: TimeSettings, yearOffset: number = 0, dayOffset: number = 0): number {\n    const years   = calendarDate.year - yearOffset;\n    const days    = calendarDate.day  - dayOffset;\n    const hours   = calendarDate.hour;\n    const minutes = calendarDate.minute;\n    const seconds = calendarDate.second;\n\n    return ( ((timeSettings.daysPerYear * years + days) * timeSettings.hoursPerDay + hours ) * 60 + minutes) * 60 + seconds;\n}\n\nexport function calendarDateToString(cd: CalendarDate): String {\n    return \"Year \".concat(String(cd.year), \", Day \", String(cd.day), \", \", ('0'+String(cd.hour)).slice(-2), \":\", ('0'+String(cd.minute)).slice(-2), \":\", ('0'+String(Math.round(cd.second))).slice(-2));\n}\n\nexport function calendarDateToDurationString(cd: CalendarDate): String {\n    return String(cd.year).concat(cd.year === 1 ? \" Year, \" : \" Years, \", \n           String(cd.day), cd.day === 1 ? \" Day, \" : \" Days, \", \n           String(cd.hour), cd.hour === 1 ? \" hour, \" : \" hours, \", \n           String(cd.minute), cd.minute === 1 ? \" minute, and \" : \" minutes, and \", \n           String(Math.round(cd.second)), cd.second === 1 ? \" second\" : \" seconds\");\n}","const GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;\n\n// https://en.wikipedia.org/wiki/Golden-section_search\nexport function goldenSectionSearch(func: Function, min: number, max: number, tol: number = 1e-5) {\n    const GR = GOLDEN_RATIO - 1;\n    const GRsq = 2 - GOLDEN_RATIO;\n    let a = min, b = max;\n    let h = b - a;\n    if(h < tol) {\n        return (b + a) / 2;\n    }\n    let c = a + GRsq * h;\n    let d = a + GR * h;\n    let fc = func(c);\n    let fd = func(d);\n\n    while(h > tol) {\n        if(fc < fd) {\n            b = d;\n            d = c;\n            fd = fc;\n            h = GR * h;\n            c = a + GRsq * h;\n            fc = func(c);\n        } else {\n            a = c;\n            c = d;\n            fc = fd;\n            h = GR * h;\n            d = a + GR * h;\n            fd = func(d);\n        }\n    }\n\n    if(fc < fd) {\n        return (a + d) / 2;\n    } else {\n        return (c + b) / 2;\n    }\n}\n\n// https://en.wikipedia.org/wiki/Brent%27s_method\nexport function brentRootFind(func: Function, min: number, max: number, tol: number = 1e-12, maxIters: number = 100, warntol: number = 1.0) {\n    const errtol = 2*Number.EPSILON;\n\n    let a = min, b = max;\n    let fa = func(a);\n    let fb = func(b);\n\n    // Make sure the bounds bracket a root\n    if(Math.sign(fa) === Math.sign(fb)) {\n        throw new Error(\"The provided bounds do not bracket a root.\")\n    }\n\n    // Swap a and b to ensure that func(b) is closer to 0 than func(a) \n    if(Math.abs(fa) < Math.abs(fb)) {\n        const temp_a = a;\n        a = b;\n        b = temp_a;\n\n        const temp_fa = fa;\n        fa = fb;\n        fb = temp_fa;\n    }\n\n    let c = a;\n    let fc = fa;\n\n    let d = c;\n    let bisected = true;\n\n    let s = 0.0;\n    let fs = 1.0;\n\n    let itsRemaining = maxIters;\n    while (itsRemaining) {\n        itsRemaining--;\n\n        if(Math.abs(b - a) < tol) {\n            return b\n        }\n        if(Math.abs(fb) < errtol) {\n            return b\n        }\n\n        s = 0.0;\n\n        // Inverse quadratice interpolation\n        if((Math.abs(fa - fc) > errtol) && (Math.abs(fb - fc) > errtol)) {\n            s = ((a * fb * fc) / ((fa - fb) * (fa - fc))) + \n                ((b * fa * fc) / ((fb - fa) * (fb - fc))) +\n                ((c * fa * fb) / ((fc - fa) * (fc - fb)));\n        // Otherwise, use the secant method\n        } else {\n            s = b - (fc * ((b - a) / (fb - fa)))\n        }\n        const delta = Math.abs(errtol * b);\n        const currentStep = Math.abs(s - b);\n        const previousStep = Math.abs(b - c);\n        const secondStep = Math.abs(c - d);\n\n        // bisection conditions\n        if(\n            // s is not between (((3 * a) + b) / 4)) and b\n            ((s - (((3 * a) + b) / 4)) * (s - b) >= 0) ||\n            // the interpolation step is very small\n            (bisected && (currentStep >= previousStep / 2)) ||\n            (!bisected && (currentStep >= secondStep / 2)) ||\n            // the prvious steps were close to b\n            (bisected && previousStep < delta) ||\n            (!bisected && secondStep < delta)\n        ) {\n            s = (a + b) / 2;\n            bisected = true;\n        } else {\n            bisected = false;\n        }\n\n        // return s if func(s) is sufficiently close to 0\n        fs = func(s);\n        if(Math.abs(fs) < errtol) {\n            return s;\n        }\n\n        // reset positions and bracket\n        d = c;\n        c = b;\n\n        if(Math.sign(fa) !== Math.sign(fs)) {\n            b = s;\n            fb = fs;\n        } else {\n            a = s;\n            fa = fs;\n        }\n\n        // Swap a and b to ensure that func(b) is closer to 0 than func(a) \n        if(Math.abs(fa) < Math.abs(fb)) {\n            const temp_a = a;\n            a = b;\n            b = temp_a;\n\n            const temp_fa = fa;\n            fa = fb;\n            fb = temp_fa;\n        }\n    }\n\n    // no root found, print warning message\n    // if (Math.abs(fs) > warntol) {\n    //     console.log(\"Brent's method failed to find a root. Function value of %f at %f\", fs, s)\n    // }\n    return s;\n}\n\n// https://courses.seas.harvard.edu/courses/am205/g_act/am205_workshop_optimization.pdf\nexport function brentMinimize(func: Function, min: number, max: number, tol: number = 1e-8, maxIters: number = 50) {\n    // const GR = GOLDEN_RATIO - 1;\n    const GRsq = 2 - GOLDEN_RATIO;\n    const etol = tol; // 1e-3;\n    \n    let a = min, b = max;\n    let h = (b - a);\n    let x = a + GRsq * h;\n    let w = x;\n    let v = w;\n\n    let fv = func(v);\n    let fw = func(w);\n    let fx = func(x);\n\n    let u = 0.0;\n    let fu = 0.0;\n\n    let m = (a + b) / 2\n\n    let p = 0.0;\n    let q = 0.0;\n    let delta = 0.0;\n    let d = 0.0;\n    let e = 0.0;\n\n    let itsRemaining = maxIters;\n\n    while(itsRemaining) {\n        itsRemaining--;\n\n        if (h < tol) {\n            return m;\n        }\n\n        p = (w - x) * (w - x) * (fx - fv) + (v - x) * (v - x) * (fw - fx);\n        q = (w - x) * (fx -fv) + (v - x) * (fw - fx);\n\n        delta = 0.5 * p / q;\n\n        // If SPI is not well behaved, perform a Golden Section search\n        if(\n            // q is zero\n            (q === 0) ||\n            // u is not in between a and b\n            (a > u || u > b) ||\n            // p/q is not shrinking fast enough\n            (Math.abs(p/q) > 0.5 * Math.abs(e))  ||\n            // e is too small\n            (Math.abs(e) < etol) \n        ) {\n            e = (x < m) ? b-x : a-x;\n            d = GRsq * e;\n        // Otherwise, carry on with SPI\n        } else {\n            e = d;\n            d = delta;\n        }\n\n        u = x + d;\n\n        // newest function evaluation\n        fu = func(u);\n\n        // update bracket and previous guesses\n        // u is the best guess so far\n        if(fu <= fx) {\n            a = (u < x) ? a : x;\n            b = (u < x) ? x : b;\n            v = w;\n            w = x;\n            x = u;\n            fv = fw;\n            fw = fx;\n            fx = fu;\n        // fu is worse than fx\n        } else {\n            a = (u < x) ? u : a;\n            b = (u < x) ? b : u;\n            // fu is the second-best guess\n            if((fu <= fw) || (w === x)) {\n                v = w;\n                w = u;\n                fv = fw;\n                fw = fu;\n            // fu is the third-best guess\n            } else if((fu <= fv) || (v === x) || (v === w)) {\n                v = u;\n                fv = fu;\n            // fu is the worst guess\n            } else {\n                // Don't keep u, only the bracket is updated\n            }\n        }\n\n        // update interval size and midpoint\n        h = b - a;\n        m = (a + b) / 2;\n    }\n    // if(h > tol) {\n    //     console.log(\"Brent's minimization method failed to converge. Interval size: \", h)\n    // }\n    return m\n}\n\nexport function newtonRootSolve(\n    f: (x: number) => number,\n    df: (x: number) => number,\n    x0: number,\n    eps: number,\n    maxIters: number = 1000\n){\n    let n = 0;\n    let prevX: number;\n    let x = x0;\n    let err = eps + 1;\n    let errp = err + 1;\n    while(err > eps && n < maxIters){\n        prevX = x;\n        x -= f(x) / df(x);\n        errp = err;\n        err = Math.abs(x - prevX);\n        if(errp < err) {            // Modification to Newton's method, using bisection in case the error gets worse with an iteration\n            x = (x + prevX) / 2;    // This helps in case of poor initializations that lead to large overshoot, where the algorithm would not otherwise converge\n        }\n        n++;\n    }\n    if (n >= maxIters) {\n        console.log(\"Newton's method failed to find a root. Error of %f. \", err)\n    }\n    return x;\n}\n\ninterface NMpoint\n{\n    x:       number[],\n    objx:    number,\n}\n\nfunction sortNMpoints(p1: NMpoint, p2: NMpoint) : number {\n    return p1.objx - p2.objx;\n}\n\n\n// https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method#One_possible_variation_of_the_NM_algorithm\nexport function nelderMeadMinimize(\n    initialPoints:  number[][],\n    objective:      (x: number[]) => number,\n    tol:            number = 1.0,   // Non-standard approach to termination, since my objective functions have an assumed minimum (0.0)\n    maxIt:          number = initialPoints[0].length * 250,\n    alpha:          number = 1.0,\n    gamma:          number = 2.0,\n    rho:            number = 0.5,\n    sigma:          number = 0.5,\n    \n): number[] {\n\n    const n: number = initialPoints[0].length;\n    const simplex: NMpoint[]    = [];\n    const centroid: number[]    = initialPoints[0].slice()\n    const reflect: number[]     = centroid.slice();\n    const contract: number[]    = centroid.slice();\n    const expand: number[]      = centroid.slice();\n\n    // create simplex from initial points\n    for(let i = 0; i <= n; i++) {\n        simplex.push({x: initialPoints[i], objx: objective(initialPoints[i])})\n    }\n\n    // iterate until termination\n    let err = tol + 1;\n    for(let it = 0; it < maxIt; it++) {\n        // sort the simplex by objective function value\n        simplex.sort(sortNMpoints);\n        err = simplex[0].objx;\n        if(err < tol) {\n            break\n        }\n\n        // TODO: add convergence test for general case\n\n        // calculate the centroid of the simplex\n        for(let i = 0; i <= n; i++) {\n            centroid[i] = 0.0;\n            for(let j = 0; j < n; j++) {\n                centroid[i] = centroid[i] + simplex[j].x[i];\n            }\n            centroid[i] = centroid[i] / n;\n        }\n\n        // reflect worst point across the centroid\n        for(let i = 0; i < n; i++) {\n            reflect[i] = centroid[i] + alpha * (centroid[i] - simplex[n].x[i]);\n        }\n        const objReflect = objective(reflect);\n\n        // if the point is better than second worse, but not the best,\n        // replace the worst point with the reflected point and iterate\n            if(objReflect < simplex[n - 1].objx && objReflect >= simplex[0].objx) {\n                simplex[n].x = reflect.slice();\n                simplex[n].objx = objReflect;\n                continue\n            }\n\n        // if the relfected point is the best so far, expand the reflected point\n        if(objReflect < simplex[0].objx) {\n            for(let i = 0; i < n; i++) {\n                expand[i] = centroid[i] + gamma * (reflect[i] - centroid[i]);\n            }\n            const objExpand = objective(expand);\n\n            // use the better of the expanded and reflected points to replace the worst point\n            // then, iterate\n            if(objExpand < objReflect) {\n                simplex[n].x = expand.slice();\n                simplex[n].objx = objExpand;\n            } else {\n                simplex[n].x = reflect.slice();\n                simplex[n].objx = objReflect;\n            }\n            continue\n        }\n\n        // Here, the reflected point is at least as bad as the second worst point\n        // If it is the worst point, compute the contracted point on the inside\n        if(objReflect > simplex[n].objx) {\n            for(let i = 0; i < n; i++) {\n                contract[i] = centroid[i] + rho * (simplex[n].x[i] - centroid[i]);\n            }        \n            const objContract = objective(contract);\n            // replace worst point if this one is any better, then iterate\n            if(objContract < simplex[n].objx) {\n                simplex[n].x = contract.slice();\n                simplex[n].objx = objContract;\n                continue\n            }\n        // otherwise, compute the contracted point on the outside\n        } else {\n            for(let i = 0; i < n; i++) {\n                contract[i] = centroid[i] + rho * (reflect[i] - centroid[i]);\n            }    \n            const objContract = objective(contract);\n            // replace worst point if this one is an improvement on the reflection, then iterate\n            if(objContract < objReflect) {\n                simplex[n].x = contract.slice();\n                simplex[n].objx = objContract;\n                continue\n            }\n        }\n\n        // At this step, all points will be shrunk toward the best point\n        for(let i = 1; i <= n; i++) {\n            for(let j = 1; j < n; j++) {\n                simplex[i].x[j] = simplex[0].x[j] + sigma * (simplex[i].x[j] - simplex[0].x[j]);\n            }\n            simplex[i].objx = objective(simplex[i].x);\n        }\n    }\n    return simplex[0].x\n}\n\n","import DepartArrive from \"./departarrive\";\nimport Kepler from \"./kepler\";\nimport { add3, mag3, sub3 } from \"./math\";\nimport { brentMinimize, brentRootFind } from \"./optim\";\n\nfunction orbitDistanceFromBody(date: number, orbit: IOrbit, satelliteBody: IOrbitingBody) {\n    const orbitPos = Kepler.orbitToPositionAtDate(orbit, date);\n    const bodyPos  = Kepler.orbitToPositionAtDate(satelliteBody.orbit, date);\n    return mag3(sub3(bodyPos, orbitPos)) - satelliteBody.soi;\n}\n\nfunction findNextOrbit(orbit: IOrbit, system: ISolarSystem, startDate: number, endDate: number = Infinity, nRevs: number = 0): IOrbit | null {\n    // prepare attractor body\n    const attractor = orbit.orbiting === 0 ? system.sun : system.orbiterIds.get(orbit.orbiting) as IOrbitingBody;\n    // prepare satellite bodies\n    const satelliteBodies: IOrbitingBody[] = [];\n    for(let j=0; j<system.orbiters.length; j++) {\n        if(system.orbiters[j].orbiting === attractor.id) {\n            satelliteBodies.push(system.orbiters[j]);\n        }\n    }\n    // set search bounds\n    let maxDate: number = endDate;\n    let escapes: boolean = orbit.eccentricity > 1;\n    let escapeDate: number = NaN;\n    const soi = attractor.soi === null ? Infinity : attractor.soi;\n    if (!escapes && attractor.soi !== null) {\n        const apoapsis = orbit.apoapsis ? orbit.apoapsis : orbit.semiMajorAxis * (1 + orbit.eccentricity);\n        escapes = apoapsis > attractor.soi;\n    }\n    if (escapes) {\n        if (soi === Infinity) {\n            const maxDist = Math.max(...satelliteBodies.map(body => body.orbit.apoapsis ? body.orbit.apoapsis + body.soi : body.orbit.semiMajorAxis * (1 + body.orbit.eccentricity) + body.soi));\n            escapeDate = Kepler.trueAnomalyToOrbitDate(Kepler.trueAnomalyAtDistance(maxDist, orbit.eccentricity, orbit.semiLatusRectum), orbit, startDate);\n            maxDate = Math.min(maxDate, escapeDate);\n        } else {\n            escapeDate = DepartArrive.ejectionDate(orbit, attractor as IOrbitingBody);\n        }\n        maxDate = Math.min(maxDate, escapeDate);\n    } else {\n        maxDate = Math.min(maxDate, startDate + orbit.siderealPeriod * (nRevs + 1));\n    }\n\n    // perform search\n    const maxIters = escapes ? 1 : nRevs + 1;\n    let start = startDate;\n    let end = escapes ? escapeDate : start + orbit.siderealPeriod;\n    let interceptTime: number = Infinity;\n    let interceptBody: IOrbitingBody | undefined = undefined;\n    for(let i=0; i<maxIters; i++) {\n        for(let j=0; j<satelliteBodies.length; j++) {\n            const distObj = (d: number) => orbitDistanceFromBody(d, orbit, satelliteBodies[j]);\n            const minDistTime = brentMinimize(distObj, Math.min(start, Math.max(start, end)), end);\n            const minDist = distObj(minDistTime);\n            if(minDist < -10 && minDistTime < interceptTime) {\n                interceptTime = minDistTime;\n                interceptBody = satelliteBodies[j];\n            }\n        }\n        // stop the search once an intercept has been found, or if the specified endDate has been exceeded\n        if(interceptTime !== Infinity || end > endDate) {\n            break\n        }\n        end = maxDate + orbit.siderealPeriod;\n        start = end;\n    }\n\n    // if no intercepts were found\n    if(interceptBody === undefined) {\n        // if the orbit escapes from the attractor's SoI...\n        if(escapes && escapeDate <= maxDate) {\n            // if the attractor body is the sun (has infinite SoI), return null (there is no next orbit)\n            if(soi === Infinity) {\n                return null;\n            }\n            // otherwise, patch the orbit into the attractor body's attractor\n            const grandparentId = (attractor as IOrbitingBody).orbiting;\n            const grandparent = grandparentId === 0 ? system.sun : system.orbiterIds.get(grandparentId) as ICelestialBody;\n            const orbitState = Kepler.orbitToStateAtDate(orbit, attractor, escapeDate);\n            const bodyState  = Kepler.orbitToStateAtDate((attractor as IOrbitingBody).orbit, grandparent, escapeDate);\n            const postPatchState: OrbitalState = {\n                date: escapeDate,\n                pos:  add3(orbitState.pos, bodyState.pos),\n                vel:  add3(orbitState.vel, bodyState.vel)\n            }\n            return Kepler.stateToOrbit(postPatchState, grandparent);\n        // if the orbit does not escape, return null (there is no next orbit)\n        } else {\n            return null;\n        }\n    // If an intercept was found, patch the orbit into the SoI of the satellite body\n    } else {\n        // for the soonest intercept, get the date where the SoI patch occurs\n        const distObj = (d: number) => orbitDistanceFromBody(d, orbit, interceptBody as IOrbitingBody);\n        const rootFind = (s: number, e: number, iter=0): number => {try { return brentRootFind(distObj, s, e) } catch { if(iter>10) { return rootFind(s + 10, e, iter+1) } else { return NaN } }}\n        let soiPatchTime = rootFind(start, interceptTime);\n        // if(isNaN(soiPatchTime)) { return null; }\n        if(isNaN(soiPatchTime)) {\n            if(distObj(start) < 0) {\n                soiPatchTime = start;\n            } else {\n                return null;\n            }\n        }\n\n        const orbitState = Kepler.orbitToStateAtDate(orbit, attractor, soiPatchTime);\n        const bodyState  = Kepler.orbitToStateAtDate((interceptBody as IOrbitingBody).orbit, attractor, soiPatchTime);\n        const postPatchState: OrbitalState = {\n            date: soiPatchTime,\n            pos:  sub3(orbitState.pos, bodyState.pos),\n            vel:  sub3(orbitState.vel, bodyState.vel),\n        }\n        return Kepler.stateToOrbit(postPatchState, interceptBody as IOrbitingBody);\n    }\n}\n\n// function sortManeuvers(man1: Maneuver, man2: Maneuver): number {\n//     return man1.preState.date - man2.preState.date;\n// }\n\nexport function propagateFlightPlan(startOrbit: IOrbit, system: ISolarSystem, startDate: number, maneuverComponents: ManeuverComponents[], nRevs: number = 0): Trajectory[] {\n    // maneuvers should be in chronological order\n    const sortedManeuverComponents = [...maneuverComponents].sort((a,b) => a.date - b.date);\n    \n    // store the single-system trajectories in an array\n    const trajectories: Trajectory[] = [];\n\n    // propagate starting orbit forward\n    let orbits: IOrbit[] = [startOrbit];\n    let intersectTimes: number[] = [startDate];\n    let maneuvers: Maneuver[] = [];\n    let currentOrbit: IOrbit = startOrbit;\n    let sDate: number = startDate;\n    let eDate: number = Infinity;\n    // before each maneuver, check for intercepts up to the maximum specified nRevs\n    for(let i=0; i<=sortedManeuverComponents.length; i++) {\n        eDate = i !== sortedManeuverComponents.length ? sortedManeuverComponents[i].date : Infinity;\n        let nextOrbit: IOrbit | null = null;\n        let noPatchFound = false;\n        while(!noPatchFound) {\n            nextOrbit = findNextOrbit(currentOrbit, system, sDate, eDate, nRevs);\n            noPatchFound = nextOrbit === null;\n            if(!noPatchFound) {\n                sDate = (nextOrbit as IOrbit).epoch;\n                intersectTimes.push(sDate);\n\n                // since an SoI change happened, finish the current trajectory and start a new one\n                const traj: Trajectory = {\n                    orbits,        \n                    intersectTimes,\n                    maneuvers,\n                };\n                trajectories.push(traj);\n\n                orbits = [nextOrbit as IOrbit]\n                currentOrbit = nextOrbit as IOrbit;\n                intersectTimes = [sDate];\n                maneuvers = [];\n            }\n        }\n        if(i !== sortedManeuverComponents.length) {\n            const currentAttractor = currentOrbit.orbiting === 0 ? system.sun : system.orbiterIds.get(currentOrbit.orbiting) as IOrbitingBody;\n            const preState = Kepler.orbitToStateAtDate(currentOrbit, currentAttractor, sortedManeuverComponents[i].date)\n            const maneuver = Kepler.maneuverComponentsToManeuver(sortedManeuverComponents[i], preState);\n            nextOrbit = Kepler.stateToOrbit(maneuver.postState, currentAttractor)\n            sDate = nextOrbit.epoch;\n            intersectTimes.push(sDate);\n            orbits.push(nextOrbit);\n            maneuvers.push(maneuver);\n            currentOrbit = nextOrbit;\n        } else {\n            // finish off last trajectory\n            intersectTimes.push(Infinity);\n            const traj: Trajectory = {\n                orbits,        \n                intersectTimes,\n                maneuvers,\n            };\n            trajectories.push(traj);\n        }\n    }\n    return trajectories;\n}\n\nexport function propagateVessel(vessel: IVessel, system: ISolarSystem, startDate: number = vessel.orbit.epoch, nRevs: number = 0) {\n    return propagateFlightPlan(vessel.orbit, system, startDate, vessel.maneuvers, nRevs);\n}\n\nexport function vesselToFlightPlan(vessel: IVessel, system: ISolarSystem, color: IColor = {r: 255, g: 255, b: 255}, startDate: number = vessel.orbit.epoch, nRevs: number = 0): FlightPlan {\n    const fp = {\n        name:           vessel.name,\n        color,\n        trajectories:   propagateVessel(vessel, system, startDate, nRevs),\n    }\n    return fp;\n}\n\nexport function flightPlanToVessel(flightPlan: FlightPlan): IVessel {\n    const maneuvers: ManeuverComponents[] = flightPlan.trajectories.map(t => t.maneuvers.map(m => Kepler.maneuverToComponents(m))).flat();\n    return {\n        name:       flightPlan.name,\n        orbit:      flightPlan.trajectories[0].orbits[0],\n        maneuvers,         \n    }\n}\n\nexport default vesselToFlightPlan;","import SolarSystem from \"../main/objects/system\";\nimport vesselToFlightPlan from \"../main/libs/propagate\";\n\ndeclare var self: DedicatedWorkerGlobalScope;\nexport {};\n\nself.onmessage = (event: MessageEvent<{vesselPlans: IVessel[], system: SolarSystem}>) => {\n    const {vesselPlans, system} = event.data;\n    const flightPlans = vesselPlans.map(v => vesselToFlightPlan(v, system));\n    self.postMessage(flightPlans);\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [424], function() { return __webpack_require__(3510); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"e39a63f6\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/Kerbal-Transfer-Illustrator/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t510: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkkerbal_transfer_illustrator\"] = self[\"webpackChunkkerbal_transfer_illustrator\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(424).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["X_DIR","vec3","Y_DIR","Z_DIR","TWO_PI","Math","PI","HALF_PI","clamp","x","min","max","wrapAngle","angle","circles","floor","acosClamped","acos","copysign","y","isnegative","lerp","t","z","mult3","v","f","div3","add3","u","sub3","dot3","cross3","magSq3","mag3","sqrt","normalize3","roderigues","axis","c","cos","s","sin","v1","v2","v3","alignVectorsAngleAxis","xHat","yHat","counterClockwiseAngleInPlane","normalDirection","isNaN","xPlane","yPlane","xAngle","atan2","zxz","a1","a2","a3","c1","c2","c3","s1","s2","s3","GOLDEN_RATIO","brentRootFind","func","tol","maxIters","errtol","Number","EPSILON","a","b","fa","fb","sign","Error","abs","temp_a","temp_fa","fc","d","bisected","fs","itsRemaining","delta","currentStep","previousStep","secondStep","brentMinimize","GRsq","etol","h","w","fv","fw","fx","fu","m","p","q","e","newtonRootSolve","df","x0","eps","prevX","n","err","console","log","orbitDistanceFromBody","date","orbit","satelliteBody","orbitPos","Kepler","bodyPos","soi","findNextOrbit","system","startDate","endDate","Infinity","nRevs","attractor","orbiting","sun","orbiterIds","get","satelliteBodies","j","orbiters","length","id","push","maxDate","escapes","eccentricity","escapeDate","NaN","apoapsis","semiMajorAxis","maxDist","map","body","semiLatusRectum","DepartArrive","siderealPeriod","start","end","interceptTime","interceptBody","undefined","i","distObj","minDistTime","grandparentId","grandparent","orbitState","bodyState","postPatchState","pos","vel","rootFind","iter","soiPatchTime","propagateFlightPlan","startOrbit","maneuverComponents","sortedManeuverComponents","sort","trajectories","orbits","intersectTimes","maneuvers","currentOrbit","sDate","eDate","nextOrbit","noPatchFound","epoch","traj","currentAttractor","preState","maneuver","postState","propagateVessel","vessel","color","r","g","fp","name","self","onmessage","event","data","vesselPlans","flightPlans","vesselToFlightPlan","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","fulfilled","Object","keys","every","key","splice","definition","o","defineProperty","enumerable","chunkId","Promise","all","reduce","promises","miniCssF","obj","prop","prototype","hasOwnProperty","call","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}