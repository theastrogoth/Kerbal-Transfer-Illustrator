{"version":3,"file":"static/js/315.9996fa4e.chunk.js","mappings":"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","sources":["main/libs/transfer-calculator.ts","main/objects/transfer.ts"],"sourcesContent":["import Kepler from \"./kepler\";\nimport Trajectories from \"./trajectories\";\nimport Transfer from \"../objects/transfer\";\nimport { sub3, vec3, mag3, sphericalToCartesian, cartesianToSpherical, randomSign} from \"./math\";\nimport { nelderMeadMinimize } from \"./optim\";\n\nclass TransferCalculator {\n    private readonly _system:           ISolarSystem;\n    private _sequenceUp!:               number[];\n    private _sequenceDown!:             number[];\n\n    private _startOrbit:                IOrbit;\n    private _endOrbit:                  IOrbit;\n\n    private _startBody:                 ICelestialBody;\n    private _endBody:                   ICelestialBody;\n    private _transferBody:              ICelestialBody;\n\n    private _startDate:                 number;\n    private _flightTime:                number;\n    private _endDate:                   number;\n\n    private _transferTrajectory:        Trajectory;\n    private _ejections:                 Trajectory[];\n    private _insertions:                Trajectory[];\n\n    private _soiPatchPositions:         Vector3[];\n    private _soiPatchBodies:            ICelestialBody[];\n\n    private _ejectionInsertionType:     \"simple\" | \"direct\" | \"oberth\";\n\n    private _planeChange:               boolean;\n    private _noInsertionBurn:           boolean;\n    private _matchStartMo:              boolean;\n    private _matchEndMo:                boolean;\n\n    private _maneuvers:                 Maneuver[];\n    private _deltaV!:                   number;\n\n    constructor(inputs: TransferInputs) {\n        this._system        = inputs.system;\n        this._startOrbit    = inputs.startOrbit;\n        this._startBody     = (inputs.startBody) ? inputs.startBody : this.bodyFromId(this._startOrbit.orbiting);\n        this._endOrbit      = inputs.endOrbit;\n        this._endBody       = (inputs.endBody) ? inputs.endBody : this.bodyFromId(this._endOrbit.orbiting);\n        this._startDate     = inputs.startDate;\n        this._flightTime    = inputs.flightTime\n        this._endDate       = inputs.startDate + inputs.flightTime;\n\n        if(!inputs.transferBody) {\n            const startId = this._startBody.id;\n            const endId = this._endBody.id;\n            const transferId = this.commonAttractorId(startId, endId);\n            this._transferBody = this.bodyFromId(transferId);\n        } else {\n            this._transferBody = inputs.transferBody;\n        }\n\n        if(!inputs.sequenceUp) {\n            this.setSequenceUp();\n        } else {\n            this._sequenceUp = inputs.sequenceUp;\n        }\n\n        if(!inputs.sequenceDown) {\n            this.setSequenceDown();\n        } else {\n            this._sequenceDown = inputs.sequenceDown;\n        }\n\n        const soiPatchSequence = [...this._sequenceUp.slice(0, this._sequenceUp.length - 1), ...this._sequenceDown.slice(1, this._sequenceDown.length)];\n        this._soiPatchBodies = soiPatchSequence.map(i => this.bodyFromId(i));\n\n        this._ejectionInsertionType = inputs.ejectionInsertionType === undefined ? \"simple\" : inputs.ejectionInsertionType;\n        this._planeChange     = inputs.planeChange     === undefined ? false : inputs.planeChange;    \n        this._matchStartMo    = inputs.matchStartMo    === undefined ? true  : inputs.matchStartMo;\n        this._matchEndMo      = inputs.matchEndMo      === undefined ? false : inputs.matchEndMo;     \n        this._noInsertionBurn = inputs.noInsertionBurn === undefined ? false : inputs.noInsertionBurn;\n\n        // initialize arrays of orbits and maneuvers\n        this._transferTrajectory = {orbits: [], intersectTimes: [], maneuvers: []};\n        this._ejections = [];\n        this._insertions = [];\n        this._maneuvers = [];\n\n        // if not provided set all soi patch corrections to zero\n        if(!inputs.soiPatchPositions) {\n            this._soiPatchPositions = [];\n            for(let i=1; i<=this._soiPatchBodies.length; i++) {\n                this._soiPatchPositions.push(vec3(0.0, 0.0, 0.0));\n            }\n        } else {\n            this._soiPatchPositions = inputs.soiPatchPositions;\n        }\n\n        // compute the rest of the transfer information\n        this.computeTransfer();\n    }\n\n    public get deltaV() {\n        return this._deltaV;\n    }\n\n    public get ejectionDeltaV() {\n        return this._maneuvers[0].deltaV;\n    }\n\n    public get insertion() {\n        return this._maneuvers[this._maneuvers.length].deltaV;\n    }\n\n    public get data(): ITransfer {\n        return {\n            system:                 this._system,\n            startOrbit:             this._startOrbit,\n            endOrbit:               this._endOrbit,\n            startDate:              this._startDate,\n            flightTime:             this._flightTime,\n            endDate:                this._endDate,\n            transferTrajectory:     this._transferTrajectory,\n            ejections:   this._ejections,\n            insertions:  this._insertions,\n            maneuvers:              this._maneuvers,\n            deltaV:                 this._deltaV,\n            soiPatchPositions:      this._soiPatchPositions,\n            ejectionInsertionType:  this._ejectionInsertionType,\n            planeChange:            this._planeChange,\n            matchStartMo:           this._matchStartMo,\n            matchEndMo:             this._matchEndMo,\n            noInsertionBurn:        this._noInsertionBurn,\n            patchPositionError:     this.soiPatchPositionError(),\n            patchTimeError:         this.soiPatchTimeError(),\n        }\n    }\n\n    public get transfer() {\n        return new Transfer(this.data)\n    }\n\n    private clearOrbits() {\n        this._transferTrajectory = {orbits: [], intersectTimes: [], maneuvers: []};\n        this._ejections = [];\n        this._insertions = [];\n        this._maneuvers = [];\n    }\n\n    ///// Trajectory calculation /////\n\n    public computeTransfer() {\n        this.clearOrbits();\n        this.setTransferOrbit();\n        this.setEjectionOrbits();\n        this.setInsertionOrbits();\n        this.setDeltaV();        \n    }\n\n    private bodyFromId(id: number) {\n        if(id === 0) {\n            return this._system.sun;\n        } else {\n            const body = this._system.orbiterIds.get(id);\n            if(!body)\n                throw new Error(`No body with id ${id}`);\n            return body;\n        }\n    }\n\n    private sequenceToSun(id: number) {\n        let bd = this.bodyFromId(id);\n        let seq: number[] = [bd.id];\n        while(bd.hasOwnProperty(\"orbiting\")) {\n            bd = this.bodyFromId((bd as IOrbitingBody).orbiting);\n            seq.push(bd.id);\n        }\n        return seq\n    }\n\n    private commonAttractorId(id1: number, id2: number) {\n        const sunSeq1 = this.sequenceToSun(id1);\n        const sunSeq2 = this.sequenceToSun(id2);\n        for(let i=0; i<sunSeq1.length; i++) {\n            if(sunSeq2.includes(sunSeq1[i])) {\n                return sunSeq1[i]\n            }\n        }\n        throw new Error('Bodies do not share a common attractor (error in defining this SolarSystem)')\n    }\n\n    private setSequenceUp() {\n        let bd = this._startBody;\n        let seq: number[] = [this._startBody.id];\n        while(bd.id !== this._transferBody.id) {\n            if(bd.hasOwnProperty(\"orbiting\")) {\n                bd = this.bodyFromId((bd as IOrbitingBody).orbiting)\n                seq.push(bd.id)\n            } else {\n                throw new Error('The start body does not orbit around the transfer body')\n            }\n        }\n        this._sequenceUp = seq;\n    }\n\n    private setSequenceDown() {\n        let bd = this._endBody;\n        let seq: number[] = [this._endBody.id];\n        while(bd.id !== this._transferBody.id) {\n            if(bd.hasOwnProperty(\"orbiting\")) {\n                bd = this.bodyFromId((bd as IOrbitingBody).orbiting)\n                seq.push(bd.id)\n            } else {\n                throw new Error('The end body does not orbit around the transfer body')\n            }\n        }\n        this._sequenceDown = seq.reverse();\n    }\n\n    private setTransferOrbit() {\n        // Get the orbit/position at the start of the transfer\n        const sOrb = this._sequenceUp.length === 1 ? \n            this._startOrbit : \n            (this.bodyFromId(this._sequenceUp[this._sequenceUp.length - 2]) as IOrbitingBody).orbit;\n\n        const startPatchIdx = this._sequenceUp.length - 2;\n        const startPatchPos = startPatchIdx >= 0 ? this._soiPatchPositions[startPatchIdx] : vec3(0.0, 0.0, 0.0);\n\n        // Get the orbit/position at the end of the transfer\n        const eOrb = this._sequenceDown.length ===1 ? \n            this._endOrbit : \n            (this.bodyFromId(this._sequenceDown[1]) as IOrbitingBody).orbit;\n\n        const endPatchIdx = startPatchIdx + 1;\n        const endPatchPos = endPatchIdx <= this._soiPatchPositions.length ? this._soiPatchPositions[endPatchIdx] : vec3(0.0, 0.0, 0.0);\n\n        this._transferTrajectory = Trajectories.transferTrajectory(sOrb, eOrb, this._transferBody, this._startDate, this._flightTime, this._endDate, this._planeChange, startPatchPos, endPatchPos);\n\n        // If there are no ejection orbits, add the first burn maneuver to the list\n        if(this._sequenceUp.length === 1) {\n            this._maneuvers.push(this._transferTrajectory.maneuvers[0]);\n        }\n        // If there is a plane change burn, add it to the maneuver list\n        if(this._planeChange) {\n            this._maneuvers.push(this._transferTrajectory.maneuvers[1]);\n        }\n        // If there are no insertion orbits, add the last burn maneuver to the list\n        if(this._sequenceUp.length === 1) {\n            const transferLength = this._transferTrajectory.orbits.length;\n            this._maneuvers.push(this._transferTrajectory.maneuvers[transferLength]);\n        }\n    }\n\n    private setEjectionOrbits() {\n        const nEjections = this._sequenceUp.length - 1;\n        this._ejections = Trajectories.ejectionTrajectories(this._system, this._startOrbit, this._transferTrajectory.orbits[0], this._sequenceUp, this._startDate, \n                                                            this._matchStartMo, this._ejectionInsertionType, this._soiPatchPositions.slice(0, nEjections + 1));\n        // store ejection maneuvers\n        const ejectionManeuvers: Maneuver[] = [];\n        for(let i=0; i<nEjections; i++) {\n            if(i > 0) { // ignore the periapsis burn \n                ejectionManeuvers.push(...this._ejections[i].maneuvers.slice(1));\n            } else {    // except for the first ejection\n                ejectionManeuvers.push(...this._ejections[i].maneuvers);\n            }\n        }\n        this._maneuvers = [...ejectionManeuvers, ...this._maneuvers]\n    }\n\n    private setInsertionOrbits() {\n        const nEjections  = this._sequenceUp.length   - 1;\n        const nInsertions = this._sequenceDown.length - 1;\n        const transferLength = this._transferTrajectory.orbits.length;\n        this._insertions = Trajectories.insertionTrajectories(this._system, this._endOrbit, this._transferTrajectory.orbits[transferLength- 1], this._sequenceDown, this._endDate, \n                                                              this._matchEndMo, this._ejectionInsertionType, this._soiPatchPositions.slice(nEjections));\n        // store insertion orbits and maneuvers\n        for(let i=0; i<nInsertions; i++) {\n            if(i < nInsertions - 1) { // ignore the periapsis burn\n                this._maneuvers.push(...this._insertions[i].maneuvers.slice(0,-1));\n            } else {                  // except for the last insertion\n                this._maneuvers.push(...this._insertions[i].maneuvers)\n            }\n        }\n    }\n\n    private setDeltaV() {\n        let dv = 0;\n        for(let i=0; i<this._maneuvers.length; i++) {\n            dv += this._maneuvers[i].deltaVMag;\n        }\n        if (isNaN(dv)) {\n            dv = Number.MAX_VALUE;\n        }\n        this._deltaV = dv;\n    }\n\n    ///// SoI patch optimization /////\n\n    private calculateSoiPatches() {\n        const soiPatchPositions: Vector3[] = [];\n        for(let i=0; i<this._ejections.length; i++) {\n            const ejLen = this._ejections[i].orbits.length;\n            const ejOrbit = this._ejections[i].orbits[ejLen - 1];\n            const ejDate = this._ejections[i].intersectTimes[ejLen];\n            soiPatchPositions.push(Kepler.orbitToPositionAtDate(ejOrbit, ejDate));\n        }\n        for(let j=0; j<this._insertions.length; j++) {\n            const inOrbit = this._insertions[j].orbits[0];\n            const inDate = this._insertions[j].intersectTimes[0];\n            soiPatchPositions.push(Kepler.orbitToPositionAtDate(inOrbit, inDate));\n        }\n        return soiPatchPositions\n    }\n\n    private setSoiPatchPositions() {\n        this._soiPatchPositions = this.calculateSoiPatches();\n    }\n\n    private soiPatchPositionError() {\n        const soiPatchPositions = this.calculateSoiPatches();\n        let err = 0.0;\n        for(let i=0; i<this._soiPatchPositions.length; i++) {\n            err += mag3(sub3(this._soiPatchPositions[i], soiPatchPositions[i]));\n        }\n        return err;\n    }\n\n    private soiPatchUpTimeErrors() {\n        let errs: number[] = [];\n        const lastEjIdx = this._ejections.length - 1;\n        for(let i=0; i<=lastEjIdx; i++) {\n            const ejLen = this._ejections[i].orbits.length;\n            if(i === lastEjIdx) {\n                errs.push(this._ejections[i].intersectTimes[ejLen] - this._startDate);\n            } else{\n                errs.push(this._ejections[i].intersectTimes[ejLen] - this._ejections[i+1].orbits[0].epoch);\n            }\n        }\n        return errs;\n    }\n\n    private soiPatchDownTimeErrors() {\n        let errs: number[] = [];\n        for(let i=0; i<this._insertions.length; i++) {\n            if(i === 0 ) {\n                errs.push(this._insertions[i].intersectTimes[0] - this._endDate);\n            } else {\n                const prevInLen = this._insertions[i-1].orbits.length;\n                errs.push(this._insertions[i].intersectTimes[0] - this._insertions[i-1].intersectTimes[prevInLen]);\n            }\n        }\n        return errs;\n    }\n\n    private soiPatchTimeError() {\n        let err = 0.0;\n        const upErrs = this.soiPatchUpTimeErrors();\n        for(let i=0; i<upErrs.length; i++) {\n            err += Math.abs(upErrs[i]);\n        }\n        const downErrs = this.soiPatchDownTimeErrors();\n        for(let i=0; i<downErrs.length; i++) {\n            err += Math.abs(downErrs[i])\n        }\n        return err;\n    }\n\n    // private upTimeOffset() {\n    //     return this.soiPatchUpTimeErrors().reduce((p,c) => p + c);\n    // }\n\n    // private downTimeOffset() {\n    //     return this.soiPatchDownTimeErrors().reduce((p,c) => p + c);\n    // }\n\n    private patchPositionsToAngles(positions: Vector3[] = this._soiPatchPositions): number[] {\n        // angles are returned in a single vector, [theta_1, phi_1, theta_2, phi_2, ...]\n        const angles: number[] = [];\n        for(let i = 0; i<positions.length; i++) {\n            const sphericalPos = cartesianToSpherical(positions[i]);\n            angles.push(sphericalPos.theta, sphericalPos.phi);\n        }\n        return angles;\n    }\n\n    private setPatchPositionsFromAngles(angles: number[]) {\n        // angles should be arranged: [theta_1, phi_1, theta_2, phi_2, ...]\n        for(let i = 0; i < this._soiPatchBodies.length; i++) {\n            this._soiPatchPositions[i] = sphericalToCartesian({r: this._soiPatchBodies[i].soi, theta: angles[2*i], phi: angles[2*i + 1]});\n        }\n    }\n    \n    // private startDateOffset() {\n    //     let off = 0.0;\n    //     const lastEjIdx = this._ejections.length - 1;\n    //     if(lastEjIdx >= 0) {\n    //         const ejLen = this._ejections[lastEjIdx].orbits.length;\n    //         const ejTime = this._ejections[ejLen -1].intersectTimes[ejLen];\n    //         off += ejTime - this._startDate;\n    //     }\n    //     return off;\n    // }\n\n    // private endDateOffset() {\n    //     let off = 0.0;\n    //     if(this._insertions.length > 0) {\n    //         const inTime = this._insertions[0].intersectTimes[0];\n    //         off += inTime - this._endDate;\n    //     }\n    //     return off;\n    // }\n\n    public optimizeSoiPatchPositions(tol: number = 0.001, maxit: number = this._soiPatchPositions.length * 100) {\n        console.log(\"\\tOptimizing transfer SoI patch positions only.\")\n        if(this._soiPatchPositions.length === 0) {\n            return\n        }\n        if(mag3(this._soiPatchPositions[0]) === 0) {\n            this.setSoiPatchPositions();\n        }\n        const objective = (x: number[]): number => {\n            // x contains alternating theta and phi positions for each patch position\n            this.setPatchPositionsFromAngles(x);\n            this.computeTransfer();\n            return this.soiPatchPositionError() + 1000 * this._deltaV;\n        }\n        const initialPoints: number[][] = [this.patchPositionsToAngles()];\n        for(let i = 0; i < this._soiPatchBodies.length; i++) {\n            const newPoint1 = initialPoints[0].slice();\n            const newPoint2 = initialPoints[0].slice();\n            newPoint1[2 * i]     += randomSign() * (Math.random() * Math.PI / 24);\n            newPoint2[2 * i + 1] += randomSign() * (Math.random() * Math.PI / 12);\n            initialPoints.push(newPoint1);\n            initialPoints.push(newPoint2);\n        }\n        const optimizedPoint = nelderMeadMinimize(initialPoints, objective, tol, maxit);\n        this.setPatchPositionsFromAngles(optimizedPoint);\n        this.computeTransfer();\n    }\n\n    private initialPositionAndAnglePoints() {\n        const sOrb = this._sequenceUp.length === 1 ? \n        this._startOrbit : \n            (this.bodyFromId(this._sequenceUp[this._sequenceUp.length - 2]) as IOrbitingBody).orbit;\n        const eOrb = this._sequenceDown.length ===1 ? \n            this._endOrbit : \n            (this.bodyFromId(this._sequenceDown[1]) as IOrbitingBody).orbit;\n\n        const initialPoints: number[][] = [[this._startDate, this._flightTime, ...this.patchPositionsToAngles()],                                                                                           // current start and end dates\n                                           [this._startDate + randomSign() * Math.random() * this._transferTrajectory.orbits[0].siderealPeriod / 4, this._flightTime, ...this.patchPositionsToAngles()],    // perturb start date\n                                           [this._startDate, this._flightTime + randomSign() * Math.random() * this._transferTrajectory.orbits[0].siderealPeriod / 4, ...this.patchPositionsToAngles()]];   // perturb end date\n        for(let i = 1; i <= this._soiPatchBodies.length; i++) {                                                                                                                                             // perturb each SoI angle                  \n            const newPoint1 = initialPoints[0].slice();\n            const newPoint2 = initialPoints[0].slice();\n            newPoint1[2 * i]     += randomSign() * (Math.random() * Math.PI / 24);\n            newPoint2[2 * i + 1] += randomSign() * (Math.random() * Math.PI / 12);\n            initialPoints.push(newPoint1);\n            initialPoints.push(newPoint2);\n        }\n        return initialPoints;\n    }\n\n    public optimizeSoiPatchPositionsAndTimes(tol: number = 0.001, maxit = (this._soiPatchPositions.length + 2) * 100) {\n        console.log(\"\\tOptimizing transfer SoI patch positions and times.\")\n        if(this._soiPatchPositions.length === 0) {\n            return\n        }\n        if(mag3(this._soiPatchPositions[0]) === 0) {\n            this.setSoiPatchPositions();\n        }\n        const objective = (x: number[]): number => {\n            // the first two elements of x are the transfer start date and transfer end date\n            // the remaining elements of x contain alternating theta and phi positions for each patch position\n            this._startDate = x[0];\n            this._flightTime = x[1];\n            this._endDate = x[0] + x[1];\n            this.setPatchPositionsFromAngles(x.slice(2,x.length));\n            this.computeTransfer();\n            return this.soiPatchPositionError() + 10 * this.soiPatchTimeError() + 100 * this._deltaV;   // mixed units, so the coefficients here are arbitrary\n        }\n\n        const initialPoints = this.initialPositionAndAnglePoints();\n        const optimizedPoint = nelderMeadMinimize(initialPoints, objective, tol, maxit);\n        const optimizedPointObj = objective(optimizedPoint);\n        // console.log(this._soiPatchPositions)\n        // console.log(this.calculateSoiPatches())\n        // console.log(optimizedPointObj)\n    }\n\n    public optimizeSoiPatches() {\n        if(this._soiPatchPositions.length === 0) {\n            console.log(\"\\tThere are no SoI patches to optimize.\")\n        } else if((this._ejections.length === 0 || (this._ejections.length === 1 && !this._matchStartMo)) &&\n                  (this._insertions.length === 0 || (this._insertions.length === 1 && !this._matchEndMo))) {\n            this.optimizeSoiPatchPositions();\n        } else {\n            this.optimizeSoiPatchPositionsAndTimes();\n        }\n    }\n}\n\nexport default TransferCalculator","import SolarSystem from \"./system\";\nimport { OrbitingBody } from \"./body\";\nimport Orbit from \"./orbit\";\nimport TransferCalculator from \"../libs/transfer-calculator\";\nimport Kepler from \"../libs/kepler\";\nimport { wrapAngle } from \"../libs/math\";\n\n\nexport class Transfer implements ITransfer {\n    readonly system:                    SolarSystem;\n    readonly startOrbit:                Orbit;\n    readonly endOrbit:                  Orbit;\n    readonly startDate:                 number;\n    readonly flightTime:                number;\n    readonly endDate:                   number;\n    readonly transferTrajectory:        Trajectory;\n    readonly ejections:                 Trajectory[];\n    readonly insertions:                Trajectory[];\n    readonly maneuvers:                 Maneuver[];\n    readonly deltaV:                    number;\n    readonly soiPatchPositions:         Vector3[];\n    readonly ejectionInsertionType:     \"simple\" | \"direct\" | \"oberth\";\n    readonly planeChange:               boolean;\n    readonly noInsertionBurn:           boolean;\n    readonly matchStartMo:              boolean;\n    readonly matchEndMo:                boolean;\n\n    readonly patchPositionError:        number;\n    readonly patchTimeError:            number;\n\n    constructor(inputs: ITransfer) {\n        this.system = new SolarSystem(inputs.system.sun, inputs.system.orbiters);\n        this.startOrbit = new Orbit(inputs.startOrbit, this.system.bodyFromId(inputs.startOrbit.orbiting));\n        this.endOrbit = new Orbit(inputs.endOrbit, this.system.bodyFromId(inputs.endOrbit.orbiting));\n        this.startDate = inputs.startDate;\n        this.flightTime = inputs.flightTime;\n        if(inputs.endDate) {\n            this.endDate = inputs.endDate;\n        } else {\n            this.endDate = inputs.startDate + inputs.flightTime\n        };\n        this.transferTrajectory = inputs.transferTrajectory;\n        this.ejections = inputs.ejections;\n        this.insertions = inputs.insertions;\n        this.maneuvers = inputs.maneuvers;\n        this.deltaV = inputs.deltaV;\n\n        this.ejectionInsertionType = inputs.ejectionInsertionType;\n        this.planeChange     = inputs.planeChange;    \n        this.matchStartMo    = inputs.matchStartMo;\n        this.matchEndMo      = inputs.matchEndMo;       \n        this.noInsertionBurn = inputs.noInsertionBurn;\n\n        this.soiPatchPositions = inputs.soiPatchPositions;\n\n        this.patchPositionError = inputs.patchPositionError;\n        this.patchTimeError     = inputs.patchTimeError;\n    }\n\n    public get data(): ITransfer {\n        return {\n            system:                 this.system,\n            startOrbit:             this.startOrbit,\n            endOrbit:               this.endOrbit,\n            startDate:              this.startDate,\n            flightTime:             this.flightTime,\n            endDate:                this.endDate,\n            transferTrajectory:     this.transferTrajectory,\n            ejections:              this.ejections,\n            insertions:             this.insertions,\n            maneuvers:              this.maneuvers,\n            deltaV:                 this.deltaV,\n            soiPatchPositions:      this.soiPatchPositions,\n            ejectionInsertionType:  this.ejectionInsertionType,\n            planeChange:            this.planeChange,\n            matchStartMo:           this.matchStartMo,\n            matchEndMo:             this.matchEndMo,\n            noInsertionBurn:        this.noInsertionBurn,\n            patchPositionError:     this.patchPositionError,\n            patchTimeError:         this.patchTimeError,\n        }\n    }\n\n    public optimizeSoiPatches() {\n        const inputs: TransferInputs = {\n            system:             this.system,\n            startOrbit:         this.startOrbit,\n            endOrbit:           this.endOrbit,\n            startDate:          this.startDate,\n            flightTime:         this.flightTime,\n            soiPatchPositions:  this.soiPatchPositions,\n            planeChange:        this.planeChange,\n            matchStartMo:       this.matchStartMo, \n            matchEndMo:         this.matchEndMo,\n            noInsertionBurn:    this.noInsertionBurn,\n        }\n        const transferCalculator = new TransferCalculator(inputs);\n        transferCalculator.optimizeSoiPatches();\n        return transferCalculator.transfer;\n    }\n\n    public get transferBody() {\n        return this.system.bodyFromId(this.system.commonAttractorId(this.startOrbit.orbiting, this.endOrbit.orbiting));\n    }\n\n    public get startBody() {\n        return this.system.bodyFromId(this.startOrbit.orbiting);\n    }\n\n    public get endBody() {\n        return this.system.bodyFromId(this.endOrbit.orbiting);\n    }\n\n    public get phaseAngle() {\n        const sOrb = this.ejections.length === 0  ? this.startOrbit : (this.system.bodyFromId(this.ejections[this.ejections.length - 1].orbits[0].orbiting) as OrbitingBody).orbit;\n        const eOrb = this.insertions.length === 0 ? this.endOrbit   : (this.system.bodyFromId(this.insertions[0].orbits[0].orbiting) as OrbitingBody).orbit;\n        const sPos = Kepler.orbitToPositionAtDate(sOrb, this.startDate);    // start orbit position at start\n        const ePos = Kepler.orbitToPositionAtDate(eOrb, this.startDate);    // target position at start\n        const sAngle = Kepler.angleInOrbitPlane(sPos, sOrb);\n        const eAngle = Kepler.angleInOrbitPlane(ePos, sOrb);\n        return wrapAngle(eAngle - sAngle);\n    }\n}\n\nexport default Transfer;"],"names":["TransferCalculator","inputs","_system","_sequenceUp","_sequenceDown","_startOrbit","_endOrbit","_startBody","_endBody","_transferBody","_startDate","_flightTime","_endDate","_transferTrajectory","_ejections","_insertions","_soiPatchPositions","_soiPatchBodies","_ejectionInsertionType","_planeChange","_noInsertionBurn","_matchStartMo","_matchEndMo","_maneuvers","_deltaV","this","system","startOrbit","startBody","bodyFromId","orbiting","endOrbit","endBody","startDate","flightTime","transferBody","startId","id","endId","transferId","commonAttractorId","sequenceUp","setSequenceUp","sequenceDown","setSequenceDown","soiPatchSequence","slice","length","map","i","undefined","ejectionInsertionType","planeChange","matchStartMo","matchEndMo","noInsertionBurn","orbits","intersectTimes","maneuvers","soiPatchPositions","push","vec3","computeTransfer","deltaV","endDate","transferTrajectory","ejections","insertions","patchPositionError","soiPatchPositionError","patchTimeError","soiPatchTimeError","Transfer","data","clearOrbits","setTransferOrbit","setEjectionOrbits","setInsertionOrbits","setDeltaV","sun","body","orbiterIds","get","Error","bd","seq","hasOwnProperty","id1","id2","sunSeq1","sequenceToSun","sunSeq2","includes","reverse","sOrb","orbit","startPatchIdx","startPatchPos","eOrb","endPatchIdx","endPatchPos","Trajectories","transferLength","nEjections","ejectionManeuvers","nInsertions","dv","deltaVMag","isNaN","Number","MAX_VALUE","ejLen","ejOrbit","ejDate","Kepler","j","inOrbit","inDate","calculateSoiPatches","err","mag3","sub3","errs","lastEjIdx","epoch","prevInLen","upErrs","soiPatchUpTimeErrors","Math","abs","downErrs","soiPatchDownTimeErrors","positions","angles","sphericalPos","cartesianToSpherical","theta","phi","sphericalToCartesian","r","soi","tol","maxit","console","log","setSoiPatchPositions","objective","x","setPatchPositionsFromAngles","initialPoints","patchPositionsToAngles","newPoint1","newPoint2","randomSign","random","PI","optimizedPoint","nelderMeadMinimize","siderealPeriod","initialPositionAndAnglePoints","optimizeSoiPatchPositionsAndTimes","optimizeSoiPatchPositions","SolarSystem","orbiters","Orbit","transferCalculator","optimizeSoiPatches","transfer","sPos","ePos","sAngle","eAngle","wrapAngle"],"sourceRoot":""}